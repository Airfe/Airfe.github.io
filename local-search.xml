<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>https</title>
    <link href="/2024/04/12/https%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86/"/>
    <url>/2024/04/12/https%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="https机制原理"><a href="#https机制原理" class="headerlink" title="https机制原理"></a>https机制原理</h1><h2 id="网络传输的安全性"><a href="#网络传输的安全性" class="headerlink" title="网络传输的安全性"></a>网络传输的安全性</h2><ul><li>http 协议：不安全，未加密</li><li>https 协议：安全，对请求报文和响应报文做加密</li></ul><h2 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><ul><li><p>特点：</p><p>加解密使用 <strong>相同</strong> 秘钥 高效，适用于大量数据的加密场景 算法公开，安全性取决于秘钥大小，但秘钥越大效率越低，需要权衡在安全和效率中做权衡</p></li><li><p>缺点：</p><p>算法本身安全，但使用场景不够安全，因为解密和加密都是同一个秘钥。</p><blockquote><p>算法本身是难解密的，但是在网络传输中因为使用的是同一把钥匙，一开始就需要客户端将密钥传输给服务器，这个过程就有被劫持密钥的风险。</p></blockquote></li></ul><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><ul><li>使用 <strong>匹配的一对密钥</strong> 来<code>分别</code>进行加密和解密，分别是是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）</li><li><strong>公钥加密的数据 只能 用 对应的私钥解密，同理，私钥加密的数据 只能用 对应的公钥解密</strong></li><li>算法：RSA、ECC、Elgamal、背包算法、Rabin、D-H 等</li><li>特点：安全性高</li><li>缺点：加解密复杂，效率低，耗时较长</li><li>用法概要：<ul><li>加密：对数据做加密（公钥加密，私钥解密）</li><li>签名：证明数据是谁发的（私钥加密，公钥能解密就能证明）</li></ul></li></ul><h4 id="加密用法"><a href="#加密用法" class="headerlink" title="加密用法"></a>加密用法</h4><p><strong>场景：</strong> 用来针对互联网上加密数据传递</p><ul><li><p>准备工作：</p><ul><li>生成一对匹配的 私钥 和 公钥 (ps：公钥其实是根据私钥生成的)</li><li>将公钥公布给外界</li></ul></li><li><p>公钥加密：</p><ul><li>要发送数据的一方用公钥对数据进行加密，发送</li></ul></li><li><p>私钥解密</p><ul><li>接收到加密数据的一方用自身的私钥进行解密</li></ul><blockquote><p>因为一个公钥加密的数据只有对应的私钥才能解密，所以密文很安全 </p><p>补充：如果要在网络上相互发送密文，可以让对方也发对方的公钥过来，用对方的公钥来加密</p></blockquote></li></ul><h4 id="私钥签名"><a href="#私钥签名" class="headerlink" title="私钥签名"></a>私钥签名</h4><p><strong>场景：</strong> 目的是为了将明文公布给别人，同时证明是自己发的；可以防止明文被篡改。</p><p>以A向B发送”哈哈哈“为例解析私钥签名的过程：</p><ul><li><code>A</code>用<strong>自己的私钥</strong>对“哈哈哈”明文的<code>hsah</code>值进行加密形成签名，然后把签名和明文一并发送给B。</li></ul><blockquote><p>由于明文一般较长，故进行非对称加密的效率较差。hash以后得到的是固定长度的信息，可以提升加密效率。</p></blockquote><ul><li><p><code>B</code>用<strong>A的公钥</strong>对接收到的签名进行解密，对接收到的明文进行<code>hash</code>，通过对比解密后得到的明文hash值和接收到的明文hash值判断</p><p>发送者是否是<code>A</code></p></li></ul><h2 id="https协议安全传输原理"><a href="#https协议安全传输原理" class="headerlink" title="https协议安全传输原理"></a>https协议安全传输原理</h2><p><strong>HTTPS</strong>是运行在SSL&#x2F;TLS之上的 HTTP 协议，所有传输的内容都经过加密，加密采用的是<strong>对称加密</strong>，但<strong>对称加密的密钥</strong>用<strong>服务器证书进行了非对称加密</strong>。</p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>非对称加密之所以不安全，是因为客户端收到公钥之后，无法确定这把公钥是否是来自服务端。<strong>无法确定这把公钥是否是别人冒充</strong>的。</p><p>因此引入了拥有公信力的认证中心CA生成<strong>数字证书</strong>。服务器会用<strong>CA提供的私钥</strong>对消息摘要进行加密来形成数字签名。</p><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/markdown/image-20240413104635561.png" alt="image-20240413104635561"></p><p>并且，最后还会把原来没Hash算法之前的信息和数字签名合并在一起，形成<strong>数字证书</strong>。</p><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/markdown/image-20240413104433471.png" alt="image-20240413104433471"></p><p>当客户端拿到这份数字证书之后，就会用<strong>CA提供的公钥</strong>来对数字证书里面的<strong>数字签名</strong>进行解密得到<strong>消息摘要</strong>，然后对数字证书里面<strong>小服的公钥和个人信息</strong>进行Hash得到另一份<strong>消息摘要</strong>，然后把两份消息摘要进行对比，如果一样，则证明这些东西确实是小服的，否则就不是。</p><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/markdown/image-20240413104752001.png" alt="image-20240413104752001"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>https保障内容的安全传输的本质还是使用对称加密算法，但是对称加密的秘钥容易被窃取，因而又使用了非对称加密算法对秘钥进行加密，又为了保障非对称加密的公钥不被冒充（伪造），引入了数字证书。</p><ul><li>CA认证中心会生成<strong>数字证书</strong>，数字证书包含两个部分，一个是<strong>服务器的公钥和基本信息</strong>，另一个是经过认证中心对这些<strong>内容的消息摘要进行私钥加密</strong>后形成的<strong>数字签名</strong>。</li><li>当客户端拿到这份数字证书之后，会查看操作系统的证书拿到这个数字证书的CA公钥，来对数字证书里面的数字签名进行解密验证，如果验证通过就可以拿到<strong>这个确保数字证书里存放的服务器公钥不是伪造的</strong>。</li><li>确保<strong>拿到了服务器的公钥</strong>之后，浏览器就可以放心的把<strong>会话秘钥通过公钥以非对称加密的方式</strong>传递给服务器。</li><li><strong>服务器</strong>收到后，<strong>用私钥解密</strong>，<strong>获取</strong>到了浏览器的<strong>会话秘钥</strong>。</li><li>后续只需要使用共同的会话秘钥通过对称加密的方式，进行传输内容了</li><li>既保证了传输的安全性，又避免了一直使用非对称加密传输数据太大的问题</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7036551179517558791">https机制原理</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http</title>
    <link href="/2024/04/12/http/"/>
    <url>/2024/04/12/http/</url>
    
    <content type="html"><![CDATA[<h1 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h1><h2 id="TCP-x2F-IP概念层模型"><a href="#TCP-x2F-IP概念层模型" class="headerlink" title="TCP&#x2F;IP概念层模型"></a>TCP&#x2F;IP概念层模型</h2><table><thead><tr><th>TCP&#x2F;IP概念层模型</th><th>功能</th><th>TCP&#x2F;IP协议族</th></tr></thead><tbody><tr><td>应用层</td><td>文件传输，电子邮件，文件服务，虚拟终端</td><td>TFTP， <strong>HTTP</strong>，SNMP，FTP，SMTP，<strong>DNS</strong>，Telnet</td></tr><tr><td>传输层</td><td>提供端对端的接口</td><td><strong>TCP</strong>，UDP</td></tr><tr><td>网络层</td><td>为数据包选择路由</td><td>IP，ICMP， RIP，OSPF，BGP，IGMP</td></tr><tr><td>链路层</td><td>传输有地址的帧以及错误检测功能</td><td>SLIP，CSLIP，PPP，ARP，RARP，MTU</td></tr></tbody></table><p>要建立一次完整的TCP连接到关闭连接需要：<strong>①三次挥手</strong> –&gt; <strong>②四次挥手</strong></p><p>首先了解关于 <code>ACK</code>、<code>FIN</code>、<code>SYN</code> 状态码的含义：</p><ol><li><code>ACK</code> 用于确认，表示通知对方，我已经收到你发来的信息了。</li><li><code>FIN</code> 用于结束，表示告知对方，我这边已经结束，数据全部发送完毕，没有后续输出，请求终止连接。</li><li><code>SYN</code> 用于同步和建立连接，表示告知对方，我这边请求同步建立连接。</li></ol><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230427221904147.png" alt="image-20230427221904147"></p><p>可以简单理解：</p><blockquote><p>双方都要发送接收的信息：我想建立连接，对方得告诉我可以跟我建立连接</p><p>一共就是四个信息的传递，只不过是中间那次握手可以同时发送两个信息，四个信息加上三次握手，保证了连接的有效性和可靠性</p></blockquote><p>为什么不是两次握手？</p><p>如果采用两次握手建立连接，客户端向服务端发送了一个SYN包，因为一些未知原因没有发送成功而是滞留在网路中。此时客户端会重新</p><p>发送SYN包，服务器接收到后发送SYN+ACK包，建立起连接。在以后未知的某个时刻第一包数据阻塞的网络节点突然恢复，服务器会误以</p><p>为是客户端发送的连接请求，于是接收并回复SYN+ACK包亦建立起连接，最终会导致客户端和服务端的状态不一致。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230427221928592.png" alt="image-20230427221928592"></p><p>我想关闭连接，对方得考诉我可以关闭连接，对方赶紧把剩下的数据发过来并说他也想关闭连接，我收到数据告诉对方数据已经收到可以关闭连接。</p><p>后续我会继续等待一段时间后再进行关闭连接，因为担心我给对方发送的可以关闭信息没有成功发出，如果对方真没收到就会重新发送数据（重复一下第三次挥手），我还能做响应。</p><p>可以简单理解中间的两次挥手：</p><blockquote><p>FIN和ACK不能合并在一起的原因：（四次挥手）</p><p>发送FIN和ACK的时机不同，发送ACK是内核行为，发送FIN是应用程序行为，在代码中执行到对应的close()方法才会触发FIN。</p><p>但有时也会出现三次挥手。（FIN和ACK可以合并的情况）</p><p>如果程序能够很快地调用close()方法，FIN和ACK相隔时间不长，就会触发TCP的“延迟应答”和“捎带应答”机制。</p></blockquote><h2 id="URL和URI"><a href="#URL和URI" class="headerlink" title="URL和URI"></a>URL和URI</h2><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>URL是对于某种web资源的引用，并且包含了如何获取该资源的方式。 最常见到的场景就是指一个网站的地址，也就是你在浏览器地址栏</p><p>见到的那个东西。</p><p><code>https://www.google.com/search?q=url+vs+uri#showMeTheDifferences</code></p><p>一个URL由如下几个部分构成：</p><ul><li><p><strong>协议</strong>: 通常是<code>https</code>或者<code>http</code>。表示通过何种方式获取该资源。你可能还见过其他协议类型，比如<code>ftp</code>或者<code>file</code></p></li><li><p>协议后面跟着<code>://</code></p></li><li><p><strong>主机名</strong>: 可以是一个已经在DNS服务器注册过的域名 —— 或者是一个IP地址 —— 域名就表示背后的IP地址。一组主要由数字组成的用</p><p>于标识接入网络的设备的字符串。</p></li><li><p>主机名后面可以指定端口，端口是可选的，如果不指定则使用默认端口，端口和主机名之间通过冒号隔开。</p></li><li><p><strong>资源路径</strong>: 用于表示资源在主机上的文件系统路径。</p></li><li><p>可以在这之后通过问号连接可选的查询参数，如果有多个查询参数，通过&amp;符连接，一般用于 <code>GET</code> 查询。</p></li><li><p>最后一项，如果需要的话可以添加#作为需要跳转的页面上的矛点名称。</p></li></ul><h3 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h3><p>与<code>URL</code>相似的部分是，URI同样定义了资源的标识。但不同点在于URI通常不会包含获取资源的方式。</p><p>比如<code>ISBN</code>作为书目的资源定义就是一种<code>URI</code>，但不是<code>URL</code>。它清楚地为每一种出版的书目定义了唯一的数字编号，但没有包含任何如何</p><p>获取这种资源的方法。</p><p>总结：URI是URL的超集，URL是URI的子集。每一个URL都必定也是一个URI。</p><blockquote><p>The term “Uniform Resource Locator” (URL) refers to the subset of URIs that, in addition to identifying a resource, provide a means of locating the resource by describing its primary access mechanism.</p></blockquote><h2 id="各种协议与HTTP协议的关系"><a href="#各种协议与HTTP协议的关系" class="headerlink" title="各种协议与HTTP协议的关系"></a>各种协议与HTTP协议的关系</h2><p>当想要访问一个网址时：</p><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230427222011536.png" alt="image-20230427222011536"></p><ol><li><p>先用DNS解析成IP地址</p></li><li><p>HTTP生成HTTP请求报文</p></li><li><p>TCP将报文切割成一份一份报文段，方便传输</p></li><li><p>IP协议一边搜索一边中转</p></li><li><p>到达目标服务器后，TCP再将报文段按序号合并成报文</p></li><li><p>应用层的HTTP再对请求报文的内容进行处理。</p></li></ol><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>HTTP</strong> —— HyperText Transfer Protocol，超文本传输协议。是当今互联网上应用最为广泛的一种网络协议，所有的 WWW（万维网） 文件都必须遵守这个标</p><p>准。包括三个部分：超文本、传输、协议。</p><ul><li><p><strong>超文本</strong>：HTTP 传输的内容是「超文本」，字面意思就是超越了基本文字内容各种互联网内容，包括图片、音频、视频、压缩包、文件等，都是HTTP的「超文</p><p>本」，这些内容通过浏览器渲染展现出来，创造了丰富多彩的网络生活。</p></li><li><p><strong>传输</strong>：从一端（A）传输内容导另一端（B）的过程，就是传输，传输过程A、B是双向的。客户端（浏览器）向服务端请求网页数据，服务端收到请求后返回</p><p>对应的数据，客户端（浏览器）收到数据后渲染出网页展示给用户。</p></li><li><p><strong>协议</strong>：协议就是一种事先的约定规范，HTTP协议是面向计算机，用于计算机之间通信的规范，规范了内容的结构、行为、错误处理机制等。就像我们以前用</p><p>的“邮编+地址”也是一种通信协议。</p></li></ul><h2 id="协议结构"><a href="#协议结构" class="headerlink" title="协议结构"></a>协议结构</h2><ul><li><p><strong>HTTP的请求协议包括：4部分</strong>。请求行、请求头、空白行、请求体。</p><p>HTTP请求协议的具体报文：<strong>GET请求</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs http">GET /servlet05/getServlet?username=lucy&amp;userpwd=1111 HTTP/1.1 请求行<br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>localhost:8080 请求头开始<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">sec-ch-ua</span><span class="hljs-punctuation">: </span>“Google Chrome”;v=“95”, “Chromium”;v=“95”, “;Not A Brand”;v=“99”<br><span class="hljs-attribute">sec-ch-ua-mobile</span><span class="hljs-punctuation">: </span>?0<br><span class="hljs-attribute">sec-ch-ua-platform</span><span class="hljs-punctuation">: </span>“Windows”<br><span class="hljs-attribute">Upgrade-Insecure-Requests</span><span class="hljs-punctuation">: </span>1<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) <br>Chrome/95.0.4638.54<br>Safari/537.36<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,/;q=0.8,<br>application/signed-exchange;v=b3;q=0.9<br><span class="hljs-attribute">Sec-Fetch-Site</span><span class="hljs-punctuation">: </span>same-origin<br><span class="hljs-attribute">Sec-Fetch-Mode</span><span class="hljs-punctuation">: </span>navigate<br><span class="hljs-attribute">Sec-Fetch-User</span><span class="hljs-punctuation">: </span>?1<br><span class="hljs-attribute">Sec-Fetch-Dest</span><span class="hljs-punctuation">: </span>document<br><span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>http://localhost:8080/servlet05/index.html<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate, br<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.9  请求头结束<br>空白行<br>请求体<br></code></pre></td></tr></table></figure><p>HTTP请求协议的具体报文：<strong>POST请求</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs http">POST /servlet05/postServlet HTTP/1.1 请求行<br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>localhost:8080 请求头开始<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>25<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=0<br><span class="hljs-attribute">sec-ch-ua</span><span class="hljs-punctuation">: </span>“Google Chrome”;v=“95”, “Chromium”;v=“95”, “;Not A Brand”;v=“99”<br><span class="hljs-attribute">sec-ch-ua-mobile</span><span class="hljs-punctuation">: </span>?0<br><span class="hljs-attribute">sec-ch-ua-platform</span><span class="hljs-punctuation">: </span>“Windows”<br><span class="hljs-attribute">Upgrade-Insecure-Requests</span><span class="hljs-punctuation">: </span>1<br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>http://localhost:8080<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.54 Safari/537.36<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span><br>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,/;q=0.8,application/signed-exchange;v=b3;q=0.9<br><span class="hljs-attribute">Sec-Fetch-Site</span><span class="hljs-punctuation">: </span>same-origin<br><span class="hljs-attribute">Sec-Fetch-Mode</span><span class="hljs-punctuation">: </span>navigate<br><span class="hljs-attribute">Sec-Fetch-User</span><span class="hljs-punctuation">: </span>?1<br><span class="hljs-attribute">Sec-Fetch-Dest</span><span class="hljs-punctuation">: </span>document<br><span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>http://localhost:8080/servlet05/index.html<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate, br<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.9   请求头结束<br>空白行<br>username=lisi&amp;userpwd=123 请求体<br></code></pre></td></tr></table></figure><p><strong>请求行</strong>包括三部分：请求方式（GET、POST等7种） URL  HTTP协议版本</p><blockquote><p>请求方式、 HTTP协议版本发展历史后面会详细介绍</p></blockquote><p><strong>请求头</strong>中的字段为 <code>key: value</code>结构，按行分割。</p><table><thead><tr><th>常用请求头字段</th><th>描述</th></tr></thead><tbody><tr><td>Host</td><td>发送的目标，服务器的域名、端口号</td></tr><tr><td>Connection</td><td>网络连接方式，默认值<code>keep-alive</code>表示使用 TCP 持久连接，以便其他请求复用</td></tr><tr><td>Accept</td><td>告诉服务端可以接受的资源的（MME）类型</td></tr><tr><td>Accept-Encoding</td><td>告诉服务端可以支持哪些压缩方式，常用压缩方式：<code>gzip</code>主流、<code>deflate</code>、<code>br</code>HTTP专用压缩算法</td></tr><tr><td>Cookie</td><td>Cookie数据</td></tr><tr><td>User-Agent</td><td>浏览器表明自己的身份</td></tr><tr><td>Referer</td><td>表示请求引用自哪个地址</td></tr></tbody></table><blockquote><p>注意到get请求在“请求行”上发送数据，post请求将参数放在请求体中</p></blockquote></li><li><p><strong>HTTP的响应协议包括：4部分</strong>。状态行、响应头、空白行、响应体。</p><p>HTTP响应协议的具体报文：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> ok                                     状态行<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html;charset=UTF-8               响应头开始<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>160<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Mon, 08 Nov 2021 13:19:32 GMT<br><span class="hljs-attribute">Keep-Alive</span><span class="hljs-punctuation">: </span>timeout=20<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive                              响应头结束<br>                                                    空白行<br>&lt;!doctype html&gt;                                     响应体<br>&lt;html&gt;<br>    &lt;head&gt;<br>        &lt;title&gt;from get servlet&lt;/title&gt;<br>    &lt;/head&gt;<br>    &lt;body&gt;<br>        &lt;h1&gt;from get servlet&lt;/h1&gt;<br>    &lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><strong>状态行</strong>包括三部分：HTTP协议版本号（HTTP&#x2F;1.1） 状态码  状态的描述信息</p><blockquote><p>常见的状态码和其含义后面会详细介绍</p></blockquote><p><strong>响应头</strong>中的字段为 <code>key: value</code>结构，按行分割。</p><table><thead><tr><th>常用响应头字段</th><th>描述</th></tr></thead><tbody><tr><td>Content-Type</td><td>响应的资源类型</td></tr><tr><td>Content-Length</td><td>返回数据的长度</td></tr><tr><td>Content-Encoding</td><td>发送的实体数据采用的编码类型(压缩方式)，和Accept-Encoding对应</td></tr><tr><td>Server</td><td>表示服务器名称</td></tr><tr><td>Set-Cookie</td><td>后端设置的 Cookie 信息</td></tr><tr><td>Expires</td><td>缓存过期时长</td></tr></tbody></table><p><a href="https://link.juejin.cn/?target=https://tsejx.github.io/javascript-guidebook/computer-networks/http/http-headers">更多HTTP 首部字段</a></p><p><strong>响应体</strong>就是响应的正文，这些内容是一个长的字符串，这个字符串被浏览器渲染，解释并执行，最终展示出效果。</p></li></ul><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><table><thead><tr><th>状态码</th><th>描述</th><th>常用</th></tr></thead><tbody><tr><td><strong>1xx</strong></td><td>提示信息，处理的中间状态，很少用</td><td>无</td></tr><tr><td><strong>2xx</strong></td><td>处理成功的状态</td><td>- <code>200: OK</code> 成功，一切正常，最常用。<br>- <code>204: No Content</code> 成功但没有<code>body</code>数据<br>- <code>206: Partial Content</code> 成功但仍需继续，常用于分块下载、断点续传</td></tr><tr><td><strong>3xx</strong></td><td>重定向，客户端请求的资源发送了变动，需要重新发起请求继续处理</td><td>- <code>301: Moved Permanently</code> 永久重定向，请求的资源转移到了新URL<br>- <code>302: Found</code> 请求的页面临时移动到新URL，后续请求继续用原URL<br>- <code>304: Not Modified</code> 资源未修改，客户端缓存了资源，重定向到本地</td></tr><tr><td><strong>4xx</strong></td><td>客户端发生错误：语法、请求错误等，服务端无法处理</td><td>- <code>400: Bad Request</code> 请求的报文有错误，具体不明<br>- <code>403: Forbidden</code> 请求了服务端禁止访问的资源<br>- <code>404: Not Found</code> 请求的资源不存在、未找到</td></tr><tr><td><strong>5xx</strong></td><td>服务端发生错误：不能满足客户端请求</td><td>- <code>500: Internal Server Error</code>  服务端错误，具体不明 <br>- <code>501: Not Implemented</code>  还没实现，暂不支持<br>- <code>502: Bad Gateway</code>  网关、代理错误<br>- <code>503: Service Unavailable</code>  服务端很忙，请稍后再试</td></tr></tbody></table><ul><li><a href="https://link.juejin.cn/?target=http://quickref.mofe.io/docs/http-status-code.html">HTTP 状态码备忘清单</a></li></ul><h2 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h2><table><thead><tr><th>请求方式</th><th>描述</th></tr></thead><tbody><tr><td><strong>GET</strong></td><td>请求指定的页面数据，请求的参数放在URL地址中</td></tr><tr><td><strong>POST</strong></td><td>向指定资源提交数据，请求服务器处理，数据在请求体<code>body</code>中。数据可以是ASCII字符也可以是字节型数据</td></tr><tr><td>HEAD</td><td>类似GET请求，用于获取响应的头部信息，不返回内容。</td></tr><tr><td>PUT</td><td>即向指定资源位置上传其最新内容，可用于上传、更新资源。</td></tr><tr><td>DELETE</td><td>请求服务器删除所标识的资源</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td>OPTIONS</td><td>允许客户端访问服务器的性能</td></tr><tr><td>CONNECT</td><td>HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。</td></tr></tbody></table><blockquote><p>最常用的是GET、POST两种方式。RESful API 接口规范的一般会用到 <code>POST</code>、<code>DELETE</code>、<code>GET</code>、<code>PUT</code>（分别对应增删查改）。</p></blockquote><h3 id="GET、POST区别"><a href="#GET、POST区别" class="headerlink" title="GET、POST区别"></a>GET、POST区别</h3><table><thead><tr><th></th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td><strong>提交方式</strong></td><td>数据在url的问号<code>?</code>后：<code>url?key=value&amp;key=...</code></td><td>数据在请求体body中</td></tr><tr><td><strong>编码</strong>enctype</td><td>只有appliacation-x-www-form-urlencoded</td><td>支持多种</td></tr><tr><td><strong>书签&#x2F;历史</strong></td><td>可以加入收藏，历史记录、日志会保留数据</td><td>不可收藏、不会保留数据</td></tr><tr><td><strong>缓存&#x2F;效率</strong></td><td>可以被浏览器缓存，效率（速度）更高</td><td>不可缓存</td></tr><tr><td><strong>数据类型&#x2F;长度</strong></td><td>只允许 ASCII 字符，URL长度有限制（2048），不同浏览器不同</td><td>类型没有限制，支持二进制数据。长度（几乎）无限制</td></tr><tr><td><strong>安全性</strong></td><td>安全性更低，数据在URL中容易暴露</td><td>安全性稍高，不过传输过程也是明文的，不会在浏览记录、日志中存储</td></tr><tr><td><strong>回退&#x2F;刷新？</strong></td><td>无副作用（幂等），可重复访问，因为只是<strong>读取</strong>信息</td><td>有副作用，数据会被重新提交（不幂等）<br>浏览器一般会提示用户数据会被重新提交</td></tr><tr><td><strong>使用场景</strong></td><td>获取数据</td><td>提交数据：添加、修改、删除</td></tr></tbody></table><blockquote><p>「<strong>幂等</strong>」，意思是多次执行相同的操作，结果都是「相同」。</p><p>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</p></blockquote><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><p><strong>无状态</strong>。这意味着客户端和服务端之间无法知晓当前对方的状态信息，<code>HTTP</code> 请求本身是不带有任何状态存储的。但实际情况下，客户端和服务端必然需要状</p><p>态的认证和交互，所以就引入了 <code>Cookie</code>， 用于存储当前浏览器的一些状态信息，每次通过独立的 <code>HTTP</code> 请求进行收发，从而解决这个问题。</p></li><li><p><strong>请求互相独立</strong>。<code>HTTP</code> 互相之间都是一个独立的个体请求，在客户端请求网页时多数情况下并不是一次请求就能成功的，服务端首先是响应 <code>HTML</code> 页面，然后</p><p>浏览器收到响应之后发现页面还引用了其他的资源，例如，CSS，JS文件，图片等等，还会自动发送 <code>HTTP</code> 请求获取这些需要的资源。</p></li><li><p><strong>简单快速</strong>：客户向服务器请求服务的时候，只需要传送请求方法和路径，请求方法一般是get和post，因为HTTP协议简单，所以HTTP服务器的程序规模小，</p><p>通信速度快。</p></li><li><p><strong>灵活</strong>：HTTP协议运行传输任意类型的数据对象，传输的类型由Content-Type标记。</p></li></ul><h2 id="HTTP版本"><a href="#HTTP版本" class="headerlink" title="HTTP版本"></a>HTTP版本</h2><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230427222046465.png" alt="image-20230427222046465"></p><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h3><p>HTTP 1.0 是在 1996 年引入的，从那时开始，它的普及率就达到了惊人的效果。</p><ul><li>HTTP 1.0 仅仅提供了最基本的认证，这时候用户名和密码还未经加密，因此很容易收到窥探。</li><li>HTTP 1.0 被设计用来使用短链接，即每次发送数据都会经过 TCP 的三次握手和四次挥手，效率比较低。</li><li>HTTP 1.0 只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。</li><li>HTTP 1.0 不支持断点续传，也就是说，每次都会传送全部的页面和数据。</li><li>HTTP 1.0 认为每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname）。</li></ul><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h3><p>HTTP 1.1 是 HTTP 1.0 开发三年后出现的，也就是 1999 年，它做出了以下方面的变化</p><ul><li><p>默认使用<strong>长连接</strong>，也叫持久连接，建立一次TCP连接后可重复使用，一直保持TCP连接，任意一方主动断开才会结束连接。</p><ul><li>长连接的连接时长可以通过请求头中的 <code>keep-alive</code> 来设置</li></ul></li><li><p><strong>管道传输</strong>：不必串行排队等候了，可以并行连续发送多次请求，但<strong>服务端会顺序处理，顺序返回</strong>。</p></li><li><p><strong>增加Host请求头字段</strong>：WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点，这才实现了在一台WEB服务器上可以在同一个IP地址和端</p><p>口号上使用不同的主机名来创建多个虚拟WEB站点。</p></li><li><p><strong>节约带宽</strong>：HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求</p><p>body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。</p></li><li><p>HTTP 1.1 支持断点续传，通过使用请求头中的 <code>Range</code> 来实现。</p></li><li><p>HTTP 1.1 使用了摘要算法来进行身份验证</p></li><li><p>HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效。</p></li><li><p>HTTP 1.1 使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。</p></li></ul><h3 id="HTTP发展到1-1存在有哪些问题："><a href="#HTTP发展到1-1存在有哪些问题：" class="headerlink" title="HTTP发展到1.1存在有哪些问题："></a>HTTP发展到1.1存在有哪些问题：</h3><ul><li><strong>队头阻塞</strong>：虽然管道传输可以使得并行发送多个请求，但前面的请求未完成前，后续的请求都在排队等待，顺序执行没有优先级控制。</li><li><strong>Header</strong>：不支持压缩（只有Body支持压缩），每次相同的<code>header</code>浪费，特别是<code>Cookie</code>、<code>User Agent</code>等完全相同的首部。</li><li><strong>单向请求</strong>：客户端请求，服务端被动响应，服务端无法主动联系客户端。</li></ul><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230427222113280.png" alt="image-20230427222113280"></p><h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h3><p>HTTP 2.0 是 2015 年开发出来的标准，它主要做的改变如下</p><ul><li><p><code>头部压缩</code>，由于 HTTP 1.1 经常会出现 <strong>User-Agent、Cookie、Accept、Server、Range</strong> 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字</p><p>节，所以导致头部偏重。HTTP 2.0 使用 <code>HPACK</code> 算法进行压缩。</p></li><li><p><code>多路复用</code>，即每一个请求都是是用作连接共享。实现了真正的并行传输，它能够在一个TCP上进行任意数量HTTP请求。做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</p><ul><li>HTTP2.0里每个数据流都可以设置优先级和依赖，优先级高的数据流会被服务器优先处理和返回给客户端，数据流还可以依赖其他的子数据流。</li></ul></li><li><p><code>二进制格式</code>：HTTP2.0通过在应用层和传输层之间增加一个二进制分帧层（更加靠近 TCP&#x2F;IP 的二进制格式），突破了HTTP1.1的性能限制、改进传输性能。</p></li><li><p><code>服务器推送</code>：为了改善延迟，HTTP2.0引入了<code>server push</code>，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求</p><p>到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。</p><blockquote><p>服务端推送是一种在客户端请求之前发送数据的机制。</p><p>网页使用了许多资源：HTML、样式表、脚本、图片等等。在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取HTML开</p><p>始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。</p></blockquote></li><li><p><code>强化安全</code>，由于安全已经成为重中之重，所以 HTTP2.0 一般都跑在 HTTPS 上。</p></li></ul><h1 id="浏览器输入一个URL后发生了什么"><a href="#浏览器输入一个URL后发生了什么" class="headerlink" title="浏览器输入一个URL后发生了什么"></a>浏览器输入一个URL后发生了什么</h1><ol><li><p><strong>分析 url</strong>：判断输入的 url 是否合法，如果不合法浏览器会使用默认的搜索引擎进行搜索。如果输入的是一个域名，默认会加上一个 http 前缀。</p></li><li><p><strong>缓存判断</strong>：浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。</p></li><li><p><strong>DNS解析</strong>：检查浏览器本地hosts文件的缓存，如果没有会向本地 DNS 服务器发送请求进行递归查询，如果找到则返回，否则会向根 DNS 进行迭代查询。找</p><p>到域名和 ip 的关系后，把结果返回给用户，并把结果保存到缓存中。</p></li><li><p><strong>TCP 建立连接</strong>：拿到 ip 地址后，浏览器以一个随机端口与服务器的80端口建立TCP连接，并发送HTTP请求。</p></li><li><p><strong>处理请求</strong>：服务器收到 HTTP 请求报文后进行响应，返回 HTTP 响应报文。</p></li><li><p><strong>接收响应</strong>：浏览器收到 HTTP 响应报文后进行解析，首先查看响应报文在状态行的状态码，根据不同的状态码做不同的事，将渲染结果返回给用户并进行缓存。</p></li><li><p><strong>TCP 断开连接</strong>：通过 TCP 的四次挥手断开连接。</p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><p>《图解HTTP》</p></li><li><p><a href="https://juejin.cn/post/7078956663440408612#heading-3">HTTP协议、GET请求和POST请求的区别</a></p></li><li><p><a href="https://juejin.cn/post/7179037422653538364#heading-7">HTTP协议图文简述–HTTP&#x2F;HTTPS&#x2F;HTTP2</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript(五) 泛型</title>
    <link href="/2024/04/11/TypeScript(%E4%BA%94)%20%E6%B3%9B%E5%9E%8B/"/>
    <url>/2024/04/11/TypeScript(%E4%BA%94)%20%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>如果有这样的场景，定义一个函数，需要直接返回传入的参数，但是传入的参数未知。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">a:any</span>):any &#123;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure><p>但用any并不能体现出传入的类型和返回类型是相同的，而且也就相当于关闭了类型检查。</p><p><strong>在定义函数或是类时，遇到类型不明确就可以使用泛型</strong>。</p><p><strong>T 是一个抽象类型，只有在调用的时候才确定它的值。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> fn1&lt;K&gt;(<span class="hljs-attr">a</span>:K):K &#123;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-comment">// 泛型可以同时指定多个</span><br><span class="hljs-keyword">function</span> fn2&lt;T,K&gt;(<span class="hljs-attr">a</span>:T,<span class="hljs-attr">b</span>:K):T &#123;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-comment">// 可以直接调用具有泛型的函数</span><br><span class="hljs-title function_">fn1</span>(<span class="hljs-number">10</span>)  <span class="hljs-comment">// 不指定泛型，TS可以自动对类型进行推断</span><br>fn1&lt;string&gt;(<span class="hljs-string">&#x27;hello&#x27;</span>)  <span class="hljs-comment">// 指定泛型</span><br><br><span class="hljs-title function_">fn2</span>(<span class="hljs-number">123</span>,<span class="hljs-string">&#x27;hello&#x27;</span>)  <span class="hljs-comment">// 不指定泛型，TS可以自动对类型进行推断</span><br>fn2&lt;number,string&gt;(<span class="hljs-number">123</span>,<span class="hljs-string">&#x27;hello&#x27;</span>) <span class="hljs-comment">// 指定泛型</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;T&gt; &#123;<br>    <span class="hljs-attr">name</span>:T;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name:T</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// const mc = new MyClass(&#x27;孙悟空&#x27;)</span><br><span class="hljs-keyword">const</span> mc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>&lt;string&gt;(<span class="hljs-string">&#x27;孙悟空&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p> 使用 extends 关键字可以泛型约束。简单来说就是定义一个类型，然后让 T 实现这个接口即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Inter</span> &#123;<br>    <span class="hljs-attr">length</span>: number<br>&#125; <br><span class="hljs-comment">// T extends Inter 表示泛型T必须是Inter的实现类（子类）</span><br><span class="hljs-keyword">function</span> fn3&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Inter</span>&gt;(<span class="hljs-attr">a</span>:T):number &#123;<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-property">length</span><br>&#125;<br><span class="hljs-title function_">fn3</span>(<span class="hljs-string">&#x27;123&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript(四) 接口</title>
    <link href="/2024/04/11/TypeScript(%E5%9B%9B)%20%E6%8E%A5%E5%8F%A3/"/>
    <url>/2024/04/11/TypeScript(%E5%9B%9B)%20%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>先回顾一下在JavaScript中我们学习类时，提过类可以定义应该存在于实例上的成员、应该存在于原型上的成员，以及应该存在于类本身的成员。</p><ul><li>类通过类构造函数<strong>constructor()<strong>为</strong>实例</strong>添加属性和方法</li><li>类块中<strong>直接定义的方法</strong>会添加到<strong>原型</strong>上，所有实例共享。但类块中只能定义原型方法，不能添加属性。欲给原型添加属性，只能通过类在外部添加。</li><li>类中定义的静态方法即<strong>类方法</strong>，也称静态(static)方法只存在<strong>类本身</strong>，实例不会继承。同样类定义中不支持添加类成员数据。只能通过在类定义外部添加。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123; <br>    <span class="hljs-comment">// 类构造函数 -&gt; 实例</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-comment">// 添加到 this 的所有内容都会存在于不同的实例上</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">locate</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;instance&#x27;</span>, <span class="hljs-variable language_">this</span>); <br>    &#125; <br>    <span class="hljs-comment">// 等同于写在类构造函数constructor中</span><br>    name = <span class="hljs-string">&#x27;猪八戒&#x27;</span><br>    age = <span class="hljs-string">&#x27;18&#x27;</span><br><br>    <span class="hljs-comment">// 类块中直接定义方法 -&gt; 在类的原型对象上</span><br>    <span class="hljs-title function_">locate</span>(<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;prototype&#x27;</span>, <span class="hljs-variable language_">this</span>); <br>    &#125; <br><br>    <span class="hljs-comment">// 类方法</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">locate</span>(<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-variable language_">this</span>); <br>    &#125; <br>    <span class="hljs-comment">// 类属性</span><br>    <span class="hljs-keyword">static</span> color = <span class="hljs-string">&#x27;pink&#x27;</span><br><br>&#125; <br><br><span class="hljs-comment">// 手动外部添加原型属性</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Jake&#x27;</span>;<br><span class="hljs-comment">// 手动外部添加类属性</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property">greeting</span> = <span class="hljs-string">&#x27;My name is&#x27;</span>;<br></code></pre></td></tr></table></figure><p>在TypeScript中类中属性和方法经过编译为JS后依然符合以上规则。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 使用class关键字来定义一个类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// 定义实例属性</span><br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;孙悟空&#x27;</span>;<br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">18</span>;<br>    <span class="hljs-comment">// 在属性前使用static 关键字可以定义类属性（静态属性）</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-attr">color</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;pink&#x27;</span>;<br><br>    <span class="hljs-comment">// 定义原型方法,如果前面加了static就是类方法</span><br>    <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello 大家好&#x27;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">test1</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;test1&#x27;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> per = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(per.<span class="hljs-property">name</span>,per.<span class="hljs-property">age</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property">color</span>)<br><br>per.<span class="hljs-title function_">sayHello</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-title function_">test1</span>())<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-title function_">test2</span>())<br></code></pre></td></tr></table></figure><p>编译为JS后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-comment">// 使用class关键字来定义一个类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 定义实例属性</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;孙悟空&#x27;</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">18</span>;<br>    &#125;<br>    <span class="hljs-comment">// 定义原型方法,如果前面加了static就是类方法</span><br>    <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello 大家好&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">test1</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;test1&#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 在属性前使用static 关键字可以定义类属性（静态属性）</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;pink&#x27;</span>;<br><span class="hljs-keyword">const</span> per = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(per.<span class="hljs-property">name</span>, per.<span class="hljs-property">age</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property">color</span>);<br>per.<span class="hljs-title function_">sayHello</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-title function_">test1</span>());<br></code></pre></td></tr></table></figure><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>TypeScript 中的接口是一个非常灵活的概念，除了可以用来定义一个类结构，即一个类中应该包含的属性和方法；同时接口也可以当成类型声明去使用。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> myInterface &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:myInterface = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;sss&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">111</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>赋值的时候，变量的形状必须和接口的形状保持一致，比接口少一些或多一些属性都是不允许的。</p></blockquote><h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><p>可选属性的含义是该属性可以不存在。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    age?: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">tom</span>: <span class="hljs-title class_">Person</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h2><p>有时候我们希望一个接口中除了包含必选和可选属性之外，还允许有其他的任意属性，这时我们可以使用 <strong>索引签名</strong> 的形式来满足上述要求。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    age?: <span class="hljs-built_in">number</span>;<br>    [<span class="hljs-attr">propName</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">tom</span>: <span class="hljs-title class_">Person</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>需要注意的是，<strong>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-attr">name</span>: string;<br>    age?: number;<br>    [<span class="hljs-attr">propName</span>: string]: string;<br>&#125;<br><br><span class="hljs-comment">// 会报错，因为可选属性age的值是number，不是string的子属性，可以将上面任意属性改成 [propName: string]: string;</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">tom</span>: <span class="hljs-title class_">Person</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="绕开额外属性检查的方式"><a href="#绕开额外属性检查的方式" class="headerlink" title="绕开额外属性检查的方式"></a>绕开额外属性检查的方式</h2><h3 id="鸭式辨型法"><a href="#鸭式辨型法" class="headerlink" title="鸭式辨型法"></a>鸭式辨型法</h3><p>所谓的<strong>鸭式辨型法</strong>就是<code>像鸭子一样走路并且嘎嘎叫的就叫鸭子</code>，即具有鸭子特征的认为它就是鸭子，也就是通过制定规则来判定对象是否实现这个接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">LabeledValue</span> &#123;<br>    <span class="hljs-attr">label</span>: string;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printLabel</span>(<span class="hljs-params">labeledObj: LabeledValue</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(labeledObj.<span class="hljs-property">label</span>);<br>&#125;<br><span class="hljs-title function_">printLabel</span>(&#123; <span class="hljs-attr">size</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;Size 10 Object&quot;</span> &#125;); <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">LabeledValue</span> &#123;<br>  <span class="hljs-attr">label</span>: string;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printLabel</span>(<span class="hljs-params">labeledObj: LabeledValue</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(labeledObj.<span class="hljs-property">label</span>);<br>&#125;<br><span class="hljs-keyword">let</span> myObj = &#123; <span class="hljs-attr">size</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;Size 10 Object&quot;</span> &#125;;<br><span class="hljs-title function_">printLabel</span>(myObj); <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><p>参数里写对象就相当于是直接给<code>labeledObj</code>赋值，这个对象有严格的类型定义，所以不能多参或少参。</p><p>而当你在外面将该对象用另一个变量<code>myObj</code>接收，然后将这个<code>myObj</code>再赋值给<code>labeledObj</code>，此时根据类型的兼容性，两种类型对象，参照<strong>鸭式辨型法</strong>，因为都具有<code>label</code>属性，所以被认定为两个相同，故而可以用此法来绕开多余的类型检查。</p><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言的意义就等同于你在告诉程序，你很清楚自己在做什么，此时程序自然就不会再进行额外的属性检查了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Props</span> &#123; <br>  <span class="hljs-attr">name</span>: string;  <br>  money?: number;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">Props</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;兔神&quot;</span>,<br>  <span class="hljs-attr">money</span>: -<span class="hljs-number">100000</span>,<br>  <span class="hljs-attr">girl</span>: <span class="hljs-literal">false</span><br>&#125; <span class="hljs-keyword">as</span> <span class="hljs-title class_">Props</span>; <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><h3 id="索引签名"><a href="#索引签名" class="headerlink" title="索引签名"></a>索引签名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Props</span> &#123; <br>  <span class="hljs-attr">name</span>: string; <br>  money?: number;<br>  [<span class="hljs-attr">key</span>: string]: any;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">Props</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;兔神&quot;</span>,<br>  <span class="hljs-attr">money</span>: -<span class="hljs-number">100000</span>,<br>  <span class="hljs-attr">girl</span>: <span class="hljs-literal">false</span><br>&#125;; <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript(三) 打包</title>
    <link href="/2024/04/10/TypeScript(%E4%B8%89)%20%E6%89%93%E5%8C%85/"/>
    <url>/2024/04/10/TypeScript(%E4%B8%89)%20%E6%89%93%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript打包"><a href="#TypeScript打包" class="headerlink" title="TypeScript打包"></a>TypeScript打包</h1><p>以webpack为例介绍一下如何结合构建工具使用TS；</p><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>进入项目根目录，执行命令 <code> npm init -y</code>，创建package.json文件</p><h2 id="下载构建工具"><a href="#下载构建工具" class="headerlink" title="下载构建工具"></a>下载构建工具</h2><p>命令如下：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">npm i -<span class="hljs-keyword">D</span> webpack webpack-<span class="hljs-keyword">cli</span> webpack-dev-server typescript ts-loader clean-webpack-<span class="hljs-keyword">plugin</span><br></code></pre></td></tr></table></figure><p>共安装了7个包:</p><ul><li>webpack：构建工具webpack</li><li>webpack-cli：webpack的命令行工具</li><li>webpack-dev-server：webpack的开发服务器</li><li>typescript：ts编译器</li><li>ts-loader：ts加载器，用于在webpack中编译ts文件</li><li>html-webpack-plugin：webpack中html插件，用来<strong>自动创建html文件</strong></li><li>clean-webpack-plugin：webpack中的清除插件，每次构建都会先清除目录</li></ul><h2 id="配置webpack"><a href="#配置webpack" class="headerlink" title="配置webpack"></a>配置webpack</h2><p>根目录下创建webpack的配置文件<code>webpack.config.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;html-webpack-plugin&quot;</span>);<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">CleanWebpackPlugin</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;clean-webpack-plugin&quot;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>   <span class="hljs-attr">optimization</span>:&#123;<br>       <span class="hljs-attr">minimize</span>: <span class="hljs-literal">false</span> <span class="hljs-comment">// 关闭代码压缩，可选</span><br>   &#125;,<br>   <span class="hljs-comment">// 指定入口文件</span><br>   <span class="hljs-attr">entry</span>: <span class="hljs-string">&quot;./src/index.ts&quot;</span>,<br><br>   <span class="hljs-attr">devtool</span>: <span class="hljs-string">&quot;inline-source-map&quot;</span>,<br><br>   <span class="hljs-attr">devServer</span>: &#123;<br>       <span class="hljs-attr">contentBase</span>: <span class="hljs-string">&#x27;./dist&#x27;</span><br>   &#125;,<br>   <span class="hljs-comment">// 指定打包文件所在目录</span><br>   <span class="hljs-attr">output</span>: &#123;<br>       <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;dist&quot;</span>),<br>       <span class="hljs-comment">// 打包后的文件名</span><br>       <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;bundle.js&quot;</span>,<br>       <span class="hljs-attr">environment</span>: &#123;<br>           <span class="hljs-attr">arrowFunction</span>: <span class="hljs-literal">false</span> <span class="hljs-comment">// 关闭webpack的箭头函数，可选</span><br>       &#125;<br>   &#125;,<br>   <span class="hljs-comment">// 用来设置可以作为引用模块使用的文件</span><br>   <span class="hljs-attr">resolve</span>: &#123;<br>       <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&quot;.ts&quot;</span>, <span class="hljs-string">&quot;.js&quot;</span>]<br>   &#125;,  <br>   <span class="hljs-comment">// 指定webpack打包时要使用的模块</span><br>   <span class="hljs-attr">module</span>: &#123;<br>       <span class="hljs-comment">// 指定要加载的规则</span><br>       <span class="hljs-attr">rules</span>: [<br>           &#123;<br>               <span class="hljs-comment">// test指定规则生效文件，以ts结尾</span><br>               <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.ts$/</span>,<br>               <span class="hljs-comment">// 用ts-loader处理以ts结尾的文件</span><br>               <span class="hljs-attr">use</span>: &#123;<br>                   <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;ts-loader&quot;</span>     <br>               &#125;,<br>               <span class="hljs-comment">// 要排除的文件</span><br>               <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span><br>           &#125;<br>       ]<br>   &#125;,<br>   <span class="hljs-comment">// 配置webpack插件</span><br>   <span class="hljs-attr">plugins</span>: [<br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>(),<br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>           <span class="hljs-attr">title</span>:<span class="hljs-string">&#x27;TS测试&#x27;</span><br>       &#125;),<br>   ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="配置TS编译选项"><a href="#配置TS编译选项" class="headerlink" title="配置TS编译选项"></a>配置TS编译选项</h2><p>根目录下创建tsconfig.json，配置可以根据自己需要</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>       <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ES2015&quot;</span><span class="hljs-punctuation">,</span><br>       <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ES2015&quot;</span><span class="hljs-punctuation">,</span><br>       <span class="hljs-attr">&quot;strict&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>   <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="修改package-json配置"><a href="#修改package-json配置" class="headerlink" title="修改package.json配置"></a>修改package.json配置</h2><p>修改package.json添加如下配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>   ...<br>   <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>       <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><span class="hljs-punctuation">,</span><br>       <span class="hljs-comment">// 通过build命令来执行webpack，配置以后可以通过npm run build来执行webpack</span><br>       <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack&quot;</span><span class="hljs-punctuation">,</span><br>       <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack serve --open chrome.exe&quot;</span><br>   <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>   ...<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="项目使用"><a href="#项目使用" class="headerlink" title="项目使用"></a>项目使用</h2><p>在src下创建ts文件，并在命令行执行<code>npm run build</code>对代码进行编译；</p><p>或者执行<code>npm start</code>来启动开发服务器；</p><h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>除了webpack，开发中还经常需要结合babel来对代码进行转换；</p><p>以使其可以兼容到更多的浏览器，在上述步骤的基础上，通过以下步骤再将babel引入到项目中；</p><blockquote><p>虽然TS在编译时也支持代码转换，但是只支持简单的代码转换；</p><p>对于例如：Promise等ES6特性，TS无法直接转换，这时还要用到babel来做转换；</p></blockquote><p>安装依赖包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i -D @babel/core @babel/preset-env babel-loader core-js<br></code></pre></td></tr></table></figure><p>共安装了4个包，分别是：</p><ul><li>@babel&#x2F;core：babel的核心工具</li><li>@babel&#x2F;preset-env：babel的预定义环境，预定义不同浏览器的环境，但只是做简单的代码转换</li><li>@babel-loader：babel在webpack中的加载器</li><li>core-js：core-js用来使老版本的浏览器支持<strong>新版ES语法</strong></li></ul><p>修改webpack.config.js配置文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js">...<br><span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>        &#123;<br>            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.ts$/</span>,<br>            <span class="hljs-attr">use</span>: [<br>                <span class="hljs-comment">// 配置babel</span><br>                &#123;<br>                    <span class="hljs-comment">// 指定加载器</span><br>                    <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;babel-loader&quot;</span>,<br>                    <span class="hljs-attr">options</span>:&#123;<br>                        <span class="hljs-comment">// 设置预定义环境</span><br>                        <span class="hljs-attr">presets</span>: [<br>                            [<br>                                <span class="hljs-comment">// 指定环境的插件</span><br>                                <span class="hljs-string">&quot;@babel/preset-env&quot;</span>,<br>                                <span class="hljs-comment">// 配置信息</span><br>                                &#123;<br>                                    <span class="hljs-comment">// 要兼容的目标浏览器</span><br>                                    <span class="hljs-string">&quot;targets&quot;</span>:&#123;<br>                                        <span class="hljs-string">&quot;chrome&quot;</span>: <span class="hljs-string">&quot;58&quot;</span>,<br>                                        <span class="hljs-string">&quot;ie&quot;</span>: <span class="hljs-string">&quot;11&quot;</span><br>                                    &#125;,<br>                                    <span class="hljs-comment">// 指定corejs的版本</span><br>                                    <span class="hljs-string">&quot;corejs&quot;</span>:<span class="hljs-string">&quot;3&quot;</span>,<br>                                    <span class="hljs-comment">// 使用corejs的方式 &quot;usage&quot;  按需加载</span><br>                                    <span class="hljs-string">&quot;useBuiltIns&quot;</span>: <span class="hljs-string">&quot;usage&quot;</span>  <br>                                &#125;<br>                            ]<br>                        ]<br>                    &#125;<br>                &#125;,<br>                &#123;<br>                    <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;ts-loader&quot;</span>,<br><br>                &#125;<br>            ],<br>            <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span><br>        &#125;<br>    ]<br>&#125;<br>...<br></code></pre></td></tr></table></figure><p>如此一来，使用ts编译后的文件将会再次被babel处理；</p><p>使得代码可以在大部分浏览器中直接使用；</p><p>同时可以在配置选项的targets中指定要兼容的浏览器版本；</p>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript(二) 编译选项</title>
    <link href="/2024/04/09/TypeScript(%E4%BA%8C)%20%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9/"/>
    <url>/2024/04/09/TypeScript(%E4%BA%8C)%20%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h1><h2 id="自动编译文件"><a href="#自动编译文件" class="headerlink" title="自动编译文件"></a>自动编译文件</h2><p>编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tsc xxx.ts -w<br></code></pre></td></tr></table></figure><h2 id="自动编译整个项目"><a href="#自动编译整个项目" class="headerlink" title="自动编译整个项目"></a>自动编译整个项目</h2><p>如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。<strong>但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json</strong>。</p><h2 id="tsconfig-json介绍"><a href="#tsconfig-json介绍" class="headerlink" title="tsconfig.json介绍"></a>tsconfig.json介绍</h2><p>tsconfig.json 包含 TypeScript 编译的相关配置，通过更改编译配置项，我们可以让 TypeScript 编译出 ES6、ES5、node 的代码。</p><p>tsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译。</p><h2 id="tsconfig-json-重要配置选项"><a href="#tsconfig-json-重要配置选项" class="headerlink" title="tsconfig.json 重要配置选项"></a>tsconfig.json 重要配置选项</h2><ul><li>files - 设置要编译的文件的名称；</li><li>include - 设置需要进行编译的文件，支持路径模式匹配；</li><li>exclude - 设置无需进行编译的文件，支持路径模式匹配；</li><li>compilerOptions - 设置与编译流程相关的选项</li></ul><h2 id="compilerOptions-选项"><a href="#compilerOptions-选项" class="headerlink" title="compilerOptions 选项"></a>compilerOptions 选项</h2><ul><li>编译选项是配置文件中非常重要也比较复杂的配置选项</li><li>在compilerOptions中包含多个子选项，用来完成对编译的配置</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs ts">&#123;<br>  <span class="hljs-string">&quot;compilerOptions&quot;</span>: &#123;<br>  <br>    <span class="hljs-comment">/* 基本选项 */</span><br>    <span class="hljs-string">&quot;target&quot;</span>: <span class="hljs-string">&quot;es5&quot;</span>,                       <span class="hljs-comment">// 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES6&#x27;/&#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;</span><br>    <span class="hljs-string">&quot;module&quot;</span>: <span class="hljs-string">&quot;commonjs&quot;</span>,                  <span class="hljs-comment">// 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27;</span><br>    <span class="hljs-string">&quot;lib&quot;</span>: [],                             <span class="hljs-comment">// 指定要包含在编译中的库文件</span><br>    <span class="hljs-string">&quot;allowJs&quot;</span>: <span class="hljs-literal">true</span>,                       <span class="hljs-comment">// 允许编译 javascript 文件</span><br>    <span class="hljs-string">&quot;checkJs&quot;</span>: <span class="hljs-literal">true</span>,                       <span class="hljs-comment">// 报告 javascript 文件中的错误</span><br>    <span class="hljs-string">&quot;jsx&quot;</span>: <span class="hljs-string">&quot;preserve&quot;</span>,                     <span class="hljs-comment">// 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;</span><br>    <span class="hljs-string">&quot;declaration&quot;</span>: <span class="hljs-literal">true</span>,                   <span class="hljs-comment">// 生成相应的 &#x27;.d.ts&#x27; 文件</span><br>    <span class="hljs-string">&quot;sourceMap&quot;</span>: <span class="hljs-literal">true</span>,                     <span class="hljs-comment">// 生成相应的 &#x27;.map&#x27; 文件</span><br>    <span class="hljs-string">&quot;outFile&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                       <span class="hljs-comment">// 将输出文件合并为一个文件</span><br>    <span class="hljs-string">&quot;outDir&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                        <span class="hljs-comment">// 指定输出目录</span><br>    <span class="hljs-string">&quot;rootDir&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                       <span class="hljs-comment">// 用来控制输出目录结构 --outDir.</span><br>    <span class="hljs-string">&quot;removeComments&quot;</span>: <span class="hljs-literal">true</span>,                <span class="hljs-comment">// 删除编译后的所有的注释</span><br>    <span class="hljs-string">&quot;noEmit&quot;</span>: <span class="hljs-literal">true</span>,                        <span class="hljs-comment">// 不生成输出文件</span><br>    <span class="hljs-string">&quot;importHelpers&quot;</span>: <span class="hljs-literal">true</span>,                 <span class="hljs-comment">// 从 tslib 导入辅助工具函数</span><br>    <span class="hljs-string">&quot;isolatedModules&quot;</span>: <span class="hljs-literal">true</span>,               <span class="hljs-comment">// 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）.</span><br><br>    <span class="hljs-comment">/* 严格的类型检查选项 */</span><br>    <span class="hljs-string">&quot;strict&quot;</span>: <span class="hljs-literal">true</span>,                        <span class="hljs-comment">// 启用所有严格类型检查选项</span><br>    <span class="hljs-string">&quot;noImplicitAny&quot;</span>: <span class="hljs-literal">true</span>,                 <span class="hljs-comment">// 在表达式和声明上有隐含的 any类型时报错</span><br>    <span class="hljs-string">&quot;strictNullChecks&quot;</span>: <span class="hljs-literal">true</span>,              <span class="hljs-comment">// 启用严格的 null 检查</span><br>    <span class="hljs-string">&quot;noImplicitThis&quot;</span>: <span class="hljs-literal">true</span>,                <span class="hljs-comment">// 当 this 表达式值为 any 类型的时候，生成一个错误</span><br>    <span class="hljs-string">&quot;alwaysStrict&quot;</span>: <span class="hljs-literal">true</span>,                  <span class="hljs-comment">// 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27;</span><br><br>    <span class="hljs-comment">/* 额外的检查 */</span><br>    <span class="hljs-string">&quot;noUnusedLocals&quot;</span>: <span class="hljs-literal">true</span>,                <span class="hljs-comment">// 有未使用的变量时，抛出错误</span><br>    <span class="hljs-string">&quot;noUnusedParameters&quot;</span>: <span class="hljs-literal">true</span>,            <span class="hljs-comment">// 有未使用的参数时，抛出错误</span><br>    <span class="hljs-string">&quot;noImplicitReturns&quot;</span>: <span class="hljs-literal">true</span>,             <span class="hljs-comment">// 并不是所有函数里的代码都有返回值时，抛出错误</span><br>    <span class="hljs-string">&quot;noFallthroughCasesInSwitch&quot;</span>: <span class="hljs-literal">true</span>,    <span class="hljs-comment">// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span><br><br>    <span class="hljs-comment">/* 模块解析选项 */</span><br>    <span class="hljs-string">&quot;moduleResolution&quot;</span>: <span class="hljs-string">&quot;node&quot;</span>,            <span class="hljs-comment">// 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6)</span><br>    <span class="hljs-string">&quot;baseUrl&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                       <span class="hljs-comment">// 用于解析非相对模块名称的基目录</span><br>    <span class="hljs-string">&quot;paths&quot;</span>: &#123;&#125;,                           <span class="hljs-comment">// 模块名到基于 baseUrl 的路径映射的列表</span><br>    <span class="hljs-string">&quot;rootDirs&quot;</span>: [],                        <span class="hljs-comment">// 根文件夹列表，其组合内容表示项目运行时的结构内容</span><br>    <span class="hljs-string">&quot;typeRoots&quot;</span>: [],                       <span class="hljs-comment">// 包含类型声明的文件列表</span><br>    <span class="hljs-string">&quot;types&quot;</span>: [],                           <span class="hljs-comment">// 需要包含的类型声明文件名列表</span><br>    <span class="hljs-string">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 允许从没有设置默认导出的模块中默认导入。</span><br><br>    <span class="hljs-comment">/* Source Map Options */</span><br>    <span class="hljs-string">&quot;sourceRoot&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                    <span class="hljs-comment">// 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span><br>    <span class="hljs-string">&quot;mapRoot&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                       <span class="hljs-comment">// 指定调试器应该找到映射文件而不是生成文件的位置</span><br>    <span class="hljs-string">&quot;inlineSourceMap&quot;</span>: <span class="hljs-literal">true</span>,               <span class="hljs-comment">// 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span><br>    <span class="hljs-string">&quot;inlineSources&quot;</span>: <span class="hljs-literal">true</span>,                 <span class="hljs-comment">// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span><br><br>    <span class="hljs-comment">/* 其他选项 */</span><br>    <span class="hljs-string">&quot;experimentalDecorators&quot;</span>: <span class="hljs-literal">true</span>,        <span class="hljs-comment">// 启用装饰器</span><br>    <span class="hljs-string">&quot;emitDecoratorMetadata&quot;</span>: <span class="hljs-literal">true</span>          <span class="hljs-comment">// 为装饰器提供元数据的支持</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript(一) 简介和基本数据类型</title>
    <link href="/2024/04/09/TypeScript(%E4%B8%80)%20%E7%AE%80%E4%BB%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2024/04/09/TypeScript(%E4%B8%80)%20%E7%AE%80%E4%BB%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript简介"><a href="#TypeScript简介" class="headerlink" title="TypeScript简介"></a>TypeScript简介</h1><p>Typed JavaScript at Any Scale.</p><p>是以JavaScript为基础构建的语言，一个JavaScript的超集，扩展了JavaScript，并添加了类型。</p><p>TypeScript提供了一套静态类型检测机制, 可以帮助我们在编译时就发现错误。TS不能被JS解析器直接执行，需要<strong>编译</strong>为JS，浏览器才能执行。</p><blockquote><p>js中的类型只是针对值而言，在ts中类型可以设定在变量身上。</p></blockquote><p>TypeScript特点</p><ul><li>支持最新的JavaScript新特特性</li><li>支持代码静态检查</li><li>支持诸如C,C++,Java,Go等后端语言中的特性 (枚举、泛型、类型转换、命名空间、声明文件、类、接口等)</li></ul><h1 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h1><ol><li><p>下载并安装<strong>Node.js</strong></p></li><li><p>使用npm全局安装typescript编译器  <code>npm i -g typescript</code></p></li><li><p>创建一个ts文件</p></li><li><p>使用tsc对文件进行编译  <code>tsc xxx.ts</code></p></li><li><p>如果出现报错信息 tsc : 无法加载文件 D:\Nodejs\node_global\tsc.ps1，因为在此系统上禁止运行脚本……</p><p>原因：执行策略的问题（权限问题）</p><p>解决方法：<code>Set-ExecutionPolicy -Scope CurrentUser</code>     <code>RemoteSigned</code></p><p>只要查看<code>Get-ExecutionPolicy</code>  得到的结果是<code>RemoteSigned</code> 而不是 <code>Restricted</code>就已经成功解决</p></li></ol><h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><h2 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h2><ul><li><p>类型声明给变量（参数、形参）设置了类型，使得变量只能存储某种类型的值；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> 变量: 类型;<br><br><span class="hljs-keyword">let</span> 变量: 类型 = 值;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">参数: 类型, 参数: 类型</span>): 类型&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>自动类型判断</p><ul><li>TS拥有自动的类型判断机制</li><li>当<strong>同时声明变量且赋值</strong>，TS编译器会自动判断变量的类型</li><li>所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 如果变量的声明和赋值是同时进行的，TS可以自动对变量进行类型检查</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// b会有红色波浪线，因为TS编译器已经自动判断变量的类型为boolean</span><br>b = <span class="hljs-string">&#x27;hello&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><table><thead><tr><th><strong>类型</strong></th><th><strong>例子</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>number</td><td>1, -33, 2.5</td><td>任意数字</td></tr><tr><td>string</td><td>‘hi’, “hi”, <code>hi</code></td><td>任意字符串</td></tr><tr><td>boolean</td><td>true、false</td><td>布尔值true或false</td></tr><tr><td>字面量</td><td>其本身</td><td>限制变量的值就是该字面量的值</td></tr><tr><td>any</td><td>*</td><td>任意类型</td></tr><tr><td>unknown</td><td>*</td><td>类型安全的any</td></tr><tr><td>void</td><td>空值（undefined）</td><td>没有值（或undefined）</td></tr><tr><td>never</td><td>没有值</td><td>不能是任何值</td></tr><tr><td>object</td><td>{name:’孙悟空’}</td><td>任意的JS对象</td></tr><tr><td>array</td><td>[1,2,3]</td><td>任意JS数组</td></tr><tr><td>tuple</td><td>[4,5]</td><td>元素，TS新增类型，固定长度数组</td></tr><tr><td>enum</td><td>enum{A, B}</td><td>枚举，TS中新增类型</td></tr></tbody></table><p>TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了元组（Tuple）、Any、Unknown、Void、Never、枚举（enum）等实用的类型方便我们使用。</p><h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><p><strong>boolean</strong>、<strong>number</strong>、<strong>string</strong> 、<strong>null</strong>、<strong>undefined</strong>、**symbol **和 ES10 中的新类型 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt"><code>bigint </code></a>，这7种是原始类型。</p><h4 id="boolean-布尔值"><a href="#boolean-布尔值" class="headerlink" title="boolean(布尔值)"></a>boolean(布尔值)</h4><p>在<strong>TypeScript</strong>中，<code>boolean</code> 是 JavaScript 中的基本类型，而 <code>Boolean</code> 是 JavaScript 中的构造函数。其他基本类型（除了 <code>null</code> 和 <code>undefined</code>）一样。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 编译通过</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">isDone</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">createdByBoolean</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-title class_">Boolean</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 使用构造函数 Boolean 创造的对象不是布尔值，编译报错</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">createdByNewBoolean</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><blockquote><p><code>new Boolean()</code> 返回的是一个 <code>Boolean</code> 对象<code>let createdByNewBoolean: Boolean = new Boolean(1);</code></p></blockquote><h4 id="number和bigint"><a href="#number和bigint" class="headerlink" title="number和bigint"></a>number和bigint</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">big</span>: <span class="hljs-built_in">bigint</span> =  <span class="hljs-number">100n</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">6</span>;<br>big = num;<br>num = big;<br><span class="hljs-comment">// 会抛出一个类型不兼容的 ts(2322) 错误。</span><br></code></pre></td></tr></table></figure><h4 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string(字符串)"></a>string(字符串)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">myName</span>: string = <span class="hljs-string">&#x27;Tom&#x27;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">myAge</span>: number = <span class="hljs-number">25</span>;<br><br><span class="hljs-comment">// 模板字符串</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">sentence</span>: string = <span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;myName&#125;</span>.I&#x27;ll be <span class="hljs-subst">$&#123;myAge + <span class="hljs-number">1</span>&#125;</span> years old next month.`</span>;<br></code></pre></td></tr></table></figure><p>编译结果：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">var</span> myName = <span class="hljs-string">&#x27;Tom&#x27;</span>;<br><span class="hljs-keyword">var</span> myAge = <span class="hljs-number">25</span>;<br><span class="hljs-comment">// 模板字符串</span><br><span class="hljs-keyword">var</span> sentence = <span class="hljs-string">&quot;Hello, my name is &quot;</span> + myName + <span class="hljs-string">&quot;.I&#x27;ll be &quot;</span> + (myAge + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot; years old next month.&quot;</span>;<br></code></pre></td></tr></table></figure><p>其中 &#96; 用来定义 ES6 中的模板字符串，${expr} 用来在模板字符串中嵌入表达式。</p><h4 id="null和-undefined"><a href="#null和-undefined" class="headerlink" title="null和 undefined"></a>null和 undefined</h4><p>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。 就是说你可以把 <code>null</code> 和 <code>undefined</code> 赋值给其他类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">u</span>: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">n</span>: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">// null和undefined赋值给string</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">str</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;666&quot;</span>;<br>str = <span class="hljs-literal">null</span><br>str= <span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure><p>如果你在tsconfig.json指定了<code>&quot;strictNullChecks&quot;:true</code> ，<code>null</code> 和 <code>undefined</code> 只能赋值给 <code>void</code> 和它们各自的类型。</p><h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">sym</span>: <span class="hljs-built_in">symbol</span> = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;me&quot;</span>); <br></code></pre></td></tr></table></figure><h3 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h3><p>其他类型包括有<strong>enum</strong>、<strong>array</strong>、<strong>tuple</strong>、<strong>函数</strong>、<strong>void</strong>、<strong>never</strong>、<strong>any</strong>、<strong>unknown</strong>、<strong>Number、String、Boolean、Symbol</strong>、<strong>Object</strong></p><h4 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// enum 枚举</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Gender</span> &#123;<br>    <span class="hljs-title class_">Male</span> = <span class="hljs-number">0</span>,<br>    <span class="hljs-title class_">Female</span> = <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">i</span>:&#123;<span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span>,<span class="hljs-attr">gender</span>:<span class="hljs-title class_">Gender</span>&#125;<br><br>i = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;孙悟空&#x27;</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-title class_">Gender</span>.<span class="hljs-property">Male</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i.<span class="hljs-property">gender</span> === <span class="hljs-title class_">Gender</span>.<span class="hljs-property">Male</span>)<br></code></pre></td></tr></table></figure><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><h4 id="Tuple（元祖）"><a href="#Tuple（元祖）" class="headerlink" title="Tuple（元祖）"></a>Tuple（元祖）</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>];<br>x = [<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">10</span>]; <br></code></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><br></code></pre></td></tr></table></figure><h4 id="void（空值）"><a href="#void（空值）" class="headerlink" title="void（空值）"></a>void（空值）</h4><p>JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 <code>void</code> 表示没有任何返回值的函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">alertName</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;My name is Tom&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>声明一个 <code>void</code> 类型的变量没有什么用，因为你只能将它赋值为 <code>undefined</code> 和 <code>null</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">unusable</span>: <span class="hljs-built_in">void</span> = <span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure><p>与 <code>void</code> 的区别是，<code>undefined</code> 和 <code>null</code> 是所有类型的子类型。也就是说 <code>undefined</code> 类型的变量，可以赋值给 <code>number</code> 类型的变量：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 这样不会报错</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span> = u;<br></code></pre></td></tr></table></figure><p>而 <code>void</code> 类型的变量不能赋值给 <code>number</code> 类型的变量</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">u</span>: <span class="hljs-built_in">void</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span> = u;<br><span class="hljs-comment">// Type &#x27;void&#x27; is not assignable to type &#x27;number&#x27;.</span><br></code></pre></td></tr></table></figure><h4 id="never"><a href="#never" class="headerlink" title="never"></a>never</h4><p>表示那些永不存在的值的类型，值会永不存在的两种情况：</p><ol><li><p>如果一个函数执行时抛出了<strong>异常</strong>，那么这个函数永远不存在返回值（因为抛出异常会直接中断程序运行，这使得程序运行不到返回值那一步，即具有不可达的终点，也就永不存在返回了）；</p></li><li><p>函数中执行无限循环的代码（<strong>死循环</strong>），使得程序永远无法运行到函数返回值那一步，永不存在返回。</p></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 异常</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">err</span>(<span class="hljs-params">msg: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">never</span> &#123; <span class="hljs-comment">// OK</span><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(msg); <br>&#125;<br><br><span class="hljs-comment">// 死循环</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">loopForever</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">never</span> &#123; <span class="hljs-comment">// OK</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="any"><a href="#any" class="headerlink" title="any"></a>any</h4><p>在 TypeScript 中，任何类型都可以被归为 any 类型。这让 any 类型成为了类型系统的顶级类型.</p><p>如果是一个普通类型，在赋值过程中改变类型是不被允许的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;seven&#x27;</span>;<br>a = <span class="hljs-number">7</span>;<br><span class="hljs-comment">// TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span><br></code></pre></td></tr></table></figure><p>但如果是 <code>any</code> 类型，则允许被赋值为任意类型。在any上访问任何属性都是允许的,也允许调用任何方法.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">any</span> = <span class="hljs-number">666</span>;<br>a = <span class="hljs-string">&quot;Semlinker&quot;</span>;<br>a = <span class="hljs-literal">false</span>;<br>a = <span class="hljs-number">66</span><br>a = <span class="hljs-literal">undefined</span><br>a = <span class="hljs-literal">null</span><br>a = []<br>a = &#123;&#125;<br></code></pre></td></tr></table></figure><p>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型。如果我们使用 <code>any</code> 类型，就无法使用 TypeScript 提供的大量的保护机制。请记住，<code>any 是魔鬼！</code>尽量不要用any。为了解决 <code>any</code> 带来的问题，TypeScript 3.0 引入了 <code>unknown</code> 类型。</p><h4 id="unknow"><a href="#unknow" class="headerlink" title="unknow"></a>unknow</h4><p><code>unknown</code>与<code>any</code>一样，所有类型都可以分配给<code>unknown</code>。</p><blockquote><p>unknown与any的最大区别是：</p><p> 任何类型的值可以赋值给any，同时any类型的值也可以赋值给任何类型。unknown任何类型的值都可以赋值给它，但它只能赋值给unknown和any</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">notSure</span>: <span class="hljs-built_in">any</span> = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">uncertain</span>: <span class="hljs-built_in">number</span> = notSure; <span class="hljs-comment">// ok</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">notSure</span>: <span class="hljs-built_in">unknown</span> = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">uncertain</span>: <span class="hljs-built_in">number</span> = notSure; <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure><h4 id="Number、String、Boolean、Symbol"><a href="#Number、String、Boolean、Symbol" class="headerlink" title="Number、String、Boolean、Symbol"></a>Number、String、Boolean、Symbol</h4><p>这几种是相应原始类型的包装对象，姑且称之为对象类型。从类型兼容性上看，原始类型兼容对应的对象类型，反过来对象类型不兼容对应的原始类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Num</span>: <span class="hljs-title class_">Number</span>;<br><span class="hljs-title class_">Num</span> = num; <span class="hljs-comment">// ok</span><br>num = <span class="hljs-title class_">Num</span>; <span class="hljs-comment">// ts(2322)报错</span><br></code></pre></td></tr></table></figure><p><strong>不要使用对象类型来注解值的类型，因为这没有任何意义。</strong></p><h4 id="object、Object-和"><a href="#object、Object-和" class="headerlink" title="object、Object 和 {}"></a>object、Object 和 {}</h4><p>小 object 代表的是所有非原始类型，也就是说我们不能把原始类型赋值给 object。在严格模式下，<code>null</code> 和 <code>undefined</code> 类型也不能赋给 object。</p><p>大Object 代表所有拥有 toString、hasOwnProperty 方法的类型，所以所有原始类型、非原始类型都可以赋给 Object。同样，在严格模式下，null 和 undefined 类型也不能赋给 Object。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">lowerCaseObject</span>: <span class="hljs-built_in">object</span>;<br>lowerCaseObject = <span class="hljs-number">1</span>; <span class="hljs-comment">// ts(2322)</span><br>lowerCaseObject = <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// ts(2322)</span><br>lowerCaseObject = <span class="hljs-literal">null</span>; <span class="hljs-comment">// ts(2322)</span><br>lowerCaseObject = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// ts(2322)</span><br>lowerCaseObject = &#123;&#125;; <span class="hljs-comment">// ok</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">upperCaseObject</span>: <span class="hljs-title class_">Object</span>;<br>upperCaseObject = <span class="hljs-number">1</span>; <span class="hljs-comment">// ok</span><br>upperCaseObject = <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// ok</span><br>upperCaseObject = <span class="hljs-literal">null</span>; <span class="hljs-comment">// ts(2322)</span><br>upperCaseObject = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// ts(2322)</span><br>upperCaseObject = &#123;&#125;; <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><blockquote><p>{}、大 Object 是比小 object 更宽泛的类型（least specific），{} 和大 Object 可以互相代替，用来表示原始类型（null、undefined 除外）和非原始类型；而小 object 则表示非原始类型。</p></blockquote><p>{}用来指定对象中可以包含哪些属性，不能多也不能少，语法：{属性名：属性值,属性名：属性值}</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 加问号表示可选属性</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>:&#123;<span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span>,age?:<span class="hljs-built_in">number</span>,[<span class="hljs-attr">propName</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span> &#125;<br>b = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;孙悟空&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>通过<em>类型断言</em>这种方式可以告诉编译器，“相信我，我知道自己在干什么”。类型断言有两种形式。 </p><p>其一是“尖括号”语法：&lt;类型&gt;</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// string[]表示字符串数组</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">e</span>:<span class="hljs-built_in">string</span>[]<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">g</span>:<span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;<br></code></pre></td></tr></table></figure><p>另一个为<code>as</code>语法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (someValue <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure><p>以上两种方式虽然没有任何区别，但是尖括号格式会与react中JSX产生语法冲突，因此我们更推荐使用 as 语法。</p><h4 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言"></a>非空断言</h4><p>在上下文中当类型检查器无法断定类型时，一个新的后缀表达式操作符 <code>!</code> 可以用于断言操作对象是非 null 和非 undefined 类型。</p><p><strong>具体而言，x! 将从 x 值域中排除 null 和 undefined 。</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span> | <span class="hljs-built_in">string</span>;<br>a!.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// ok</span><br>a.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// ts(2531)</span><br></code></pre></td></tr></table></figure><h4 id="确定赋值断言"><a href="#确定赋值断言" class="headerlink" title="确定赋值断言"></a>确定赋值断言</h4><p>允许在实例属性和变量声明后面放置一个 <code>!</code> 号，从而告诉 TypeScript 该属性会被明确地赋值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> x!: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 如果是let x: number;会报异常</span><br><span class="hljs-title function_">initialize</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> * x); <span class="hljs-comment">// Ok</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initialize</span>(<span class="hljs-params"></span>) &#123;<br>  x = <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h2><p>在 TypeScript 中，字面量不仅可以表示值，还可以表示类型，即所谓的字面量类型。</p><p>目前，TypeScript 支持 3 种字面量类型：字符串字面量类型、数字字面量类型、布尔字面量类型。</p><p>对应的字符串字面量、数字字面量、布尔字面量分别拥有与其值一样的字面量类型。</p><h3 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">specifiedStr</span>: <span class="hljs-string">&#x27;this is string&#x27;</span> = <span class="hljs-string">&#x27;this is string&#x27;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;any string&#x27;</span>;<br>specifiedStr = str; <span class="hljs-comment">// ts(2322) 类型 &#x27;&quot;string&quot;&#x27; 不能赋值给类型 &#x27;this is string&#x27;</span><br>str = specifiedStr; <span class="hljs-comment">// ok ，但是&#x27;this is string&#x27;类型可以赋值给类型&quot;string&quot;，因为它本来就属于string的子类型</span><br></code></pre></td></tr></table></figure><h3 id="数字字面量类型和布尔字面量类型"><a href="#数字字面量类型和布尔字面量类型" class="headerlink" title="数字字面量类型和布尔字面量类型"></a>数字字面量类型和布尔字面量类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Config</span> &#123;<br>    <span class="hljs-attr">size</span>: <span class="hljs-string">&#x27;small&#x27;</span> | <span class="hljs-string">&#x27;big&#x27;</span>;<br>    <span class="hljs-attr">isEnable</span>:  <span class="hljs-literal">true</span> | <span class="hljs-literal">false</span>;<br>    <span class="hljs-attr">margin</span>: <span class="hljs-number">0</span> | <span class="hljs-number">2</span> | <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://ts.xcatliu.com/">TypeScript 入门教程</a></li><li><a href="https://jkchao.github.io/typescript-book-chinese/">深入理解 TypeScript</a></li><li><a href="https://www.tslang.cn/docs/home.html">TS官方文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>断点续存</title>
    <link href="/2024/03/21/%E6%96%AD%E7%82%B9%E7%BB%AD%E5%AD%98/"/>
    <url>/2024/03/21/%E6%96%AD%E7%82%B9%E7%BB%AD%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="断点续存"><a href="#断点续存" class="headerlink" title="断点续存"></a>断点续存</h1><p>原理：允许在上传中断后继续上传。根本上还是通过<strong>文件分片</strong>上传实现的，<strong>记录分片的上传情况</strong>和<strong>整体的上传进度</strong>，从而实现可以恢复之前进度的功能。</p><p>可以解决</p><ul><li>1G的文件按照正常的20M的带宽（上行20M已经属于很快的带宽），我们可能需要在页面停留大约9分钟（大概时间，甚至更久）。正常用户都无法忍受9分钟什么都不做，等着文件上传</li><li>由于文件过大，上传时间过长，中途断网或者浏览器崩溃，都会导致上传中断。可能就差几M就成功的文件，导致下次又要继续从头开始上传</li><li>同一个文件多次上传，浪费服务器资源</li></ul><h1 id="基于element-ui-自定义封装大文件上传组件"><a href="#基于element-ui-自定义封装大文件上传组件" class="headerlink" title="基于element-ui 自定义封装大文件上传组件"></a>基于element-ui 自定义封装大文件上传组件</h1><h2 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h2><ul><li>获取文件，调校验文件状态的接口，询问后端这个文件是否已上传，如果上传过的话后端会直接返回访问url，速度很快（秒传）；</li><li>如果上传过一部分分片，就根据返回已上传的分片信息，只选择哪些还没上传过的分片上传。</li><li>如果从来没有上传过，就上传所有的分片</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div class=&quot;big-file-box&quot;&gt;<br> &lt;div  @click=&quot;handleClick&quot;&gt;<br>     &lt;slot&gt;&lt;/slot&gt;<br>     &lt;input class=&quot;el-upload__input&quot; type=&quot;file&quot; ref=&quot;input&quot; name=&quot;请上传文件&quot; @change=&#x27;handleChange&#x27; :multiple=&#x27;multiple&#x27; :accept=&#x27;accept&#x27;&gt;&lt;/input&gt; <br> &lt;/div&gt;<br> &lt;slot name=&quot;tip&quot;&gt;&lt;/slot&gt;<br> &lt;div class=&quot;file-box&quot;&gt;<br>     &lt;transition-group tag=&quot;ul&quot;&gt;<br>         &lt;li v-for=&quot;item in uploadFiles&quot;<br>             :key=&quot;item.uid&quot;<br>             tabindex=&quot;0&quot;<br>             :class=&quot;&#123;&#x27;file-li&#x27;:true&#125;&quot;<br>             @mouseover=&quot;handleMouseover(item.uid)&quot;<br>             @mouseleave=&quot;handleMouseleave(item.uid)&quot;<br>         &gt;<br>             &lt;i class=&quot;el-icon-document&quot;&gt;&lt;/i&gt;<br>             &lt;span class=&quot;file-name&quot; @click=&quot;handleClickFile(item)&quot;&gt;&#123;&#123;item.name || item.url&#125;&#125;&lt;/span&gt;<br>             &lt;i v-if=&quot;item.status === &#x27;success&#x27;&quot; :class=&quot;item.uid === listChecked ? &#x27;el-icon-close deleteColor&#x27;: &#x27;el-icon-circle-check passColor&#x27;&quot; @click=&quot;hanldeRemoveFile(item)&quot;&gt;&lt;/i&gt;<br>             &lt;el-progress<br>                 v-if=&quot;item.status === &#x27;uploading&#x27;&quot;<br>                 type=&quot;line&quot;<br>                 :stroke-width=&quot;2&quot;<br>                 :percentage=&quot;Number(item.percentage.toFixed(1))&quot;&gt;<br>             &lt;/el-progress&gt;<br>         &lt;/li&gt;<br>     &lt;/transition-group&gt;<br>     &lt;/div&gt;<br> &lt;/div&gt;<br></code></pre></td></tr></table></figure><h3 id="第一步：选取文件"><a href="#第一步：选取文件" class="headerlink" title="第一步：选取文件"></a>第一步：选取文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 重置上一次的文件，接着主动触发input 的click事件</span><br><span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">input</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">input</span>.<span class="hljs-title function_">click</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第二步：判断文件规范性"><a href="#第二步：判断文件规范性" class="headerlink" title="第二步：判断文件规范性"></a>第二步：判断文件规范性</h3><ul><li><p>触发input的change事件，开始判断是否已选取文件，接着判断文件个数，如果超出限制，会直接终止当前逻辑并将文件，以及文件列表抛给父组件的onExceed 函数，父组件自行给出提示；</p></li><li><p>如果未超过限制，继续执行上传逻辑执行 upload 方法, upload 方法会调用beforeUpload 方法是否符合文件类型，如果返回ture, <strong>继续执行，开始读取大文件的md5</strong></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-title function_">handleChange</span>(<span class="hljs-params">ev</span>)&#123;<br>    <span class="hljs-keyword">const</span> files = ev.<span class="hljs-property">target</span>.<span class="hljs-property">files</span>;<br>    <span class="hljs-keyword">if</span> (!files) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">uploadExceedFiles</span>(files);<br>&#125;,<br><br><span class="hljs-title function_">uploadExceedFiles</span>(<span class="hljs-params">files</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">limit</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">fileList</span>.<span class="hljs-property">length</span> + files.<span class="hljs-property">length</span> &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">limit</span>) &#123;<br>        <span class="hljs-comment">//大于限制数量，父组件处理自己的逻辑</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onExceed</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onExceed</span>(files, <span class="hljs-variable language_">this</span>.<span class="hljs-property">fileList</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">upload</span>(files)<br>&#125;,<br><br><span class="hljs-keyword">async</span> <span class="hljs-title function_">upload</span>(<span class="hljs-params">files</span>)&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">beforeUpload</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">readFile</span>(files[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-keyword">const</span> before = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">beforeUpload</span>(files[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">if</span>(before) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">readFile</span>(files[<span class="hljs-number">0</span>])<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第三步：文件切片上传"><a href="#第三步：文件切片上传" class="headerlink" title="第三步：文件切片上传"></a>第三步：文件切片上传</h3><p>首先将文件开始切片,放入切片list中，接着开始读取文件，这里可以自行在父组件中调用 onReadingFile 方法设置loading状态，提升用户体验度。 接着会直接调用服务单接口，检查是否已经上传过，并将已上传的分片序号写入到一个isUploadChuncks list中，然后循环上传未上片段，这里会执行 onStart 方法，给每个文件一个初始对象，设置文件的初始状态，以及文件内容，插入到已上传的文件列表 uploadFiles 中，为后根据文件状态展示进度条，以及上传失败时删除对应文件列表做准备</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-title function_">readFile</span>(<span class="hljs-params">files</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sliceFile</span>(files);<br>    <span class="hljs-comment">//注意这里，开始读取文件，会回调父组件的onreadingFile,告诉组件开始读取，此时父组件开始设置读取的loading 状态，读取完成之后再次调用会返回end表示读取结束，此时将loading状态改为false</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onReadingFile</span>(<span class="hljs-string">&#x27;start&#x27;</span>);<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getFileMD5</span>(files);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onReadingFile</span>(<span class="hljs-string">&#x27;end&#x27;</span>);<br>    <span class="hljs-comment">//判断是否上传重复文件</span><br>    <span class="hljs-keyword">const</span> hasSameFile = <span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span> item.<span class="hljs-property">hash</span> ===data);<br>    <span class="hljs-keyword">if</span>(hasSameFile === -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">fileSparkMD5</span> = &#123;<span class="hljs-attr">md5Value</span>:data,<span class="hljs-attr">fileKey</span>:files.<span class="hljs-property">name</span>&#125;;<br>        <span class="hljs-keyword">const</span> hasChuncks = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">checkFile</span>(data,files.<span class="hljs-property">name</span>); <span class="hljs-comment">//是否上传过</span><br>        <span class="hljs-keyword">let</span> isSuccess = <span class="hljs-literal">true</span>; <span class="hljs-comment">//同步上传成功标记</span><br>        <span class="hljs-comment">//断点续传</span><br>        <span class="hljs-keyword">if</span>(hasChuncks) &#123;<br>            <span class="hljs-keyword">const</span> hasEmptyChunk = <span class="hljs-variable language_">this</span>.<span class="hljs-property">isUploadChuncks</span>.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item === <span class="hljs-number">0</span>);<br>            <span class="hljs-comment">//上传过,并且已经完整上传，直接提示上传成功（秒传）</span><br>            <span class="hljs-keyword">if</span>(hasEmptyChunk === -<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">let</span> file = &#123;<br>                    <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;success&#x27;</span>,<br>                    <span class="hljs-attr">percentage</span>: <span class="hljs-number">100</span>,<br>                    <span class="hljs-attr">uid</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() + <span class="hljs-variable language_">this</span>.<span class="hljs-property">tempIndex</span>++,<br>                    <span class="hljs-attr">hash</span>:data,<br>                    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br>                    <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;&#x27;</span><br>                &#125;;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>.<span class="hljs-title function_">push</span>(file);<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onSuccess</span>(file);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;  <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//处理续传逻辑，上传检测之后未上传的分片</span><br>                <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onStart</span>(files,data);<br>                <span class="hljs-keyword">const</span> emptyLength = <span class="hljs-variable language_">this</span>.<span class="hljs-property">isUploadChuncks</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item === <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">isUploadChuncks</span>.<span class="hljs-property">length</span>; k++) &#123;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">isUploadChuncks</span>[k] !== <span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-keyword">let</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>();<br>                        formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;totalNumber&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">fileChuncks</span>.<span class="hljs-property">length</span>);<br>                        formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;chunkSize&quot;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">chunckSize</span>);<br>                        formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;partNumber&quot;</span>,k);<br>                        formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;uuid&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">fileSparkMD5</span>.<span class="hljs-property">md5Value</span>);<br>                        formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">fileSparkMD5</span>.<span class="hljs-property">fileKey</span>);<br>                        formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;file&#x27;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>([<span class="hljs-variable language_">this</span>.<span class="hljs-property">fileChuncks</span>[k].<span class="hljs-property">fileChuncks</span>],<span class="hljs-variable language_">this</span>.<span class="hljs-property">fileSparkMD5</span>.<span class="hljs-property">fileKey</span>))<br>                        <span class="hljs-comment">//如果并发请求，走这里</span><br>                        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">concurrentUpload</span>) &#123;<br>                            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">post</span>(formData,k,emptyLength.<span class="hljs-property">length</span>,data); <br>                        &#125;<span class="hljs-keyword">else</span> &#123;<br>                            isSuccess = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">post</span>(formData,k,emptyLength.<span class="hljs-property">length</span>,data);<span class="hljs-comment">//这注意分片总数，因为进度条是根据分片个数来算的，所以分母应该是未上传的分片总数</span><br>                            <span class="hljs-keyword">if</span>(!isSuccess) &#123;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">//兼容并发与同步请求操作，受服务器带宽影响，做并发与同步请求处理</span><br>                <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">concurrentUpload</span>) &#123;<br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">uploadSuccess</span>();<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span>(isSuccess) &#123;<br>                        <span class="hljs-comment">//执行玩循环，如果isSuccess还是true,说明所有分片已上传，可执行合并文件接口</span><br>                        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">mergeFile</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">fileSparkMD5</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">fileChuncks</span>.<span class="hljs-property">length</span>);<br>                    &#125;<span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">hash</span> === <span class="hljs-variable language_">this</span>.<span class="hljs-property">fileSparkMD5</span>.<span class="hljs-property">md5Value</span>);<br>                        <span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>,index,&#123;...<span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>[index],...&#123;<span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;error&#x27;</span>&#125;&#125;); <span class="hljs-comment">//后续拓展继续上传时可用</span><br>                        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hanldeRemoveFile</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>[index]);<br>                        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onError</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>[index]);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onStart</span>(files,data);<br>            <span class="hljs-comment">// this.sliceFile(files);</span><br>            <span class="hljs-comment">//同步上传</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">fileChuncks</span>.<span class="hljs-property">length</span>; i++) &#123;<br>                <span class="hljs-keyword">let</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>();<br>                formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;totalNumber&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">fileChuncks</span>.<span class="hljs-property">length</span>);<br>                formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;chunkSize&quot;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">chunckSize</span>);<br>                formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;partNumber&quot;</span>,i);<br>                formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;uuid&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">fileSparkMD5</span>.<span class="hljs-property">md5Value</span>);<br>                formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">fileSparkMD5</span>.<span class="hljs-property">fileKey</span>);<br>                formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;file&#x27;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>([<span class="hljs-variable language_">this</span>.<span class="hljs-property">fileChuncks</span>[i].<span class="hljs-property">fileChuncks</span>],<span class="hljs-variable language_">this</span>.<span class="hljs-property">fileSparkMD5</span>.<span class="hljs-property">fileKey</span>));<br>                <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">concurrentUpload</span>) &#123;<br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">post</span>(formData,k,emptyLength.<span class="hljs-property">length</span>,data); <br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    isSuccess = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">post</span>(formData,i,<span class="hljs-variable language_">this</span>.<span class="hljs-property">fileChuncks</span>.<span class="hljs-property">length</span>,data);<span class="hljs-comment">//这注意分片总数，因为进度条是根据分片个数来算的，所以分母应该是未上传的分片总数</span><br>                    <span class="hljs-keyword">if</span>(!isSuccess) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//兼容并发与同步请求操作，受服务器带宽影响，做并发与同步请求处理</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">concurrentUpload</span>) &#123;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">uploadSuccess</span>();<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//循环所有的片段后，isSuccess依然为ture</span><br>                <span class="hljs-keyword">if</span>(isSuccess) &#123;<br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">mergeFile</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">fileSparkMD5</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">fileChuncks</span>.<span class="hljs-property">length</span>);<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">hash</span> === <span class="hljs-variable language_">this</span>.<span class="hljs-property">fileSparkMD5</span>.<span class="hljs-property">md5Value</span>);<br>                    <span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>,index,&#123;...<span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>[index],...&#123;<span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;error&#x27;</span>&#125;&#125;); <span class="hljs-comment">//后续拓展继续上传时可用</span><br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hanldeRemoveFile</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>[index]);<br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onError</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>[index]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$message</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Please do not upload the same file repeatedly&#x27;</span>);<br>    &#125;<br>&#125;,<br><br><span class="hljs-title function_">onStart</span>(<span class="hljs-params">rawFile,hash</span>) &#123;<br>    rawFile.<span class="hljs-property">uid</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() + <span class="hljs-variable language_">this</span>.<span class="hljs-property">tempIndex</span>++;<br>    <span class="hljs-keyword">let</span> file = &#123;<br>        <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;ready&#x27;</span>,<br>        <span class="hljs-attr">name</span>: rawFile.<span class="hljs-property">name</span>,<br>        <span class="hljs-attr">size</span>: rawFile.<span class="hljs-property">size</span>,<br>        <span class="hljs-attr">percentage</span>: <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">uid</span>: rawFile.<span class="hljs-property">uid</span>,<br>        <span class="hljs-attr">raw</span>: rawFile,<br>        hash<br>    &#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>.<span class="hljs-title function_">push</span>(file);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onChange</span>(file, <span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>);<br>&#125;,<br><br>sliceFile (file) &#123;<br>    <span class="hljs-comment">//文件分片之后的集合</span><br>    <span class="hljs-keyword">const</span> chuncks = [];<br>    <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span> ;<br>    <span class="hljs-keyword">let</span> end;<br>    <span class="hljs-keyword">while</span>(start &lt; file.<span class="hljs-property">size</span>) &#123;<br>        end = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(start + <span class="hljs-variable language_">this</span>.<span class="hljs-property">chunckSize</span>,file.<span class="hljs-property">size</span>);<br>        chuncks.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">fileChuncks</span>:file.<span class="hljs-title function_">slice</span>(start,end),<span class="hljs-attr">fileName</span>:file.<span class="hljs-property">name</span>&#125;); <br>        start = end;<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fileChuncks</span> = [...chuncks];<br>&#125;,<br><br> getFileMD5 (file)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> fileReader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>();<br>        fileReader.<span class="hljs-property">onload</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span>&#123;<br>            <span class="hljs-keyword">const</span> fileMd5 = <span class="hljs-variable language_">this</span>.<span class="hljs-property">SparkMD5</span>.<span class="hljs-property">ArrayBuffer</span>.<span class="hljs-title function_">hash</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>);<br>            <span class="hljs-title function_">resolve</span>(fileMd5)<br>        &#125;<br>        fileReader.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span>&#123;<br>            <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;file read failure&#x27;</span>,e)<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onError</span>(file,<span class="hljs-string">&#x27;file read failure&#x27;</span>)<br>        &#125;<br>        fileReader.<span class="hljs-title function_">readAsArrayBuffer</span>(file);<br>    &#125;)<br>&#125;,<br><br><span class="hljs-keyword">async</span> <span class="hljs-title function_">checkFile</span>(<span class="hljs-params">md5Hash,fileName</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123;code,data&#125; = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(&#123;<span class="hljs-attr">url</span>:<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.checkApi&#125;</span>?uuid=<span class="hljs-subst">$&#123;md5Hash&#125;</span>&amp;fileName=<span class="hljs-subst">$&#123;fileName&#125;</span>`</span>, <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>&#125;);<br>    <span class="hljs-keyword">if</span>(code === <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-keyword">if</span>(data.<span class="hljs-property">length</span>) &#123;<br>            <span class="hljs-keyword">const</span> newArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-title class_">Number</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">fileChuncks</span>.<span class="hljs-property">length</span>)).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// [1,1,0,1,1]</span><br>            <span class="hljs-keyword">const</span> chunckNumberArr = data.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item);<br>            chunckNumberArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item,index</span>) =&gt;</span> &#123;<br>                newArr[item] = <span class="hljs-number">1</span><br>            &#125;);<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">isUploadChuncks</span> = [...newArr];<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//并发请求，推入promise 数组中，通过allSettled 方法来判断，所有任务是否都为resove状态，如果有是，就进行合并文件</span><br><span class="hljs-title function_">uploadSuccess</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">promiseArr</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span>=&gt;</span>&#123;<br>        <span class="hljs-keyword">const</span> hasReject = result.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;rejected&#x27;</span>);<br>        <span class="hljs-keyword">if</span>(hasReject === -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">mergeFile</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">fileSparkMD5</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">fileChuncks</span>.<span class="hljs-property">length</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">hash</span> === result[hasReject].<span class="hljs-property">reason</span>);<br>            <span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>,index,&#123;...<span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>[index],...&#123;<span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;error&#x27;</span>&#125;&#125;); <span class="hljs-comment">//后续拓展继续上传时可用</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hanldeRemoveFile</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>[index]);<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onError</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>[index]);<br>        &#125;<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span>=&gt;</span>&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onError</span>(e);<br>    &#125;).<span class="hljs-title function_">finally</span>(<span class="hljs-function"><span class="hljs-params">e</span>=&gt;</span>&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">promiseArr</span> = [];<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadQuantity</span>  = <span class="hljs-number">0</span>; <span class="hljs-comment">//重置上传进度</span><br>    &#125;)<br>&#125;,<br><br></code></pre></td></tr></table></figure><p>上传逻辑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//file：当前文件，nowChunck:当前分片索引，totalChunck:当前需要上传文件分片的总数，hash:文件的唯一hash值</span><br><span class="hljs-keyword">async</span> <span class="hljs-title function_">post</span>(<span class="hljs-params">file,nowChunck,totalChunck,hash</span>) &#123;<br>    <span class="hljs-keyword">let</span> _this = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">const</span> index = _this.<span class="hljs-property">uploadFiles</span>.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">hash</span> === hash);<br>    _this.$set(_this.<span class="hljs-property">uploadFiles</span>,index,&#123;..._this.<span class="hljs-property">uploadFiles</span>[index],...&#123;<span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;uploading&#x27;</span>&#125;&#125;);<br>    <span class="hljs-keyword">const</span> curPormise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>        <span class="hljs-comment">// 当上传完成时调用</span><br>        xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>                <span class="hljs-keyword">const</span> index = _this.<span class="hljs-property">uploadFiles</span>.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">hash</span> === hash);<br>                <span class="hljs-comment">//大文件上传进度</span><br>                _this.<span class="hljs-property">uploadQuantity</span> ++;<br>                _this.$set(_this.<span class="hljs-property">uploadFiles</span>,index,&#123;..._this.<span class="hljs-property">uploadFiles</span>[index],...&#123;<span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;uploading&#x27;</span>,<span class="hljs-attr">percentage</span>:_this.<span class="hljs-property">uploadQuantity</span> / totalChunck * <span class="hljs-number">100</span>&#125;&#125;);<br>                _this.<span class="hljs-title function_">onProgress</span>(file,_this.<span class="hljs-property">uploadQuantity</span> / totalChunck * <span class="hljs-number">100</span>);<br>                <span class="hljs-title function_">resolve</span>(<span class="hljs-literal">true</span>);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                _this.<span class="hljs-property">errorChuncks</span>.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">file</span>:file,nowChunck,totalChunck,hash&#125;);<br>                <span class="hljs-title function_">reject</span>(<span class="hljs-literal">false</span>);<br>                _this.<span class="hljs-property">uploadQuantity</span> = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">const</span> index = _this.<span class="hljs-property">uploadFiles</span>.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">hash</span> === hash);<br>                _this.$set(_this.<span class="hljs-property">uploadFiles</span>,index,&#123;..._this.<span class="hljs-property">uploadFiles</span>[index],...&#123;<span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;error&#x27;</span>&#125;&#125;); <span class="hljs-comment">//后续拓展继续上传时可用</span><br>                _this.<span class="hljs-title function_">hanldeRemoveFile</span>(_this.<span class="hljs-property">uploadFiles</span>[index]);<br>                _this.<span class="hljs-title function_">onError</span>(_this.<span class="hljs-property">uploadFiles</span>[index]);<br>            &#125;<br>        &#125;<br>        xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>            _this.<span class="hljs-property">errorChuncks</span>.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">file</span>:file,nowChunck,totalChunck,hash&#125;);<br>            <span class="hljs-title function_">reject</span>(<span class="hljs-literal">false</span>)<br>            _this.<span class="hljs-property">uploadQuantity</span> = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">const</span> index = _this.<span class="hljs-property">uploadFiles</span>.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">hash</span> === hash);<br>            _this.$set(_this.<span class="hljs-property">uploadFiles</span>,index,&#123;..._this.<span class="hljs-property">uploadFiles</span>[index],...&#123;<span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;error&#x27;</span>&#125;&#125;); <span class="hljs-comment">//后续拓展继续上传时可用</span><br>            _this.<span class="hljs-title function_">hanldeRemoveFile</span>(_this.<span class="hljs-property">uploadFiles</span>[index]);<br>            _this.<span class="hljs-title function_">onError</span>(_this.<span class="hljs-property">uploadFiles</span>[index]);<br>        &#125;<br>        <span class="hljs-comment">// 发送请求</span><br>        xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, _this.<span class="hljs-property">uploadApi</span>, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">if</span> (_this.<span class="hljs-property">apiHeader</span>?.<span class="hljs-property">withCredentials</span> &amp;&amp; <span class="hljs-string">&#x27;withCredentials&#x27;</span> <span class="hljs-keyword">in</span> xhr) &#123;<br>            xhr.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">const</span> headers = _this.<span class="hljs-property">apiHeader</span> || &#123;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">in</span> headers) &#123;<br>            <span class="hljs-keyword">if</span> (headers.<span class="hljs-title function_">hasOwnProperty</span>(item) &amp;&amp; headers[item] !== <span class="hljs-literal">null</span>) &#123;<br>                xhr.<span class="hljs-title function_">setRequestHeader</span>(item, headers[item]);<br>            &#125;<br>        &#125;<br>        xhr.<span class="hljs-title function_">send</span>(file);<br>    &#125;);<br>    _this.<span class="hljs-property">promiseArr</span>.<span class="hljs-title function_">push</span>(curPormise);<br>    <span class="hljs-keyword">return</span> curPormise;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第四步：合并文件"><a href="#第四步：合并文件" class="headerlink" title="第四步：合并文件"></a>第四步：合并文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> mergeFile (fileInfo,chunckTotal)&#123;<br>    <span class="hljs-keyword">const</span> &#123; md5Value,fileKey &#125;  = fileInfo;<br>    <span class="hljs-keyword">const</span> params = &#123;<br>        <span class="hljs-attr">totalNumber</span>:chunckTotal,<br>        <span class="hljs-attr">md5</span>:md5Value,<br>        <span class="hljs-attr">name</span>:fileKey<br>    &#125;<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">hash</span> === md5Value);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> &#123;code,data&#125; = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(&#123;<span class="hljs-attr">url</span>:<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.mergeApi&#125;</span>?uuid=<span class="hljs-subst">$&#123;md5Value&#125;</span>`</span>, <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>&#125;);<br>        <span class="hljs-keyword">if</span>(code === <span class="hljs-number">200</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>,index,&#123;...<span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>[index],...&#123;<span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;success&#x27;</span>,<span class="hljs-attr">url</span>:data&#125;&#125;); <span class="hljs-comment">//记得绑定url</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onSuccess</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>[index],data);<br>        &#125;<br>    &#125;<span class="hljs-keyword">catch</span>(e) &#123;<br>        <span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>,index,&#123;...<span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>[index],...&#123;<span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;error&#x27;</span>,<span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;&#x27;</span>&#125;&#125;); <span class="hljs-comment">//记得绑定url</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hanldeRemoveFile</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>[index]);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onError</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadFiles</span>[index]);<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadQuantity</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">errorChuncks</span> = [];<br>&#125;,<br><br></code></pre></td></tr></table></figure><p>案例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;<span class="hljs-title class_">BigUpload</span> :<span class="hljs-title class_">SparkMD5</span>=<span class="hljs-string">&quot;SparkMD5&quot;</span> :request=<span class="hljs-string">&quot;request&quot;</span> <br>    :uploadApi=<span class="hljs-string">&quot;uploadApi&quot;</span> <br>    :mergeApi=<span class="hljs-string">&quot;mergeApi&quot;</span> <br>    :checkApi=<span class="hljs-string">&quot;checkApi&quot;</span><br>    :fileList=<span class="hljs-string">&quot;videoFileList&quot;</span><br>    :on-change=<span class="hljs-string">&quot;onChange&quot;</span><br>    :on-remove=<span class="hljs-string">&quot;handleRemove&quot;</span><br>    :on-progress=<span class="hljs-string">&quot;onProgress&quot;</span><br>    :before-upload=<span class="hljs-string">&quot;beforeUpload&quot;</span><br>    :on-exceed=<span class="hljs-string">&quot;onExceed&quot;</span><br>    :on-success=<span class="hljs-string">&quot;onSuccess&quot;</span><br>    :on-error=<span class="hljs-string">&quot;onError&quot;</span><br>    :on-preview=<span class="hljs-string">&quot;onPreview&quot;</span><br>    :on-reading-file=<span class="hljs-string">&quot;onReadingFile&quot;</span><br>    :limit=<span class="hljs-string">&quot;10&quot;</span><br>    :apiHeader=<span class="hljs-string">&quot;apiHeader&quot;</span><br>    :accept=<span class="hljs-string">&#x27;`mp4,avi,mov,wmv,3gp`&#x27;</span><br>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;disabledUpload&quot;</span> <span class="hljs-attr">:loading</span>=<span class="hljs-string">&quot;loadingUpload&quot;</span>&gt;</span>&#123;&#123;loadingUpload ? $t(&#x27;workGuide.FileLoading&#x27;) : $t(&#x27;workGuide.ClickToUpload&#x27;) &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br>     <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;tip&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;el-upload__tip&quot;</span>&gt;</span>只能上传mp4,avi,mov,wmv,3gp文件，且不超过2G<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/<span class="hljs-title class_">BigUpload</span>&gt;<br><br><span class="hljs-title function_">onChange</span>(<span class="hljs-params">file,fileList</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">disabledUpload</span> = <span class="hljs-literal">true</span>;<br>&#125;,<br><br><span class="hljs-comment">//读取文件回调，大文件读取耗时较长，给一个loading状态过度</span><br><span class="hljs-title function_">onReadingFile</span>(<span class="hljs-params">value</span>)&#123;<br>    value === <span class="hljs-string">&#x27;start&#x27;</span> ?  <span class="hljs-variable language_">this</span>.<span class="hljs-property">loadingUpload</span> = <span class="hljs-literal">true</span> : <span class="hljs-variable language_">this</span>.<span class="hljs-property">loadingUpload</span> = <span class="hljs-literal">false</span>;<br>&#125;,<br><br><span class="hljs-title function_">beforeUpload</span>(<span class="hljs-params">file</span>) &#123;<br>    <span class="hljs-keyword">const</span> type = file.<span class="hljs-property">type</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;/&#x27;</span>)[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">const</span> isVideo = type === <span class="hljs-string">&#x27;video&#x27;</span>;<br>    <span class="hljs-keyword">const</span> isLt2G = file.<span class="hljs-property">size</span> / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> &lt; <span class="hljs-number">2048</span>;<br>    <span class="hljs-keyword">if</span> (!isLt2G) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$message</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.$t(<span class="hljs-string">&#x27;KOLProductBoard.MaximumSizeImages&#x27;</span>,&#123;<span class="hljs-attr">m</span>:<span class="hljs-string">&#x27;2048&#x27;</span>&#125;))<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isVideo) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$message</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.$t(<span class="hljs-string">&#x27;workGuide.uploadFormatTip&#x27;</span>,&#123;<span class="hljs-attr">m</span>:<span class="hljs-string">&#x27;mp4,avi,mov,wmv,3gp&#x27;</span>&#125;))<br>    &#125;<br>    <span class="hljs-keyword">return</span> isVideo &amp;&amp; isLt2G;<br>&#125;,<br><br><span class="hljs-comment">//超过最大上传数量回调</span><br><span class="hljs-title function_">onExceed</span>(<span class="hljs-params">file,fileList</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$message</span>.<span class="hljs-title function_">warning</span>(<span class="hljs-variable language_">this</span>.$t(<span class="hljs-string">&#x27;KOLProductBoard.MaximumLimitImages&#x27;</span>, &#123; <span class="hljs-attr">m</span>: <span class="hljs-string">&#x27;10&#x27;</span>&#125;));<br>&#125;,<br><br><span class="hljs-comment">//上传进度回调</span><br><span class="hljs-title function_">onProgress</span>(<span class="hljs-params">file,percentage</span>) &#123;<br><br>&#125;,<br><br><span class="hljs-comment">//预览回调</span><br><span class="hljs-title function_">onPreview</span>(<span class="hljs-params">&#123;url&#125;</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">bigImageUrl</span> = url;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">showBigImage</span> = <span class="hljs-literal">true</span>;<br>&#125;,<br><br><span class="hljs-title function_">onSuccess</span>(<span class="hljs-params">file,url</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">videoFileList</span>.<span class="hljs-title function_">push</span>(file);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">disabledUpload</span> = <span class="hljs-literal">false</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$message</span>.<span class="hljs-title function_">success</span>(<span class="hljs-variable language_">this</span>.$t(<span class="hljs-string">&#x27;KOL需求管理.UploadSuccessful&#x27;</span>));<br>&#125;,<br><br><span class="hljs-title function_">onError</span>(<span class="hljs-params">file,reason</span>) &#123;<br>    <span class="hljs-comment">//reason 是在浏览器读取文件失败时特有的参数</span><br>    <span class="hljs-comment">//禁用上传</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">disabledUpload</span> = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(reason) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">loadingUpload</span> = <span class="hljs-literal">false</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$message</span>.<span class="hljs-title function_">error</span>(reason);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$message</span>.<span class="hljs-title function_">success</span>(<span class="hljs-variable language_">this</span>.$t(<span class="hljs-string">&#x27;workGuide.UploadFailed&#x27;</span>));<br>    &#125;<br>&#125;,<br><br><span class="hljs-title function_">handleRemove</span>(<span class="hljs-params">file,fileList</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">videoFileList</span> = [...fileList];<br>&#125;,<br><br></code></pre></td></tr></table></figure><h2 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h2><h3 id="x2F-upload-接口"><a href="#x2F-upload-接口" class="headerlink" title="&#x2F;upload 接口"></a>&#x2F;upload 接口</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">insertFile</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">md5,name,totalNumber,chunkSize,chunckNumber</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> sql = <span class="hljs-string">`INSERT INTO fileupload.chunck_list (file_hash,chunck_number,chunck_size,chunck_total_number,file_name) VALUES (&#x27;<span class="hljs-subst">$&#123;md5&#125;</span>&#x27;,&#x27;<span class="hljs-subst">$&#123;chunckNumber&#125;</span>&#x27;,&#x27;<span class="hljs-subst">$&#123;chunkSize&#125;</span>&#x27;,&#x27;<span class="hljs-subst">$&#123;totalNumber&#125;</span>&#x27;,&#x27;<span class="hljs-subst">$&#123;name&#125;</span>&#x27;)`</span>;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> connection.<span class="hljs-title function_">query</span>(sql);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result + <span class="hljs-string">&#x27;数据插入成功&#x27;</span>)<br>&#125;<br><br>router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/upload&quot;</span>,upload.<span class="hljs-title function_">single</span>(<span class="hljs-string">&quot;file&quot;</span>), <span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> &#123;<br>        totalNumber,  <span class="hljs-comment">// 分片总数</span><br>        chunckNumber, <span class="hljs-comment">// 分片序号</span><br>        chunkSize,    <span class="hljs-comment">// 分片大小</span><br>        md5,          <span class="hljs-comment">// 文件hash值（唯一）</span><br>        name          <span class="hljs-comment">// 文件名称</span><br>    &#125; = ctx.<span class="hljs-property">req</span>.<span class="hljs-property">body</span>;<br>    <span class="hljs-comment">//指定hash文件路径</span><br>    <span class="hljs-keyword">const</span> chunckPath = path.<span class="hljs-title function_">join</span>(uploadPath, md5,<span class="hljs-string">&#x27;/&#x27;</span>);<br>    <span class="hljs-keyword">if</span>(!fs.<span class="hljs-title function_">existsSync</span>(chunckPath))&#123;<br>        fs.<span class="hljs-title function_">mkdirSync</span>(chunckPath);<br>    &#125;<br>    <span class="hljs-comment">//移动文件到指定目录</span><br>    fs.<span class="hljs-title function_">renameSync</span>(ctx.<span class="hljs-property">req</span>.<span class="hljs-property">file</span>.<span class="hljs-property">path</span>,chunckPath + md5 + <span class="hljs-string">&#x27;-&#x27;</span> + chunckNumber);<br>    <span class="hljs-title function_">insertFile</span>(md5,name,totalNumber,chunkSize,chunckNumber)<br>    ctx.<span class="hljs-property">status</span> = <span class="hljs-number">200</span>;<br>    ctx.<span class="hljs-property">res</span>.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;Success&#x27;</span>);<br>&#125;)<br><br></code></pre></td></tr></table></figure><h3 id="x2F-merge接口"><a href="#x2F-merge接口" class="headerlink" title="&#x2F;merge接口"></a>&#x2F;merge接口</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/merge&quot;</span>, <span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> &#123;totalNumber,md5,name&#125; = ctx.<span class="hljs-property">request</span>.<span class="hljs-property">body</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//分片存储得文件夹路径</span><br>        <span class="hljs-keyword">const</span> chunckPath = path.<span class="hljs-title function_">join</span>(uploadPath, md5, <span class="hljs-string">&#x27;/&#x27;</span>);<br>        <span class="hljs-comment">//创建合并后的文件</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name+<span class="hljs-string">&#x27;我是视频地址&#x27;</span>)<br>        <span class="hljs-keyword">const</span> filePath = path.<span class="hljs-title function_">join</span>(uploadPath, name);<br>        <span class="hljs-comment">//读取对应hash文件夹下的所有分片文件名称</span><br>        <span class="hljs-keyword">const</span> chunckList = fs.<span class="hljs-title function_">existsSync</span>(chunckPath) ? fs.<span class="hljs-title function_">readdirSync</span>(chunckPath) : [];<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chunckList+<span class="hljs-string">&#x27;我是视频地址&#x27;</span>)<br>        <span class="hljs-comment">//创建储存文件</span><br>        fs.<span class="hljs-title function_">writeFileSync</span>(filePath,<span class="hljs-string">&#x27;&#x27;</span>);<br>        <span class="hljs-comment">//判断切片是否完整</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chunckList.<span class="hljs-property">length</span>,totalNumber,<span class="hljs-string">&#x27;我是总地址，和分片地址&#x27;</span>)<br>        <span class="hljs-keyword">if</span>(chunckList.<span class="hljs-property">length</span> !== totalNumber)&#123;<br>            ctx.<span class="hljs-property">status</span> = <span class="hljs-number">500</span>;<br>            ctx.<span class="hljs-property">message</span> = <span class="hljs-string">&#x27;Merge failed, missing file slices&#x27;</span>;<br>            <span class="hljs-comment">// ctx.res.end(&#x27;error&#x27;);</span><br>            process.<span class="hljs-title function_">exit</span>();<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; totalNumber; i++)&#123;<br>            <span class="hljs-keyword">const</span> chunck = fs.<span class="hljs-title function_">readFileSync</span>(chunckPath +md5+ <span class="hljs-string">&#x27;-&#x27;</span> + i);<br>            <span class="hljs-comment">//写入当前切片</span><br>            fs.<span class="hljs-title function_">appendFileSync</span>(filePath,chunck);<br>            <span class="hljs-comment">//删除已合并的切片 </span><br>            fs.<span class="hljs-title function_">unlinkSync</span>(chunckPath + md5 + <span class="hljs-string">&#x27;-&#x27;</span> + i);<br>        &#125;<br>        <span class="hljs-comment">//删除空文件夹</span><br>        fs.<span class="hljs-title function_">rmdirSync</span>(chunckPath); <br>        ctx.<span class="hljs-property">status</span> = <span class="hljs-number">200</span>;<br>        ctx.<span class="hljs-property">message</span> = <span class="hljs-string">&#x27;success&#x27;</span>;<br>    &#125;<span class="hljs-keyword">catch</span> (e) &#123;<br>        ctx.<span class="hljs-property">status</span> = <span class="hljs-number">500</span>;<br>        ctx.<span class="hljs-property">res</span>.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;合并失败&#x27;</span>);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="x2F-checkChuncks-接口"><a href="#x2F-checkChuncks-接口" class="headerlink" title="&#x2F;checkChuncks 接口"></a>&#x2F;checkChuncks 接口</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/checkChuncks&quot;</span>, <span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> &#123;md5&#125; = ctx.<span class="hljs-property">request</span>.<span class="hljs-property">body</span>;<br>        <span class="hljs-keyword">const</span> queryResult = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>            <span class="hljs-keyword">const</span> query = <span class="hljs-string">`SELECT  (SELECT count(*)  FROM chunck_list WHERE file_hash = &#x27;<span class="hljs-subst">$&#123;md5&#125;</span>&#x27;) as all_count, id as chunck_id,file_hash,chunck_number,chunck_total_number FROM chunck_list  WHERE file_hash = &#x27;<span class="hljs-subst">$&#123;md5&#125;</span>&#x27; GROUP BY id ORDER BY chunck_number`</span>;<br>            connection.<span class="hljs-title function_">query</span>(query,<span class="hljs-keyword">async</span> (error,results,fields)=&gt;&#123;<br>                <span class="hljs-keyword">if</span>(error) <span class="hljs-title function_">reject</span>(error);<br>                <span class="hljs-title function_">resolve</span>(results || []);<br>            &#125;);  <br>        &#125;)<br>        ctx.<span class="hljs-property">status</span> = <span class="hljs-number">200</span>;<br>        ctx.<span class="hljs-property">body</span> = queryResult;<br>    &#125;<span class="hljs-keyword">catch</span> (e) &#123;<br>        ctx.<span class="hljs-property">status</span> = <span class="hljs-number">500</span>;<br>        ctx.<span class="hljs-property">res</span>.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="数据库表结构"><a href="#数据库表结构" class="headerlink" title="数据库表结构"></a>数据库表结构</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">CREATE</span> <span class="hljs-variable constant_">TABLE</span> <span class="hljs-string">`chunck_list`</span> (<br>  <span class="hljs-string">`id`</span> int <span class="hljs-variable constant_">NOT</span> <span class="hljs-variable constant_">NULL</span> <span class="hljs-variable constant_">AUTO_INCREMENT</span>,<br>  <span class="hljs-string">`file_hash`</span> <span class="hljs-title function_">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-variable constant_">DEFAULT</span> <span class="hljs-variable constant_">NULL</span> <span class="hljs-variable constant_">COMMENT</span> <span class="hljs-string">&#x27;文件的唯一以hash值&#x27;</span>,<br>  <span class="hljs-string">`chunck_number`</span> int <span class="hljs-variable constant_">DEFAULT</span> <span class="hljs-variable constant_">NULL</span> <span class="hljs-variable constant_">COMMENT</span> <span class="hljs-string">&#x27;分片序号&#x27;</span>,<br>  <span class="hljs-string">`chunck_size`</span> <span class="hljs-title function_">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-variable constant_">DEFAULT</span> <span class="hljs-variable constant_">NULL</span> <span class="hljs-variable constant_">COMMENT</span> <span class="hljs-string">&#x27;分片大小&#x27;</span>,<br>  <span class="hljs-string">`file_name`</span> <span class="hljs-title function_">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-variable constant_">DEFAULT</span> <span class="hljs-variable constant_">NULL</span> <span class="hljs-variable constant_">COMMENT</span> <span class="hljs-string">&#x27;文件名称&#x27;</span>,<br>  <span class="hljs-string">`chunck_total_number`</span> <span class="hljs-title function_">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-variable constant_">DEFAULT</span> <span class="hljs-variable constant_">NULL</span> <span class="hljs-variable constant_">COMMENT</span> <span class="hljs-string">&#x27;总分片数&#x27;</span>,<br>  <span class="hljs-variable constant_">PRIMARY</span> <span class="hljs-variable constant_">KEY</span> (<span class="hljs-string">`id`</span>)<br>) <span class="hljs-variable constant_">ENGINE</span>=<span class="hljs-title class_">InnoDB</span> <span class="hljs-variable constant_">AUTO_INCREMENT</span>=<span class="hljs-number">55902</span> <span class="hljs-variable constant_">DEFAULT</span> <span class="hljs-variable constant_">CHARSET</span>=utf8mb4 <span class="hljs-variable constant_">COLLATE</span>=utf8mb4_0900_ai_ci;<br></code></pre></td></tr></table></figure><h3 id="所需依赖"><a href="#所需依赖" class="headerlink" title="所需依赖"></a>所需依赖</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&quot;dependencies&quot;</span>: &#123;<br>   <span class="hljs-string">&quot;fs-extra&quot;</span>: <span class="hljs-string">&quot;^11.2.0&quot;</span>,<br>   <span class="hljs-string">&quot;koa&quot;</span>: <span class="hljs-string">&quot;^2.14.2&quot;</span>,<br>   <span class="hljs-string">&quot;koa-body&quot;</span>: <span class="hljs-string">&quot;^6.0.1&quot;</span>,<br>   <span class="hljs-string">&quot;koa-multer&quot;</span>: <span class="hljs-string">&quot;^1.0.2&quot;</span>,<br>   <span class="hljs-string">&quot;koa-router&quot;</span>: <span class="hljs-string">&quot;^12.0.0&quot;</span>,<br>   <span class="hljs-string">&quot;koa-static&quot;</span>: <span class="hljs-string">&quot;^5.0.0&quot;</span>,<br>   <span class="hljs-string">&quot;koa2-cors&quot;</span>: <span class="hljs-string">&quot;^2.0.6&quot;</span>,<br>   <span class="hljs-string">&quot;mysql&quot;</span>: <span class="hljs-string">&quot;^2.18.1&quot;</span>,<br>   <span class="hljs-string">&quot;nodemon&quot;</span>: <span class="hljs-string">&quot;^2.0.22&quot;</span><br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分片</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>客户端存储</title>
    <link href="/2023/11/19/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8/"/>
    <url>/2023/11/19/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<p>cookie 是在客户端存储数据的一个选项。</p><h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><p>cookie最初用于在客户端存储会话信息。是一个规范，这个规范要求<strong>服务器在响应HTTP请求时，发送Set-Cookie HTTP头部包含会话信息</strong>，在之后的<strong>请求中通过HTTP头部cookie再将他们发回服务器</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">HTTP/1.1 200 OK <br>Content-<span class="hljs-built_in">type</span>: text/html <br>Set-Cookie: name=value <br>Other-header: other-header-value<br></code></pre></td></tr></table></figure><p>这个 HTTP 响应会设置一个名为”name”，值为”value”的 cookie。名和值在发送时都会经过 URL编码。浏览器会存储这些会话信息，并在之后的每个请求中都会通过 HTTP 头部 cookie 再将它们发回服务器.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">GET /index.jsl HTTP/1.1 <br>Cookie: name=value <br>Other-header: other-header-value<br></code></pre></td></tr></table></figure><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p><strong>cookie 是与特定域绑定的</strong>。设置 cookie 后，它会与请求一起发送到创建它的域。</p><p>这个限制能保证cookie 中存储的信息只对被认可的接收者开放，不被其他域访问。</p><p>因为 cookie 存储在客户端机器上，所以为保证它不会被恶意利用，浏览器会施加限制。同时，cookie也不会占用太多磁盘空间。</p><p>通常需要遵循以下大致限制，就可以在浏览器中顺畅使用cookie</p><ul><li>不超过 300 个 cookie</li><li>每个 cookie 不超过 4096 字节</li><li>每个域不超过 20 个 cookie</li><li>每个域不超过 81 920 字节</li></ul><p>每个域能设置的 cookie 总数也是受限的，但不同浏览器的限制不同。如果 cookie 总数超过了单个域的上限，浏览器就会删除之前设置的 cookie。</p><p>浏览器也会限制 cookie 的大小。大多数浏览器对 cookie 的限制是不超过 4096 字节（每个域），上下可以有一个字节的误差。</p><h2 id="cookie-的构成"><a href="#cookie-的构成" class="headerlink" title="cookie 的构成"></a>cookie 的构成</h2><p>cookie 在浏览器中是由以下参数构成的。</p><ul><li><p>名称：唯一标识cookie的名称，不区分大小写。不过最好实践中区分大小写。cookie 名必须经过 URL 编码。</p></li><li><p>值：存储在 cookie 里的字符串值。这个值必须经过 URL 编码。</p></li><li><p>域：cookie 有效的域。发送到这个域的所有请求都会包含对应的 cookie。这个值可能包含子域（如<a href="http://www.wrox.com),也可以不包含(如.wrox.com/">www.wrox.com），也可以不包含（如.wrox.com</a> 表示对 wrox.com 的所有子域都有效）。如果不明确设置，则默认为设置 cookie 的域。</p></li><li><p>路径：请求 URL 中包含这个路径才会把 cookie 发送到服务器。例如，可以指定 cookie 只能由<a href="http://www.wrox.com/books/%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%9B%A0%E6%AD%A4%E8%AE%BF%E9%97%AE">http://www.wrox.com/books/访问，因此访问</a> <a href="http://www.wrox.com/%E4%B8%8B%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%B0%B1%E4%B8%8D%E4%BC%9A%E5%8F%91%E9%80%81">http://www.wrox.com/下的页面就不会发送</a> cookie，即使请求的是同一个域。</p></li><li><p>过期时间：何时删除 cookie 的时间戳（什么时间之后就不发送到服务器）。把过期时间设置为过去的时间会立即删除 cookie。</p><blockquote><p>默认情况下，浏览器会话结束之后会删除所有cookie。如果设置了过期时间，则按过期时间为准。</p></blockquote></li><li><p>安全标志：设置之后，只在使用 SSL 安全连接的情况下才会把 cookie 发送到服务器。例如，请求 <a href="https://www.wrox.com/">https://www.wrox.com</a> 会发送 cookie，而请求 <a href="http://www.wrox.com/">http://www.wrox.com</a> 则不会。</p></li></ul><p>这些参数在 Set-Cookie 头部中使用分号加空格隔开，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">HTTP/1.1 200 OK <br>Content-<span class="hljs-built_in">type</span>: text/html <br>Set-Cookie: name=value; expires=Mon, 22-Jan-07 07:10:24 GMT; domain=.wrox.com; secure<br>Other-header: other-header-value<br></code></pre></td></tr></table></figure><p>这个头部设置一个名为”name”的 cookie，这个 cookie 在 2007 年 1 月 22 日 7:10:24 过期，对<a href="http://www.wrox.com/">www.wrox.com</a> 及其他 wrox.com 的子域（如 p2p.wrox.com）有效。因为设置了 secure 标志，这个 cookie 只能在 SSL 连接上发送。</p><blockquote><p>域、路径等标志用于告诉浏览器什么情况下应该在请求中包含 cookie。这些参数并不会随请求发送给服务器，实际发送的只有 cookie 的名&#x2F;值对。</p></blockquote><h2 id="JavaScript-中的-cookie"><a href="#JavaScript-中的-cookie" class="headerlink" title="JavaScript 中的 cookie"></a>JavaScript 中的 cookie</h2><p>因为在 JavaScript 中读写 cookie 不是很直观，所以可以通过辅助函数来简化相应的操作。与 cookie相关的基本操作有读、写和删除。这些在 CookieUtil 对象中表示如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 设置 cookie </span><br><span class="hljs-title class_">CookieUtil</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Nicholas&quot;</span>); <br><span class="hljs-title class_">CookieUtil</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;book&quot;</span>, <span class="hljs-string">&quot;Professional JavaScript&quot;</span>); <br><span class="hljs-comment">// 读取 cookie </span><br><span class="hljs-title function_">alert</span>(<span class="hljs-title class_">CookieUtil</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;name&quot;</span>)); <span class="hljs-comment">// &quot;Nicholas&quot; </span><br><span class="hljs-title function_">alert</span>(<span class="hljs-title class_">CookieUtil</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;book&quot;</span>)); <span class="hljs-comment">// &quot;Professional JavaScript&quot; </span><br><span class="hljs-comment">// 删除 cookie </span><br><span class="hljs-title class_">CookieUtil</span>.<span class="hljs-title function_">unset</span>(<span class="hljs-string">&quot;name&quot;</span>); <br><span class="hljs-title class_">CookieUtil</span>.<span class="hljs-title function_">unset</span>(<span class="hljs-string">&quot;book&quot;</span>); <br><span class="hljs-comment">// 设置有路径、域和过期时间的 cookie </span><br><span class="hljs-title class_">CookieUtil</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Nicholas&quot;</span>, <span class="hljs-string">&quot;/books/projs/&quot;</span>, <span class="hljs-string">&quot;www.wrox.com&quot;</span>, <br> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;January 1, 2010&quot;</span>)); <br><span class="hljs-comment">// 删除刚刚设置的 cookie </span><br><span class="hljs-title class_">CookieUtil</span>.<span class="hljs-title function_">unset</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;/books/projs/&quot;</span>, <span class="hljs-string">&quot;www.wrox.com&quot;</span>); <br><span class="hljs-comment">// 设置安全 cookie </span><br><span class="hljs-title class_">CookieUtil</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Nicholas&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>); <br></code></pre></td></tr></table></figure><p>这些方法通过处理解析和 cookie 字符串构建，简化了使用 cookie 存储数据的操作。</p><h2 id="子-cookie"><a href="#子-cookie" class="headerlink" title="子 cookie"></a>子 cookie</h2><p>为绕过浏览器对每个域 cookie 数的限制，有些开发者提出了子 cookie 的概念。子 cookie本质上是使用 cookie 的值在单个 cookie 中存储多个名&#x2F;值对。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">name=name1=value1&amp;name2=value2&amp;name3=value3&amp;name4=value4&amp;name5=value5<br></code></pre></td></tr></table></figure><p>解析和序列化子 cookie 的方式不一样，要取得某个子 cookie，就需要先取得 cookie，然后在解码值之前找到子 cookie。</p><p>取得子 cookie 有两个方法：get()和 getAll()。</p><ul><li>get()：取得一个子 cookie 的值。接收参数（2）：cookie 的名称和子 cookie 的名称。</li><li>getAll()：取得所有子 cookie，并以对象形式返回。对象的属性是子 cookie 的名称，值是子 cookie 的值。接收参数（1）：cookie 的名称。</li></ul><blockquote><p>get()方法也是先调用了getAll()取得所有子 cookie，返回要取得的子 cookie（如果不存在则返回 null）。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 假设 document.cookie=data=name=Nicholas&amp;book=Professional%20JavaScript</span><br><span class="hljs-comment">// 取得所有子 cookie</span><br><span class="hljs-keyword">let</span> data = <span class="hljs-title class_">SubCookieUtil</span>.<span class="hljs-title function_">getAll</span>(<span class="hljs-string">&quot;data&quot;</span>);<br><span class="hljs-title function_">alert</span>(data.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;Nicholas&quot; </span><br><span class="hljs-title function_">alert</span>(data.<span class="hljs-property">book</span>); <span class="hljs-comment">// &quot;Professional JavaScript&quot;</span><br><br><span class="hljs-comment">// 取得个别子 cookie </span><br><span class="hljs-title function_">alert</span>(<span class="hljs-title class_">SubCookieUtil</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>)); <span class="hljs-comment">// &quot;Nicholas&quot; </span><br><span class="hljs-title function_">alert</span>(<span class="hljs-title class_">SubCookieUtil</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-string">&quot;book&quot;</span>)); <span class="hljs-comment">// &quot;Professional JavaScript&quot;</span><br></code></pre></td></tr></table></figure><p>要写入子 cookie，可以使用另外两个方法：set()和 setAll()。</p><ul><li>set()：接收7个参数，cookie 的名称、子 cookie 的名称、子 cookie 的值、可选的 Date 对象用于设置 cookie 的过期时间、可选的 cookie 路径、可选的 cookie 域和可选的布尔值 secure 标志。</li><li>setAll()：接收6 个参数，cookie 的名称、包含所有子 cookie 的对象，然后是 set()方法中使用的 4 个可选参数。</li></ul><p>可以像下面这样使用这些方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 假设 document.cookie=data=name=Nicholas&amp;book=Professional%20JavaScript </span><br><span class="hljs-comment">// 设置两个子 cookie </span><br><span class="hljs-title class_">SubCookieUtil</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Nicholas&quot;</span>); <br><span class="hljs-title class_">SubCookieUtil</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-string">&quot;book&quot;</span>, <span class="hljs-string">&quot;Professional JavaScript&quot;</span>); <br><span class="hljs-comment">// 设置所有子 cookie 并传入过期时间</span><br><span class="hljs-title class_">SubCookieUtil</span>.<span class="hljs-title function_">setAll</span>(<span class="hljs-string">&quot;data&quot;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>, <span class="hljs-attr">book</span>: <span class="hljs-string">&quot;Professional JavaScript&quot;</span> &#125;, <br> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;January 1, 2010&quot;</span>)); <br></code></pre></td></tr></table></figure><p>常规 cookie 可以通过直接设置过期时间为某个过去的时间删除，但删除子 cookie 没有这么简单。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 修改&quot;name&quot;的值并修改整个 cookie 的过期时间</span><br><span class="hljs-title class_">SubCookieUtil</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Michael&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;February 1, 2010&quot;</span>));<br></code></pre></td></tr></table></figure><p>为了删除子 cookie，需要先取得所有子 cookie，把要删除的那个删掉，然后再把剩下的子 cookie 设置回去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubCookieUtil</span> &#123; <br>    <span class="hljs-comment">// 省略之前的代码</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">unset</span>(<span class="hljs-params">name, subName, path, domain, secure</span>) &#123; <br>        <span class="hljs-keyword">let</span> subcookies = <span class="hljs-title class_">SubCookieUtil</span>.<span class="hljs-title function_">getAll</span>(name); <br>        <span class="hljs-keyword">if</span> (subcookies)&#123; <br>            <span class="hljs-keyword">delete</span> subcookies[subName]; <span class="hljs-comment">// 删除</span><br>            <span class="hljs-title class_">SubCookieUtil</span>.<span class="hljs-title function_">setAll</span>(name, subcookies, <span class="hljs-literal">null</span>, path, domain, secure); <br>        &#125; <br>    &#125; <br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">unsetAll</span>(<span class="hljs-params">name, path, domain, secure</span>) &#123; <br>        <span class="hljs-title class_">SubCookieUtil</span>.<span class="hljs-title function_">setAll</span>(name, <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">0</span>), path, domain, secure); <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 只删除&quot;name&quot;子 cookie </span><br><span class="hljs-title class_">SubCookieUtil</span>.<span class="hljs-title function_">unset</span>(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-comment">// 删除整个 cookie </span><br><span class="hljs-title class_">SubCookieUtil</span>.<span class="hljs-title function_">unsetAll</span>(<span class="hljs-string">&quot;data&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="使用-cookie-的注意事项"><a href="#使用-cookie-的注意事项" class="headerlink" title="使用 cookie 的注意事项"></a>使用 cookie 的注意事项</h2><p>尽可能只通过 cookie 保存必要信息，以避免性能问题。</p><p>因为所有 cookie 都会作为请求头部由浏览器发送给服务器，所以在 cookie 中保存大量信息可能会影响特定域浏览器请求的性能。保存的 cookie 越大，请求完成的时间就越长。即使浏览器对 cookie 大小有限制，最好还是尽可能只通过 cookie 保存必要信息，以避免性能问题。</p><blockquote><p>不要在 cookie 中存储重要或敏感的信息。cookie 数据不是保存在安全的环境中，因此任何人都可能获得。</p></blockquote><p>对 cookie 的限制及其特性决定了 cookie 并不是存储大量数据的理想方式。因此，其他客户端存储技术出现了。</p><h1 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h1><p>Web Storage 的目的是解决 客户端存储不需要频繁发送回服务器的数据时使用 cookie 的问题。</p><p>Web Storage 规范最新的版本是第 2 版，这一版规范主要有两个目标：</p><ul><li>提供在 cookie 之外的存储会话数据的途径；</li><li>提供跨会话持久化存储大量数据的机制。</li></ul><p>Web Storage 的第 2 版定义了两个对象：localStorage 和 sessionStorage。<strong>localStorage 是永久存储机制，sessionStorage 是跨会话的存储机制。</strong></p><p>这两种浏览器存储 API 提供了在浏览器中不受页面刷新影响而存储数据的两种方式。</p><h2 id="Storage-类型"><a href="#Storage-类型" class="headerlink" title="Storage 类型"></a><strong>Storage</strong> 类型</h2><p>Storage 类型用于保存名&#x2F;值对数据，直至存储空间上限（由浏览器决定）。特殊的有以下方法：</p><ul><li>clear()：删除所有值；不在 Firefox 中实现。</li><li>getItem(<em>name</em>)：取得给定 <em>name</em> 的值。</li><li>key(<em>index</em>)：取得给定数值位置的名称。</li><li>removeItem(<em>name</em>)：删除给定 <em>name</em> 的名&#x2F;值对</li><li>setItem(<em>name</em>, <em>value</em>)：设置给定 <em>name</em> 的值。</li></ul><p>通过 length 属性可以确定 Storage 对象中保存了多少名&#x2F;值对。</p><blockquote><p>Storage 类型只能存储字符串。非字符串数据在存储之前会自动转换为字符串。注意，这种转换不能在获取数据时撤销。</p></blockquote><h2 id="sessionStorage-对象"><a href="#sessionStorage-对象" class="headerlink" title="sessionStorage 对象"></a><strong>sessionStorage</strong> 对象</h2><p>sessionStorage 对象只存储会话数据，这意味着数据只会存储到浏览器关闭。</p><p>存储在sessionStorage 对象中的数据只能由最初存储数据的页面使用，在多页应用程序中的用处有限。(在一个页面中使用<code>sessionStorage</code>存储的数据，不能被同一域下的其他页面所访问。每个页面都有自己独立的<code>sessionStorage</code>存储空间。)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用方法存储数据</span><br>sessionStorage.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Nicholas&quot;</span>); <br><span class="hljs-comment">// 使用属性存储数据</span><br>sessionStorage.<span class="hljs-property">book</span> = <span class="hljs-string">&quot;Professional JavaScript&quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用方法取得数据</span><br><span class="hljs-keyword">let</span> name = sessionStorage.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;name&quot;</span>); <br><span class="hljs-comment">// 使用属性取得数据</span><br><span class="hljs-keyword">let</span> book = sessionStorage.<span class="hljs-property">book</span>;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用 delete 删除值</span><br><span class="hljs-keyword">delete</span> sessionStorage.<span class="hljs-property">name</span>; <br><span class="hljs-comment">// 使用方法删除值</span><br>sessionStorage.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&quot;book&quot;</span>);<br></code></pre></td></tr></table></figure><p>sessionStorage 对象应该主要用于存储只在会话期间有效的小块数据。如果需要跨会话持久存储数据，可以使用 localStorage。</p><h2 id="localStorage-对象"><a href="#localStorage-对象" class="headerlink" title="localStorage 对象"></a><strong>localStorage</strong> 对象</h2><p>localStorage 对象，作为在客户端持久存储数据的机制。</p><p>要访问同一个 localStorage 对象，页面必须来自同一个域（子域不可以）、在相同的端口上使用相同的协议。</p><p>因 为 localStorage 是 Storage 的实例，所以可以像使用 sessionStorage 一样使用localStorage。比如下面这几个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用方法存储数据</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Nicholas&quot;</span>);<br><span class="hljs-comment">// 使用属性存储数据</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-property">book</span> = <span class="hljs-string">&quot;Professional JavaScript&quot;</span>;<br><span class="hljs-comment">// 使用方法取得数据</span><br><span class="hljs-keyword">let</span> name = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-comment">// 使用属性取得数据</span><br><span class="hljs-keyword">let</span> book = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-property">book</span>;<br></code></pre></td></tr></table></figure><p>两种存储方法的区别在于，存储在 localStorage 中的数据会保留到通过 JavaScript 删除或者用户清除浏览器缓存。localStorage 数据不受页面刷新影响，也不会因关闭窗口、标签页或重新启动浏览器而丢失。</p><h2 id="存储事件"><a href="#存储事件" class="headerlink" title="存储事件"></a>存储事件</h2><p>对于 sessionStorage 和 localStorage 上的任何更改都会触发 storage 事件，但 storage 事件不会区分这两者。</p><p>这个事件对象有如下4个属性：</p><ul><li>domain：存储变化对应的域。</li><li>key：被设置或删除的键。</li><li>newValue：键被设置的新值，若键被删除则为 null。</li><li>oldValue：键变化之前的值。</li></ul><p>可以使用如下代码监听 storage 事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;storage&quot;</span>, <br> <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Storage changed for $&#123;event.domain&#125;&#x27;</span>));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cookie</tag>
      
      <tag>storage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSON</title>
    <link href="/2023/11/16/JSON/"/>
    <url>/2023/11/16/JSON/</url>
    
    <content type="html"><![CDATA[<p>理解 JSON 最关键的一点是要把它当成一种数据格式，而不是编程语言。JSON并不属于 JavaScript，只是语法类似。</p><p>JSON 也不是只能在 JavaScript 中使用，它是一种通用数据格式。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>JSON 语法支持表示 3 种类型的值。</p><ul><li>简单值：字符串、数值、布尔值和 null 可以在 JSON 中出现，就像在 JavaScript 中一样。特殊值 undefined 不可以。</li><li>对象：第一种复杂数据类型，对象表示有序键&#x2F;值对。每个值可以是简单值，也可以是复杂类型。</li><li>数组：第二种复杂数据类型，数组表示可以通过数值索引访问的值的有序列表。数组的值可以是任意类型，包括简单值、对象，甚至其他数组。</li></ul><p>JSON 没有变量、函数或对象实例的概念。</p><h2 id="简单值"><a href="#简单值" class="headerlink" title="简单值"></a>简单值</h2><p>最简单的 JSON 可以是一个数值或字符串：5       “Hello world!” </p><p>JavaScript 字符串与 JSON 字符串的主要区别是，JSON 字符串必须使用双引号（单引号会导致语法错误）。</p><p>布尔值和 null 本身也是有效的 JSON 值。</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象使用与 JavaScript 对象字面量略为不同的方式表示。</p><p>JavaScript 中的对象字面量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> person = &#123; <br>    name: <span class="hljs-string">&quot;Nicholas&quot;</span>, <br>    age: 29 <br>&#125;;<br><span class="hljs-comment"># 两种对象表达方式效果相同</span><br><span class="hljs-built_in">let</span> object = &#123; <br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>, <br>    <span class="hljs-string">&quot;age&quot;</span> : 29 <br>&#125;;<br></code></pre></td></tr></table></figure><p>JSON 中的对象</p><p><strong>JSON 中的对象必须使用双引号把属性名包围起来。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123; <br> <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>, <br> <span class="hljs-string">&quot;age&quot;</span>: 29 <br>&#125;<br></code></pre></td></tr></table></figure><p> JavaScript 对象字面量相比，JSON 主要有三处不同：</p><p>首先，没有变量声明（JSON 中没有变量）；</p><p>其次，最后没有分号；</p><p>最后，用引号将属性名包围起来才有效；</p><p>属性的值可以是简单值或复杂数据类型值，后者可以在对象中再嵌入对象，如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123; <br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>, <br>    <span class="hljs-string">&quot;age&quot;</span>: 29, <br>    <span class="hljs-string">&quot;school&quot;</span>: &#123; <br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Merrimack College&quot;</span>, <br>        <span class="hljs-string">&quot;location&quot;</span>: <span class="hljs-string">&quot;North Andover, MA&quot;</span> <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p> JavaScript 数组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> values = [25, <span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-literal">true</span>];<br></code></pre></td></tr></table></figure><p>JSON 中可以使用类似语法表示相同的数组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[25, <span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-literal">true</span>]<br></code></pre></td></tr></table></figure><p>同样，这里没有变量，也没有分号.</p><h1 id="解析与序列化"><a href="#解析与序列化" class="headerlink" title="解析与序列化"></a>解析与序列化</h1><p>JSON 的迅速流行并不仅仅因为其语法与 JavaScript 类似，很大程度上还因为 JSON 可以直接被解析成可用的 JavaScript 对象。</p><p>与解析为 DOM 文档的 XML 相比，这个优势非常明显。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># json中获取数组中数据</span><br>books[2].title<br><span class="hljs-comment"># 遍历 DOM 结构获取数组中数据</span><br>doc.getElementsByTagName(<span class="hljs-string">&quot;book&quot;</span>)[2].getAttribute(<span class="hljs-string">&quot;title&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h2><p>JSON 对象有两个方法：**stringify()**和 **parse()**。这两个方法分别可以将JavaScript 序列化为 JSON 字符串，以及将 JSON 解析为原生 JavaScript 值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> book = &#123; <br>    title: <span class="hljs-string">&quot;Professional JavaScript&quot;</span>, <br>    authors: [ <br>    <span class="hljs-string">&quot;Nicholas C. Zakas&quot;</span>, <br>    <span class="hljs-string">&quot;Matt Frisbie&quot;</span> <br>    ], <br>    edition: 4, <br>    year: 2017 <br>&#125;; <br><span class="hljs-built_in">let</span> jsonText = JSON.stringify(book);<br></code></pre></td></tr></table></figure><p>这个例子使用 JSON.stringify()把一个 JavaScript 对象序列化为一个 JSON 字符串，保存在变量jsonText 中。</p><p>默认情况下，JSON.stringify()会输出不包含空格或缩进的 JSON 字符串，因此jsonText 的值是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;Professional JavaScript&quot;</span>,<span class="hljs-string">&quot;authors&quot;</span>:[<span class="hljs-string">&quot;Nicholas C. Zakas&quot;</span>,<span class="hljs-string">&quot;Matt Frisbie&quot;</span>], <span class="hljs-string">&quot;edition&quot;</span>:4,<span class="hljs-string">&quot;year&quot;</span>:2017&#125;<br></code></pre></td></tr></table></figure><p>在序列化 JavaScript 对象时，所有函数和原型成员都会有意地在结果中省略。此外，值为 undefined的任何属性也会被跳过。最终得到的就是所有实例属性均为有效 JSON 数据类型的表示。</p><p>JSON 字符串可以直接传给 JSON.parse()，然后得到相应的 JavaScript 值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> bookCopy = JSON.parse(jsonText);<br></code></pre></td></tr></table></figure><p>注意，book 和 bookCopy 是两个完全不同的对象，没有任何关系。但是它们拥有相同的属性和值。</p><blockquote><p>如果 JSON.parse()传入的 JSON 字符串无效，则会导致抛出错误。</p></blockquote><h2 id="序列化选项"><a href="#序列化选项" class="headerlink" title="序列化选项"></a>序列化选项</h2><p>JSON.stringify()方法除了要序列化的对象，还可以接收两个参数。</p><p>第一个参数是过滤器，可以是数组或函数；第二个参数是用于缩进结果 JSON 字符串的选项。</p><h3 id="过滤结果"><a href="#过滤结果" class="headerlink" title="过滤结果"></a>过滤结果</h3><p>第二个参数是一个数组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> book = &#123; <br>    title: <span class="hljs-string">&quot;Professional JavaScript&quot;</span>, <br>    authors: [ <br>        <span class="hljs-string">&quot;Nicholas C. Zakas&quot;</span>, <br>        <span class="hljs-string">&quot;Matt Frisbie&quot;</span> <br>    ], <br>    edition: 4, <br>    year: 2017 <br>&#125;; <br><span class="hljs-built_in">let</span> jsonText = JSON.stringify(book, [<span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;edition&quot;</span>]);<br></code></pre></td></tr></table></figure><p>结果JSON字符串只会包含title、edition属性。</p><p>{“title”:”Professional JavaScript”,”edition”:4} </p><p>第二个参数是一个函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> book = &#123; <br>    title: <span class="hljs-string">&quot;Professional JavaScript&quot;</span>, <br>    authors: [ <br>        <span class="hljs-string">&quot;Nicholas C. Zakas&quot;</span>, <br>        <span class="hljs-string">&quot;Matt Frisbie&quot;</span> <br>    ], <br>    edition: 4,<br> year: 2017 <br>&#125;;   <br> <br><span class="hljs-built_in">let</span> jsonText = JSON.stringify(book, (key, value) =&gt; &#123; <br>        switch(key) &#123; <br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;authors&quot;</span>: <br>        <span class="hljs-built_in">return</span> value.join(<span class="hljs-string">&quot;,&quot;</span>) <br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;year&quot;</span>: <br>        <span class="hljs-built_in">return</span> 5000; <br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;edition&quot;</span>: <br>        <span class="hljs-built_in">return</span> undefined; <br>        default: <br>        <span class="hljs-built_in">return</span> value; <br>    &#125; <br>&#125;);<br></code></pre></td></tr></table></figure><p>这个函数基于键进行了过滤。最终得到的 JSON 字符串是这样的：</p><p>{“title”:”Professional JavaScript”,”authors”:”Nicholas C. Zakas,Matt Frisbie”,”year”:5000} </p><h3 id="字符串缩进"><a href="#字符串缩进" class="headerlink" title="字符串缩进"></a>字符串缩进</h3><p>JSON.stringify()方法的第三个参数控制缩进和空格。在这个参数是数值时，表示每一级缩进的空格数。</p><h3 id="toJSON-方法"><a href="#toJSON-方法" class="headerlink" title="**toJSON()**方法"></a>**toJSON()**方法</h3><p>有时候，对象需要在 JSON.stringify()之上自定义 JSON 序列化。可以在要序列化的对象中添加 toJSON()方法.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> book = &#123; <br>    title: <span class="hljs-string">&quot;Professional JavaScript&quot;</span>, <br>    authors: [ <br>    <span class="hljs-string">&quot;Nicholas C. Zakas&quot;</span>, <br>    <span class="hljs-string">&quot;Matt Frisbie&quot;</span> <br> ], <br>     edition: 4, <br>     year: 2017, <br>     toJSON: <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123; <br>     <span class="hljs-built_in">return</span> this.title; <br>     &#125;<br>&#125;; <br><span class="hljs-built_in">let</span> jsonText = JSON.stringify(book);<br></code></pre></td></tr></table></figure><p>把对象传给 JSON.stringify()时会执行如下步骤。</p><p>(1) 如果可以获取实际的值，则调用 toJSON()方法获取实际的值，否则使用默认的序列化。</p><p>(2) 如果提供了第二个参数，则应用过滤。传入过滤函数的值就是第(1)步返回的值。</p><p>(3) 第(2)步返回的每个值都会相应地进行序列化。</p><p>(4) 如果提供了第三个参数，则相应地进行缩进。</p><h3 id="解析选项"><a href="#解析选项" class="headerlink" title="解析选项"></a>解析选项</h3><p>JSON.parse()方法也可以接收一个额外的参数，这个函数会针对每个键&#x2F;值对都调用一次。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> book = &#123; <br>    year: 2017, <br>    releaseDate: new Date(2017, 11, 1) <br>&#125;; <br><span class="hljs-built_in">let</span> jsonText = JSON.stringify(book);<br><span class="hljs-built_in">let</span> bookCopy = JSON.parse(jsonText, <br> (key, value) =&gt; key == <span class="hljs-string">&quot;releaseDate&quot;</span> ? new Date(value) : value); <br>alert(bookCopy.releaseDate.getFullYear());<br></code></pre></td></tr></table></figure><p>还原函数会查找”releaseDate”键，如果找到就会根据它的日期字符串创建新的 Date 对象。得到的 bookCopy.releaseDate 属性又变回了Date 对象，因此可以调用其 getFullYear()方法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JSON 是一种轻量级数据格式，这个格式使用 JavaScript 语法的一个子集表示对象、数组、字符串、数值、布尔值和 null。</p><p>虽然 XML 也能胜任同样的角色，但 JSON 更简洁，JavaScript 支持也更好。更重要的是，所有浏览器都已经原生支持全局 JSON 对象。</p>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JSON</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事件</title>
    <link href="/2023/11/15/%E4%BA%8B%E4%BB%B6/"/>
    <url>/2023/11/15/%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h1><p>事件流描述了页面接收事件的顺序。不同团队提出的事件流方案分别有：<strong>事件冒泡流</strong>、<strong>事件捕获流</strong>。</p><h2 id="事件冒泡-amp-事件捕获"><a href="#事件冒泡-amp-事件捕获" class="headerlink" title="事件冒泡&amp;事件捕获"></a>事件冒泡&amp;事件捕获</h2><p>事件冒泡被定义为从最具体的元素开始触发，然后逐步向上传播。</p><p>事件捕获是从最不具体的先收到事件，然后向下传播。</p><p>大致来看，事件冒泡和事件捕获是两种相反的事件流方案，一个由内向外冒泡，一个由外向内传播。</p><h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><p>事件流分为3个阶段：事件捕获、到达目标、事件冒泡。</p><p><strong>事件捕获</strong>最先发生，目的是提前拦截事件；然后实际的目标元素<strong>接收到事件</strong>；最后一个阶段是<strong>冒泡</strong>，最迟要在这个阶段响应事件。</p><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/markdown/image-20231115172322173.png" alt="image-20231115172322173"></p><h1 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h1><p>事件是用户或浏览器执行的某种动作。比如click、load、mouseover。为响应事件而调用的函数即<strong>事件处理程序</strong>，这种程序的名字以“on”开头，click事件的处理程序叫做<strong>onclick</strong>、load事件的处理程序叫做<strong>onload</strong>。</p><h2 id="HTML事件处理程序"><a href="#HTML事件处理程序" class="headerlink" title="HTML事件处理程序"></a>HTML事件处理程序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;button&quot;</span> value=<span class="hljs-string">&quot;Click Me&quot;</span> onclick=<span class="hljs-string">&quot;console.log(&#x27;Clicked&#x27;)&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><blockquote><p>属性的值必须是能够执行的 JavaScript 代码 </p></blockquote><p>HTML 中定义的事件处理程序可以包含精确的动作指令，也可以调用在页面其他地方定义的脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt; <br> <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">showMessage</span></span>() &#123; <br> console.log(<span class="hljs-string">&quot;Hello world!&quot;</span>); <br> &#125; <br>&lt;/script&gt; <br>&lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;button&quot;</span> value=<span class="hljs-string">&quot;Click Me&quot;</span> onclick=<span class="hljs-string">&quot;showMessage()&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>以这种方式指定的事件处理程序有一些特殊的地方。首先，会创建一个函数来封装属性的值。</p><p>这个函数有一个特殊的局部变量 event，其中保存的就是 event 对象；这个函数中this 值相当于事件的目标元素。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;button&quot;</span> value=<span class="hljs-string">&quot;Click Me&quot;</span> onclick=<span class="hljs-string">&quot;console.log(event.type)&quot;</span>&gt;    &lt;!-- 输出<span class="hljs-string">&quot;click&quot;</span> --&gt; <br><br>&lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;button&quot;</span> value=<span class="hljs-string">&quot;Click Me&quot;</span> onclick=<span class="hljs-string">&quot;console.log(this.value)&quot;</span>&gt;    &lt;!-- 输出<span class="hljs-string">&quot;Click Me&quot;</span> --&gt; <br></code></pre></td></tr></table></figure><p>HTML事件处理程序有一些问题，一个是时机问题，另一个问题是html与javascript强耦合，如果需要修改事件处理程序，则必须在两个地方，即 HTML 和 JavaScript 中，修改代码。</p><blockquote><p>这也是很多开发者不使用 HTML事件处理程序，而使用 JavaScript 指定事件处理程序的主要原因。</p></blockquote><h2 id="JavaScript指定事件处理程序"><a href="#JavaScript指定事件处理程序" class="headerlink" title="JavaScript指定事件处理程序"></a>JavaScript指定事件处理程序</h2><p>传统方式是把一个函数赋值给DOM 元素的一个事件处理程序属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 取得要操作对象的引用  </span><br></code></pre></td></tr></table></figure><p>DOM2 Events 为事件处理程序的赋值和移除定义了两个方法：**addEventListener()**和 **removeEventListener()**。这两个方法暴露在所有DOM节点上，接收3个参数：事件名、事件处理函数、布尔值，true表示在捕获阶段调用，false（默认）表示在冒泡阶段调用。</p><p>使用 DOM2方式的主要优势是可以为同一个事件添加多个事件处理程序,多个事件处理程序以添加顺序来触发.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> btn = document.getElementById(<span class="hljs-string">&quot;myBtn&quot;</span>); <br><br>btn.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, () =&gt; &#123; <br> console.log(this.id); <br>&#125;, <span class="hljs-literal">false</span>); <br><br>btn.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, () =&gt; &#123; <br> console.log(<span class="hljs-string">&quot;Hello world!&quot;</span>); <br>&#125;, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>不过，通过 addEventListener()添加的事件处理程序只能使用 removeEventListener()并传入与添加时同样的参数来移除。</p><p>这意味着使用 addEventListener()添加的匿名函数无法移除。</p><h1 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h1><p>DOM 中发生事件时，所有相关信息都会被收集并存储在一个名为 event 的对象中。这个对象包含了一些基本信息，比如导致事件的元素、发生的事件类型，以及可能与特定事件相关的任何其他数据。</p><h2 id="DOM-事件对象"><a href="#DOM-事件对象" class="headerlink" title="DOM 事件对象"></a>DOM 事件对象</h2><p>在 DOM 合规的浏览器中，event 对象是传给事件处理程序的唯一参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> btn = document.getElementById(<span class="hljs-string">&quot;myBtn&quot;</span>); <br>btn.onclick = <span class="hljs-keyword">function</span>(event) &#123; <br>console.log(event.type); // <span class="hljs-string">&quot;click&quot;</span> <br>&#125;; <br>btn.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, (event) =&gt; &#123; <br>console.log(event.type); // <span class="hljs-string">&quot;click&quot;</span> <br>&#125;, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>所有事件对象都会包含下表列出的这些公共属性和方法:</p><table><thead><tr><th>属性&#x2F;方法</th><th>类 型</th><th>读&#x2F;写</th><th>说 明</th></tr></thead><tbody><tr><td>bubbles</td><td>布尔值</td><td>只读</td><td>表示事件是否冒泡</td></tr><tr><td>cancelable</td><td>布尔值</td><td>只读</td><td>表示是否可以取消事件的默认行为</td></tr><tr><td>currentTarget</td><td>元素</td><td>只读</td><td>当前事件处理程序所在的元素</td></tr><tr><td>defaultPrevented</td><td>布尔值</td><td>只读</td><td>true 表示已经调用 preventDefault()方法（DOM3 Events 中新增）</td></tr><tr><td>detail</td><td>整数</td><td>只读</td><td>事件相关的其他信息</td></tr><tr><td>eventPhase</td><td>整数</td><td>只读</td><td>表示调用事件处理程序的阶段：1 代表捕获阶段，2 代表到达目标，3 代表冒泡阶段</td></tr><tr><td>preventDefault()</td><td>函数</td><td>只读</td><td>用于取消事件的默认行为。只有 cancelable 为 true 才可以调用这个方法</td></tr><tr><td>stopImmediatePropagation()</td><td>函数</td><td>只读</td><td>用于取消所有后续事件捕获或事件冒泡，并阻止调用任何后续事件处理程序</td></tr><tr><td>stopPropagation()</td><td>函数</td><td>只读</td><td>用于取消所有后续事件捕获或事件冒泡。只有 bubbles为 true 才可以调用这个方法</td></tr><tr><td>target</td><td>元素</td><td>只读</td><td>事件目标</td></tr><tr><td>trusted</td><td>布尔值</td><td>只读</td><td>true 表示事件是由浏览器生成的。false 表示事件是开发者通过 JavaScript 创建的</td></tr><tr><td>type</td><td>字符串</td><td>只读</td><td>被触发的事件类型</td></tr><tr><td>View</td><td>AbstractView</td><td>只读</td><td>与事件相关的抽象视图。等于事件所发生的 window 对象</td></tr></tbody></table><h1 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h1><p>Web 浏览器中可以发生很多种事件。如前所述，所发生事件的类型决定了事件对象中会保存什么信息。</p><ul><li>用户界面事件</li><li>焦点事件</li><li>鼠标事件</li><li>滚轮事件</li><li>输入事件</li><li>键盘事件</li><li>合成事件</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>事件流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨域方法</title>
    <link href="/2023/10/20/%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%B3%95/"/>
    <url>/2023/10/20/%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="跨源安全策略"><a href="#跨源安全策略" class="headerlink" title="跨源安全策略"></a>跨源安全策略</h1><p>通过 XHR 进行 Ajax 通信的一个主要限制是<strong>跨源安全策略</strong>（同源策略）。默认情况下，XHR 只能访问与发起请求的页面在同一个域内的资源。这个安全限制可以防止某些恶意行为。不过，浏览器也需要支持合法跨源访问的能力，以下将介绍几种跨域方法。</p><h1 id="跨域资源共享"><a href="#跨域资源共享" class="headerlink" title="跨域资源共享"></a>跨域资源共享</h1><p>跨源资源共享（CORS，Cross-Origin Resource Sharing）可以使浏览器与服务器实现跨源通信。</p><p>基本思路：使用自定义的HTTP头部允许服务器和浏览器相互了解，以确实请求或响应应该成功或失败。</p><p>对于简单的请求，比如 GET 或 POST 请求，没有自定义头部，而且请求体是 text&#x2F;plain 类型，这样的请求在发送时会有一个额外的头部叫 Origin。Origin 头部包含发送请求的页面的源（协议、域名和端口），以便服务器确定是否为其提供响应。</p><p>比如 <code>Origin: http://www.nczonline.net </code></p><p>如果服务器决定响应请求，那么应该发送 Access-Control-Allow-Origin 头部，包含相同的源；或者如果资源是公开的，那么就包含”*”。</p><p>比如 <code>Access-Control-Allow-Origin: http://www.nczonline.net</code></p><p>如果没有这个头部，或者有但不匹配，则服务器不会响应浏览器请求。否则，服务器就会处理这个请求。</p><p>出于安全考虑，跨域 XHR对象也施加了一些额外限制。</p><ul><li>不能使用 setRequestHeader()设置自定义头部。</li><li>不能发送和接收 cookie，无论请求还是响应都不会包含 cookie 信息。</li><li>getAllResponseHeaders()方法始终返回空字符串。</li></ul><h2 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h2><p>CORS 通过一种叫预检请求（preflighted request）的服务器验证机制，运行使用自定义头部、、除 GET 和 POST 之外的方法、以及不同请求体内容类型。</p><p>在发送设计上述某种高级选项的请求时，会先向服务器发送一个“预检”请求。 该请求使用OPTIONS方法发送并包含以下头部：</p><ul><li>Origin：与简单请求相同。</li><li>Access-Control-Request-Method：请求希望使用的方法。</li><li>Access-Control-Request-Headers：（可选）要使用的逗号分隔的自定义头部列表。</li></ul><p>下面是一个假设的 POST 请求，包含自定义的 NCZ 头部：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Origin</span>: <span class="hljs-attr">http</span>:<span class="hljs-comment">//www.nczonline.net </span><br><br><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Request</span>-<span class="hljs-title class_">Method</span>: <span class="hljs-variable constant_">POST</span> <br><br><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Request</span>-<span class="hljs-title class_">Headers</span>: <span class="hljs-variable constant_">NCZ</span> <br></code></pre></td></tr></table></figure><p>服务器会通过在响应中发送如下头部与浏览器沟通这些信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Origin</span>: <span class="hljs-attr">http</span>:<span class="hljs-comment">//www.nczonline.net  // 与简单请求相同</span><br><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Methods</span>: <span class="hljs-variable constant_">POST</span>, <span class="hljs-variable constant_">GET</span>                <span class="hljs-comment">// 允许的方法（逗号分隔的列表）。</span><br><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Headers</span>: <span class="hljs-variable constant_">NCZ</span>                      <span class="hljs-comment">// 服务器允许的头部（逗号分隔的列表）</span><br><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Max</span>-<span class="hljs-title class_">Age</span>: <span class="hljs-number">1728000</span>                        <span class="hljs-comment">// 缓存预检请求的秒数</span><br></code></pre></td></tr></table></figure><p>预检请求返回后，结果会按响应指定的时间缓存一段时间。即只有第一次发送这种类型的请求时才会多发送一次额外的 HTTP 请求。</p><h2 id="凭据请求"><a href="#凭据请求" class="headerlink" title="凭据请求"></a>凭据请求</h2><p>默认情况下，跨源请求不提供凭据（cookie、HTTP 认证和客户端 SSL 证书）。</p><p>可以通过将withCredentials 属性设置为 true 来表明请求会发送凭据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Credentials</span>: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>注意，服务器也可以在预检请求的响应中发送这个 HTTP 头部，以表明这个源允许发送凭据请求。</p><h1 id="替代性跨源技术"><a href="#替代性跨源技术" class="headerlink" title="替代性跨源技术"></a>替代性跨源技术</h1><p>CORS 出现之前，开发者需要依赖能够执行跨源请求的 DOM 特性，在不使用XHR对象的情况下发送跨域请求，实现Ajax跨域。</p><p>虽然有些麻烦，但是这些技术并没有过时，因为它们不需要修改服务器。</p><h2 id="图片探测"><a href="#图片探测" class="headerlink" title="图片探测"></a>图片探测</h2><p>图片探测的原理是，通过在网页中嵌入 <code>&lt;img&gt;</code> 标签，并设置其 <code>src</code> 属性为目标资源的URL，浏览器会尝试加载这张图片。如果目标资源存在，图片加载成功；如果目标资源不存在或者加载失败，图片加载失败。通过监测加载成功（onload）和失败（onerror）的状态，可以通过监测图片加载的结果，判断目标资源是否存在，从而获取关于目标网站的信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>(); <br>img.<span class="hljs-property">onload</span> = img.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Done!&quot;</span>); <br>&#125;; <br>img.<span class="hljs-property">src</span> = <span class="hljs-string">&quot;http://www.example.com/test?name=Nicholas&quot;</span>;<br></code></pre></td></tr></table></figure><p>这个例子创建了一个新的 Image 实例，然后为它的 onload 和 onerror 事件处理程序添加了同一个函数。这样可以确保请求完成时无论什么响应都会收到通知。设置完 src 属性之后请求就开始了，这个例子向服务器发送了一个 name 值。</p><p>图片探测频繁用于跟踪用户在页面上的点击操作或动态显示广告。</p><p>缺点：只能发送 GET 请求和无法获取服务器响应的内容。</p><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>JSONP 调用是通过动态创建<script>元素并为 src 属性指定跨域 URL 实现的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleResponse</span>(<span class="hljs-params">response</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">` </span><br><span class="hljs-string"> You&#x27;re at IP address <span class="hljs-subst">$&#123;response.ip&#125;</span>, which is in </span><br><span class="hljs-string"> <span class="hljs-subst">$&#123;response.city&#125;</span>, <span class="hljs-subst">$&#123;response.region_name&#125;</span>`</span>); <br>&#125; <br><span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;script&quot;</span>); <br><span class="hljs-comment">// callback=handleResponse 1.传递给服务器handleResponse参数，2.服务器返回的数据作为handleResponse回调的参数并调用</span><br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&quot;http://freegeoip.net/json/?callback=handleResponse&quot;</span>; <br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">insertBefore</span>(script, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">firstChild</span>);<br></code></pre></td></tr></table></figure><p>相比于图片探测，使用 JSONP 可以直接访问响应，实现浏览器与服务器的<strong>双向通信</strong>。不过 JSONP 也有一些缺点。</p><p>缺点：</p><ul><li>JSONP 是从不同的域拉取可执行代码。如果这个域并不可信，则可能在响应中加入恶意内容。</li><li>不好确定 JSONP 请求是否失败，开发者经常使用计时器来决定是否放弃等待响应。这种方式并不准确，毕竟不同用户的网络连接速度和带宽是不一样的。</li></ul><h2 id="配置代理服务器"><a href="#配置代理服务器" class="headerlink" title="配置代理服务器"></a>配置代理服务器</h2><p>是一种非常巧妙的方法，前面解决跨域的所有方法都是建立在寻找如何跨域的基础之上的，而配置代理服务器旨在“不跨域”。</p><p>方法一：优先匹配前端资源（不能配置多个代理）</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//在vue.config.js中添加，开启代理服务器，端口号为前端要转发给的服务器端口号  </span><br>devServer: &#123;<br>  <span class="hljs-attr">proxy</span>: <span class="hljs-string">&#x27;http://localhost:5000&#x27;</span><br>&#125;<br><br><br>axios.get(<span class="hljs-string">&#x27;http://localhost:8080/students&#x27;</span>).then(<br><span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;请求成功了&#x27;</span>,response.data);<br>&#125;,<br>error =&gt;&#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;请求失败了&#x27;</span>,error.message);<br>&#125;       <br>)<br><br>JS<br></code></pre></td></tr></table></figure><p>方法二：可以编写多个代理，并且严格控制请求资源走服务器还是前端</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//在vue.config.js中添加</span><br>devServer: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;                            <span class="hljs-comment">//匹配所有以/api开头的请求路径</span><br>        target: <span class="hljs-string">&#x27;http://localhost:5000&#x27;</span>,   <span class="hljs-comment">//代理目标的基础路径</span><br>        pathRewrite: &#123; <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27; &#x27;</span> &#125;,<br>        <span class="hljs-attr">ws</span>: <span class="hljs-literal">true</span>,<span class="hljs-comment">//用于支持websocket</span><br>        changeOrigin: <span class="hljs-literal">true</span><span class="hljs-comment">//用于控制请求头中的host值</span><br>      &#125;,<br>      <span class="hljs-string">&#x27;/demo&#x27;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:5001&#x27;</span>,<br>        <span class="hljs-attr">pathRewrite</span>: &#123; <span class="hljs-string">&#x27;^/demo&#x27;</span>: <span class="hljs-string">&#x27; &#x27;</span> &#125;,<br>        <span class="hljs-attr">ws</span>: <span class="hljs-literal">true</span>,<span class="hljs-comment">//用于支持websocket</span><br>        changeOrigin: <span class="hljs-literal">true</span><span class="hljs-comment">//用于控制请求头中的host值，默认为true</span><br>      &#125;,<br>    &#125;<br>     <br><br>getStudents()&#123;<br>     axios.get(<span class="hljs-string">&#x27;http://localhost:8080/api/students&#x27;</span>).then(<br>        <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span>&#123;<br>          <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;请求成功了&#x27;</span>,response.data);<br>        &#125;,<br>        error =&gt;&#123;<br>          <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;请求失败了&#x27;</span>,error.message);<br>        &#125;       <br>      )<br>    &#125;,<br>    getCars()&#123;<br>      axios.get(<span class="hljs-string">&#x27;http://localhost:8080/demo/cars&#x27;</span>).then(<br>        <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>          <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;请求成功了&#x27;</span>, response.data);<br>        &#125;,<br>        error =&gt; &#123;<br>          <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;请求失败了&#x27;</span>, error.message);<br>        &#125;<br>      )<br>    &#125;<br></code></pre></td></tr></table></figure></script></p>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>同源策略</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3</title>
    <link href="/2023/08/02/Vue3/"/>
    <url>/2023/08/02/Vue3/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue3带来了什么"><a href="#Vue3带来了什么" class="headerlink" title="Vue3带来了什么"></a>Vue3带来了什么</h1><p>github的tags地址：<a href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></p><p>1.性能的提升</p><ul><li>打包大小减少41%</li><li>初次渲染快55%,更新渲染快133%</li><li>内存减少54%</li></ul><p>2.源码的升级</p><ul><li>使用Proxy代替defineProperty实现响应式</li><li>重写虚拟DOM的实现和Tree- Shaking</li></ul><p>3.拥抱TypeScript</p><p>Vue3可以更好的支持TypeScript</p><p>4.新的特性</p><ul><li>Composition API（组合API）<ul><li>setup配置</li><li>ref与reactive</li><li>watch与watchEffect</li><li>provide与inject</li><li>……</li></ul></li><li>新的内置组件<ul><li>Fragment</li><li>Teleport</li><li>Suspense</li></ul></li><li>其他改变<ul><li>新的生命周期钩子</li><li>data 选项应始终被声明为一个函数</li><li>移除keyCode支持作为 v-on 的修饰符</li><li>……</li></ul></li></ul><h1 id="创建Vue3-0工程"><a href="#创建Vue3-0工程" class="headerlink" title="创建Vue3.0工程"></a>创建Vue3.0工程</h1><p>1.使用 vue-cli 创建</p><p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span><br>vue --version<br><span class="hljs-comment">## 如果不在4.5.0以上版本，安装或者升级你的@vue/cli</span><br>npm install -g @vue/cli<br><span class="hljs-comment">## 创建</span><br>vue create vue3_test<br><span class="hljs-comment">## 启动</span><br><span class="hljs-built_in">cd</span> vue_test<br>npm run serve<br></code></pre></td></tr></table></figure><p>2.使用 vite 创建</p><p>官方文档：<a href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p><p>vite官网：<a href="https://vitejs.cn/">https://vitejs.cn</a></p><ul><li>什么是vite？—— 新一代前端构建工具。</li><li>优势如下：<ul><li>开发环境中，无需打包操作，可快速的<strong>冷启动</strong>。</li><li>轻量快速的热重载（HMR）。</li><li>真正的按需编译，不再等待整个应用编译完成。</li></ul></li><li>传统构建 与 vite构建对比图</li></ul><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/markdown/image-20230802111152075.png" alt="image-20230802111152075" style="zoom: 67%;"><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/markdown/image-20230802111207651.png" alt="image-20230802111207651" style="zoom: 67%;"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 创建工程</span><br>npm init vite-app &lt;project-name&gt;<br><span class="hljs-comment">## 进入工程目录</span><br><span class="hljs-built_in">cd</span> &lt;project-name&gt;<br><span class="hljs-comment">## 安装依赖</span><br>npm install<br><span class="hljs-comment">## 运行 </span><br>npm run dev<br></code></pre></td></tr></table></figure><h1 id="常用Composition-API"><a href="#常用Composition-API" class="headerlink" title="常用Composition API"></a>常用Composition API</h1><h2 id="1-拉开序幕的setup"><a href="#1-拉开序幕的setup" class="headerlink" title="1.拉开序幕的setup"></a>1.拉开序幕的setup</h2><ol><li>理解：Vue3.0中一个新的配置项，值为一个函数。</li><li>setup是所有<strong>Composition API（组合API）</strong>“表演的舞台“。</li><li>组件中所用到的：数据、方法等等，均要配置在setup中。</li><li>setup函数的两种返回值：<ol><li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li><li>若返回一个渲染函数：则可以自定义渲染内容。（了解）</li></ol></li><li>注意点：<ol><li>尽量不要与Vue2.x配置混用<ul><li>Vue2.x配置（data、methos、computed…）中<strong>可以访问到</strong>setup中的属性、方法。</li><li>但在setup中<strong>不能访问到</strong>Vue2.x配置（data、methos、computed…）。</li><li>如果有重名, setup优先。</li></ul></li><li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li></ol></li></ol><h2 id="2-ref函数"><a href="#2-ref函数" class="headerlink" title="2.ref函数"></a>2.ref函数</h2><ul><li><p>作用: 定义一个响应式的数据</p></li><li><p>语法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> xxx = <span class="hljs-title function_">ref</span>(initValue)<br></code></pre></td></tr></table></figure><ul><li>创建一个包含响应式数据的<strong>引用对象（reference对象，简称ref对象）</strong>。</li><li>JS中操作数据： <code>xxx.value</code></li><li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></li></ul></li><li><p>备注：</p><ul><li>接收的数据可以是：基本类型、也可以是对象类型。</li><li><strong>基本类型的数据</strong>：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li><li><strong>对象类型的数据</strong>：内部 <em>“ 求助 ”</em> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li></ul></li></ul><h2 id="3-reactive函数"><a href="#3-reactive函数" class="headerlink" title="3.reactive函数"></a>3.reactive函数</h2><ul><li>作用: 定义一个<strong>对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li><li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong>代理对象（Proxy的实例对象，简称proxy对象）</strong></li><li>reactive定义的响应式数据是“深层次的”。</li><li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li></ul><blockquote><p>基本都用reactive，基本数据类型不要单独写，封装在对象中交给reactive。</p><p><code>let data = reactive(&#123;</code></p><p>​      person: {…},</p><p>​      student: {…}</p><p><code>&#125;)</code></p></blockquote><h2 id="4-Vue3-0中的响应式原理"><a href="#4-Vue3-0中的响应式原理" class="headerlink" title="4.Vue3.0中的响应式原理"></a>4.Vue3.0中的响应式原理</h2><h3 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h3><ul><li><p>实现原理：</p><ul><li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p></li><li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, <span class="hljs-string">&#x27;count&#x27;</span>, &#123;<br>    get () &#123;&#125;, <br>    set () &#123;&#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>存在问题：</p><ul><li>新增属性、删除属性, 界面不会更新。</li><li>直接通过下标修改数组, 界面不会自动更新。</li></ul></li></ul><h3 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h3><ul><li><p>实现原理:</p><ul><li><p>通过Proxy（代理）: 拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</p></li><li><p>通过Reflect（反射）: 对源对象的属性进行操作。</p></li><li><p>MDN文档中描述的Proxy与Reflect：</p><ul><li><p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p></li><li><p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, &#123;<br>    <span class="hljs-comment">// 拦截读取属性值</span><br>    get (target, prop) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, prop)<br>    &#125;,<br>    <span class="hljs-comment">// 拦截设置属性值或添加新属性</span><br>    set (target, prop, value) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, prop, value)<br>    &#125;,<br>    <span class="hljs-comment">// 拦截删除属性</span><br>    deleteProperty (target, prop) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target, prop)<br>    &#125;<br>&#125;)<br><br>proxy.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;tom&#x27;</span>   <br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="5-reactive对比ref"><a href="#5-reactive对比ref" class="headerlink" title="5.reactive对比ref"></a>5.reactive对比ref</h2><ul><li>从定义数据角度对比：<ul><li>ref用来定义：<strong>基本类型数据</strong>。</li><li>reactive用来定义：<strong>对象（或数组）类型数据</strong>。</li><li>备注：ref也可以用来定义<strong>对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong>代理对象</strong>。</li></ul></li><li>从原理角度对比：<ul><li>ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li><li>reactive通过使用<strong>Proxy</strong>来实现响应式（数据劫持）, 并通过<strong>Reflect</strong>操作<strong>源对象</strong>内部的数据。</li></ul></li><li>从使用角度对比：<ul><li>ref定义的数据：操作数据<strong>需要</strong><code>.value</code>，读取数据时模板中直接读取<strong>不需要</strong><code>.value</code>。</li><li>reactive定义的数据：操作数据与读取数据：<strong>均不需要</strong><code>.value</code>。</li></ul></li></ul><h2 id="6-setup的两个注意点"><a href="#6-setup的两个注意点" class="headerlink" title="6.setup的两个注意点"></a>6.setup的两个注意点</h2><ul><li>setup执行的时机<ul><li>在beforeCreate之前执行一次，this是undefined。</li></ul></li><li>setup的参数<ul><li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li><li>context：上下文对象<ul><li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li><li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li><li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li></ul></li></ul></li></ul><h2 id="7-计算属性与监视"><a href="#7-计算属性与监视" class="headerlink" title="7.计算属性与监视"></a>7.计算属性与监视</h2><h3 id="1-computed函数"><a href="#1-computed函数" class="headerlink" title="1.computed函数"></a>1.computed函数</h3><ul><li><p>与Vue2.x中computed配置功能一致</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-title function_">fullName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">person</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27;-&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">person</span>.<span class="hljs-property">lastName</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>vue3中写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;computed&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;<br>    ...<br><span class="hljs-comment">//计算属性——简写</span><br>    <span class="hljs-keyword">let</span> fullName = <span class="hljs-title function_">computed</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">return</span> person.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27;-&#x27;</span> + person.<span class="hljs-property">lastName</span><br>    &#125;)<br>    <span class="hljs-comment">//计算属性——完整</span><br>    <span class="hljs-keyword">let</span> fullName = <span class="hljs-title function_">computed</span>(&#123;<br>        <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> person.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27;-&#x27;</span> + person.<span class="hljs-property">lastName</span><br>        &#125;,<br>        <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>)&#123;<br>            <span class="hljs-keyword">const</span> nameArr = value.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;-&#x27;</span>)<br>            person.<span class="hljs-property">firstName</span> = nameArr[<span class="hljs-number">0</span>]<br>            person.<span class="hljs-property">lastName</span> = nameArr[<span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-watch函数"><a href="#2-watch函数" class="headerlink" title="2.watch函数"></a>2.watch函数</h3><ul><li><p>与Vue2.x中watch配置功能一致</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-title function_">sum</span>(<span class="hljs-params">newValue,oldValue</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;sum的值变化了&#x27;</span>,newValue,oldValue);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>两个小“坑”：</p><ul><li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li><li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//情况一：监视ref定义的响应式数据</span><br><span class="hljs-title function_">watch</span>(sum,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;sum变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>&#125;)<br><br><span class="hljs-comment">//情况二：监视多个ref定义的响应式数据</span><br><span class="hljs-title function_">watch</span>([sum,msg],<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;sum或msg变化了&#x27;</span>,newValue,oldValue)<br>&#125;) <br><br><span class="hljs-comment">/* 情况三：监视reactive定义的响应式数据</span><br><span class="hljs-comment">若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！</span><br><span class="hljs-comment">若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-title function_">watch</span>(person,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">deep</span>:<span class="hljs-literal">false</span>&#125;) <span class="hljs-comment">//此处的deep配置不再奏效</span><br><br><span class="hljs-comment">//情况四：监视reactive定义的响应式数据中的某个属性</span><br><span class="hljs-title function_">watch</span>(<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">job</span>,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>&#125;) <br><br><span class="hljs-comment">//情况五：监视reactive定义的响应式数据中的某些属性</span><br><span class="hljs-title function_">watch</span>([<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">job</span>,<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">name</span>],<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person的job或者name变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>&#125;)<br><br><span class="hljs-comment">//特殊情况</span><br><span class="hljs-title function_">watch</span>(<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">job</span>,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>&#125;) <span class="hljs-comment">//此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-watchEffect函数"><a href="#3-watchEffect函数" class="headerlink" title="3.watchEffect函数"></a>3.watchEffect函数</h3><ul><li><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p></li><li><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p></li><li><p>watchEffect有点像computed：</p><ul><li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li><li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。</span><br><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">const</span> x1 = sum.<span class="hljs-property">value</span><br>    <span class="hljs-keyword">const</span> x2 = person.<span class="hljs-property">age</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;watchEffect配置的回调执行了&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h2 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h2><p><strong>vue3.0的生命周期</strong></p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/ markdown/vue3生命周期.png" alt="vue3生命周期" style="zoom: 50%;"><ul><li>Vue3.0中可以继续用配置项方式使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul><li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li><li><code>destroyed</code>改名为 <code>unmounted</code></li></ul></li><li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul><li><code>beforeCreate</code>&#x3D;&#x3D;&gt;<code>setup()</code></li><li><code>created</code>&#x3D;&#x3D;&gt;<code>setup()</code></li><li><code>beforeMount</code> &#x3D;&#x3D;&gt;<code>onBeforeMount</code></li><li><code>mounted</code>&#x3D;&#x3D;&gt;<code>onMounted</code></li><li><code>beforeUpdate</code>&#x3D;&#x3D;&gt;<code>onBeforeUpdate</code></li><li><code>updated</code> &#x3D;&#x3D;&gt;<code>onUpdated</code></li><li><code>beforeUnmount</code> &#x3D;&#x3D;&gt;<code>onBeforeUnmount</code></li><li><code>unmounted</code> &#x3D;&#x3D;&gt;<code>onUnmounted</code></li></ul></li></ul><h2 id="9-自定义hook函数"><a href="#9-自定义hook函数" class="headerlink" title="9.自定义hook函数"></a>9.自定义hook函数</h2><ul><li>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</li><li>类似于vue2.x中的mixin。</li><li>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</li></ul><h2 id="10-toRef"><a href="#10-toRef" class="headerlink" title="10.toRef"></a>10.toRef</h2><ul><li>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</li><li>语法：<code>const name = toRef(person,&#39;name&#39;)</code></li><li>应用: 要将响应式对象中的某个属性单独提供给外部使用时。</li><li>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></li></ul><h1 id="其他Composition-API"><a href="#其他Composition-API" class="headerlink" title="其他Composition API"></a>其他Composition API</h1><h2 id="1-shallowReactive-与-shallowRef"><a href="#1-shallowReactive-与-shallowRef" class="headerlink" title="1.shallowReactive 与 shallowRef"></a>1.shallowReactive 与 shallowRef</h2><ul><li>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</li><li>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</li><li>什么时候使用?<ul><li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive。</li><li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef。</li></ul></li></ul><h2 id="2-readonly-与-shallowReadonly"><a href="#2-readonly-与-shallowReadonly" class="headerlink" title="2.readonly 与 shallowReadonly"></a>2.readonly 与 shallowReadonly</h2><ul><li>readonly: 让一个响应式数据变为只读的（深只读）。</li><li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li><li>应用场景: 不希望数据(尤其是这个数据是来自与其他组件时)被修改时。</li></ul><h2 id="3-toRaw-与-markRaw"><a href="#3-toRaw-与-markRaw" class="headerlink" title="3.toRaw 与 markRaw"></a>3.toRaw 与 markRaw</h2><ul><li>toRaw：<ul><li>作用：将一个由<code>reactive</code>生成的<strong>响应式对象</strong>转为<strong>普通对象</strong>。</li><li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li></ul></li><li>markRaw：<ul><li>作用：标记一个对象，使其永远不会再成为响应式对象。</li><li>应用场景:<ol><li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li><li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li></ol></li></ul></li></ul><h2 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4.customRef"></a>4.customRef</h2><ul><li><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p></li><li><p>实现防抖效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;keyword&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>&#123;&#123;keyword&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123;ref,customRef&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Demo&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">//自定义一个myRef</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myRef</span>(<span class="hljs-params">value,delay</span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> timer</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">//通过customRef去实现自定义</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">return</span> <span class="hljs-title function_">customRef</span>(<span class="hljs-function">(<span class="hljs-params">track,trigger</span>)=&gt;</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">return</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">track</span>() <span class="hljs-comment">//告诉Vue这个value值是需要被“追踪”的</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">return</span> value</span></span><br><span class="language-javascript"><span class="language-xml">&#125;,</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-built_in">clearTimeout</span>(timer)</span></span><br><span class="language-javascript"><span class="language-xml">timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">value = newValue</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">trigger</span>() <span class="hljs-comment">//告诉Vue去更新界面</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;,delay)</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;)</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> keyword = <span class="hljs-title function_">myRef</span>(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-number">500</span>) <span class="hljs-comment">//使用程序员自定义的ref</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">keyword</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul><h2 id="5-provide-与-inject"><a href="#5-provide-与-inject" class="headerlink" title="5.provide 与 inject"></a>5.provide 与 inject</h2><ul><li><p>作用：实现<strong>祖与后代组件间</strong>通信</p></li><li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p></li><li><p>具体写法：</p><ol><li><p>祖组件中：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lasso">setup()&#123;<br>    <span class="hljs-params">...</span><span class="hljs-params">...</span><br>    <span class="hljs-keyword">let</span> car = reactive(&#123;name:<span class="hljs-string">&#x27;奔驰&#x27;</span>,price:<span class="hljs-string">&#x27;40万&#x27;</span>&#125;)<br>    <span class="hljs-keyword">provide</span>(<span class="hljs-string">&#x27;car&#x27;</span>,car)<br>    <span class="hljs-params">...</span><span class="hljs-params">...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>后代组件中：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lasso">setup(props,context)&#123;<br>    <span class="hljs-params">...</span><span class="hljs-params">...</span><br>    const car = inject(<span class="hljs-string">&#x27;car&#x27;</span>)<br>    <span class="hljs-keyword">return</span> &#123;car&#125;<br>    <span class="hljs-params">...</span><span class="hljs-params">...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ul><blockquote><p>后代组件都可以用用inject，但是父子之间一般直接用props即可。</p></blockquote><h2 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h2><ul><li>isRef: 检查一个值是否为一个 ref 对象</li><li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li><li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li><li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li></ul><h1 id="Composition-API-的优势"><a href="#Composition-API-的优势" class="headerlink" title="Composition API 的优势"></a>Composition API 的优势</h1><h2 id="1-Options-API-存在的问题"><a href="#1-Options-API-存在的问题" class="headerlink" title="1.Options API 存在的问题"></a>1.Options API 存在的问题</h2><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p><h2 id="2-Composition-API-的优势"><a href="#2-Composition-API-的优势" class="headerlink" title="2.Composition API 的优势"></a>2.Composition API 的优势</h2><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p><h1 id="新的组件"><a href="#新的组件" class="headerlink" title="新的组件"></a>新的组件</h1><h2 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h2><ul><li>在Vue2中: 组件必须有一个根标签</li><li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li><li>好处: 减少标签层级, 减小内存占用</li></ul><h2 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h2><ul><li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong>组件html结构</strong>移动到指定位置的技术。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">teleport</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;移动位置&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mask&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dialog&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>我是一个弹窗<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;isShow = false&quot;</span>&gt;</span>关闭弹窗<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">teleport</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h2><ul><li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p></li><li><p>使用步骤：</p><ul><li><p>异步引入组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 动态引入组件</span><br><span class="hljs-keyword">import</span> &#123;defineAsyncComponent&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./components/Child.vue&#x27;</span>))<br></code></pre></td></tr></table></figure></li><li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>我是App组件<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>&gt;</span><br>                // 要显示的组件<br>                <span class="hljs-tag">&lt;<span class="hljs-name">Child</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>            // 组件还没加载出来的时候显示<br>            <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:fallback</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>加载中.....<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h2><ul><li><p>Vue 2.x 有许多全局 API 和配置。</p><ul><li><p>例如：注册全局组件、注册全局指令等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//注册全局组件</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;MyButton&#x27;</span>, &#123;<br>  <span class="hljs-attr">data</span>: <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>  &#125;),<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span><br>&#125;)<br><br><span class="hljs-comment">//注册全局指令</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;focus&#x27;</span>, &#123;<br>  <span class="hljs-attr">inserted</span>: <span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el.<span class="hljs-title function_">focus</span>()<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Vue3.0中对这些API做出了调整：</p><ul><li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p><table><thead><tr><th>2.x 全局 API（<code>Vue</code>）</th><th>3.x 实例 API (<code>app</code>)</th></tr></thead><tbody><tr><td>Vue.config.xxxx</td><td>app.config.xxxx</td></tr><tr><td>Vue.config.productionTip</td><td><strong>移除</strong></td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr></tbody></table></li></ul></li></ul><h2 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h2><ul><li><p>data选项应始终被声明为一个函数。（防止组件在被复用的时候参数数据的关联关系造成干扰）</p></li><li><p>过度类名的更改：</p><ul><li><p>Vue2.x写法</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.v-enter</span>,<br><span class="hljs-selector-class">.v-leave-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.v-leave</span>,<br><span class="hljs-selector-class">.v-enter-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Vue3.x写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.v-enter-from</span>,<br><span class="hljs-selector-class">.v-leave-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-class">.v-leave-from</span>,<br><span class="hljs-selector-class">.v-enter-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p></li><li><p><strong>移除</strong><code>v-on.native</code>修饰符</p><ul><li><p>父组件中绑定事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;my-component<br>  v-<span class="hljs-attr">on</span>:close=<span class="hljs-string">&quot;handleComponentEvent&quot;</span><br>  v-<span class="hljs-attr">on</span>:click=<span class="hljs-string">&quot;handleNativeClickEvent&quot;</span><br>/&gt;<br></code></pre></td></tr></table></figure></li><li><p>子组件中声明自定义事件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;close&#x27;</span>]</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>移除</strong>过滤器（filter）</p><blockquote><p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事件循环</title>
    <link href="/2023/07/08/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <url>/2023/07/08/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><ol><li>JS是<strong>单线程</strong>，为了防止代码阻塞，我们把代码(任务) ：同步和异步</li><li>同步代码给js引擎执行，异步代码交给宿主环境</li><li>同步代码放入执行栈中，异步代码等待时机成熟送入<strong>任务队列</strong>排队</li><li><strong>执行栈</strong>把同步代码执行完毕后，会去<strong>任务队列</strong>看是否有异步任务，有就送到<strong>执行栈</strong>执行，反复循环查看执行，这个过程是事件循环(eventloop)</li></ol><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/markdown/image-20230708134740356.png" alt="image-20230708134740356" style="zoom:80%;"><h1 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h1><p>异步任务可以分为宏任务和微任务。ES5之后，JS引入了Promise，这样不需要浏览器，JS引擎自身也能够发起异步任务了。</p><ul><li><p>宏任务是由宿主（浏览器、Node发起）</p><table><thead><tr><th>任务（代码）</th><th>宏任务</th><th>环境</th></tr></thead><tbody><tr><td>script</td><td>宏任务</td><td>浏览器</td></tr><tr><td>事件</td><td>宏任务</td><td>浏览器</td></tr><tr><td>网络请求(Ajax&#x2F;Fetch)</td><td>宏任务</td><td>浏览器</td></tr><tr><td>setTimeout()一次性定时器&#x2F;setInterval()定时器</td><td>宏任务</td><td>浏览器</td></tr></tbody></table></li><li><p>微任务是由JS引擎发起的任务</p><table><thead><tr><th>任务（代码）</th><th>微任务</th><th>环境</th></tr></thead><tbody><tr><td>Promise</td><td>微任务</td><td>JS引擎</td></tr></tbody></table><blockquote><p>注意Promise 本身是同步的，但是里面的then&#x2F;catch的回调函数是异步的</p></blockquote></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JS代码分为三种</p><ol><li><p>同步代码（js执行栈&#x2F;回调栈）</p></li><li><p>微任务的异步代码（js引擎）</p><ul><li>process.nextTick(node)</li><li>Promise.then()    catch()</li><li>Async&#x2F;Await</li><li>Object.observe</li></ul></li><li><p>宏任务的异步代码（宿主环境）</p><ul><li>script（代码块）</li><li>setTimeout&#x2F;setInterval  定时器</li><li>setImmediate 定时器</li></ul></li></ol><p>执行过程</p><ol><li><p>同步代码</p></li><li><p>微任务的异步代码（promise等）</p></li><li><p>宏任务的异步代码（settimeout、setinterval等）</p><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/markdown/image-20230708141830693.png" alt="image-20230708141830693"></p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)   <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)  <span class="hljs-comment">// 2</span><br>&#125;,<span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)  <span class="hljs-comment">// 3</span><br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1000</span>)  <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)  <span class="hljs-comment">// 4</span><br>&#125;)<br><br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)  <span class="hljs-comment">// 1000</span><br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>)   <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>打印结果</p><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/markdown/image-20230708142124437.png" alt="image-20230708142124437"></p>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>事件循环</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>防抖和节流</title>
    <link href="/2023/07/08/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
    <url>/2023/07/08/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h1><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>连续触发事件，但是在设定的一段时间内只执行最后一次。重新开始。</p><p>应用场景：</p><ul><li>搜索框搜索输入</li><li>文本编辑器实时保存</li></ul><p>未使用防抖之前</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;input&quot;</span>)<br>input.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;keyup&quot;</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(input.<span class="hljs-property">value</span> + <span class="hljs-string">&quot;取后台请求&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>这样每次输入都会发送一次请求</p><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/markdown/image-20230708155407043.png" alt="image-20230708155407043"></p><p>使用防抖之后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;input&quot;</span>)<br>input.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;keyup&quot;</span>,<span class="hljs-title function_">debounce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(input.<span class="hljs-property">value</span> + <span class="hljs-string">&quot;取后台请求&quot;</span>)<br>&#125;))<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 声明定时器</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-comment">// 为了避免每次keyup都调用，判断一下定时器是否存在，存在就清空，只需要最后一个定时器</span><br>       <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer)<br>       timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>           fn.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,<span class="hljs-variable language_">arguments</span>)<br>           timer = <span class="hljs-literal">null</span>;<br>       &#125;,<span class="hljs-number">1000</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/markdown/image-20230708220529595.png" alt="image-20230708220529595"></p><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>连续触发事件但是在设定的一段时间内<strong>只执行一次</strong>函数。不要打断我</p><p>应用场景：</p><ul><li>高频事件 例如快速点击、鼠标滑动、resize事件、scroll事件</li><li>下拉加载</li><li>视频播放记录时间等</li></ul><p>未用节流之前</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>手写防抖节流<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">draggable</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> oDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)</span><br><span class="language-javascript">    oDiv.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;drag&#x27;</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">clientX</span>)</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>拖拽的过程会很频繁的执行函数</p><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/markdown/image-20230708221530127.png" alt="image-20230708221530127"></p><p>使用防抖之后使用节流之后，函数执行次数明显减少，每100ms才会执行函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 不再是清空定时器，100ms以内都不触发，有规律的每100ms触发一次函数</span><br>        <span class="hljs-keyword">if</span> (timer) <span class="hljs-keyword">return</span>;<br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,<span class="hljs-variable language_">arguments</span>);<br>            timer = <span class="hljs-literal">null</span>;<br>        &#125;, <span class="hljs-number">100</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th></th><th>共同点</th><th>区别</th><th>应用场景</th></tr></thead><tbody><tr><td>防抖debounce</td><td>在事件频繁被触发时</td><td>只执行最后一次</td><td>input输入</td></tr><tr><td>节流throttle</td><td>减少事件执行的次数</td><td>有规律地执行</td><td>拖拽、scroll</td></tr></tbody></table><ol><li><p>防抖：单位时间内，频繁触发事件，只执行最后一次</p><p>典型场景：搜索框输入</p><p>代码思路是利用定时器，每次触发先<strong>清掉</strong>以前的定时器(从新开始)</p></li><li><p>节流：单位时间内，频繁触发事件，只执行一次</p><p>典型场景：高频事件快速点击、鼠标滑动、resize 事件、scroll 事件</p><p>代码思路也是利用定时器，等定时器<strong>执行完毕</strong>，才开启定时器(不要打断)</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>防抖和节流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SEO</title>
    <link href="/2023/07/06/SEO/"/>
    <url>/2023/07/06/SEO/</url>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>SEO(search engine optimization) 搜索引擎优化。即利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。</p><blockquote><p>搜索引擎网站的后台会有一个非常庞大的数据库，里面存储了海量的关键词，而每个关键词又对应着很多网址。这些网站都是网络爬虫去互联网上抓取的。网站内容可以被搜索引擎识别，那么搜索引擎就会提高该网站的权重，增加对该网站的友好度，使得用户在访问时，该网站时能排在前面，以达到提高排名，增加流量，改善（潜在）用户体验，促进销售的作用。</p></blockquote><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>网站结构布局优化：尽量简单、开门见山，提倡扁平化结构</p><p>网页代码优化</p><ol><li><p>突出重要内容——合理的设计title、description和keywords</p><ul><li>title 值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面 title 要有所不同；</li><li>description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；</li><li>keywords 列举出重要关键词即可</li></ul></li><li><p>语义化书写HTML代码，符合W3C标准</p><ul><li>语义化代码让搜索引擎容易理解网页</li></ul></li><li><p>重要内容 HTML 代码放在最前</p><ul><li>搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被抓取</li></ul></li><li><p>重要内容不要用 js 输出</p><ul><li>爬虫不会执行 js 获取内容</li></ul></li><li><p>少用 iframe</p><ul><li>搜索引擎不会抓取 iframe 中的内容</li></ul></li><li><p>非装饰性图片必须加 alt、表格应该使用表格标题标签</p></li><li><p>提高网站速度</p><ul><li>网站速度是搜索引擎排序的一个重要指标</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>seo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务端渲染</title>
    <link href="/2023/07/06/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR/"/>
    <url>/2023/07/06/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR/</url>
    
    <content type="html"><![CDATA[<blockquote><p>为什么会出现两种渲染方式？</p></blockquote><p>假如我们只是需要一个完全静态的页面，没有任何数据变动，比如a.html。那我们只需要把这个a.html扔到服务器上进行访问就可以了。</p><p>现实工作我们的页面要复杂的多，各种数据变动交互，不可能为每一个变动的数据都写一个视图，那么我们就只能把数据和视图分离，然后通过一种技术将数据塞进视图里面，这种技术就叫做渲染。</p><h1 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h1><p>数据由浏览器通过 ajax 请求动态取得，再通过 js 将数据填充到 dom 元素最终展示到网页中。</p><h1 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h1><p>后端先调用【数据库】，获得数据之后，将数据和页面元素进行拼装，组合成完整的 html 页面，再直接返回给浏览器。</p><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><table><thead><tr><th></th><th>客户端渲染</th><th>服务端渲染</th></tr></thead><tbody><tr><td>html的生成原理</td><td>由js生成html</td><td>由后台语言通过一些模板引擎生成</td></tr><tr><td>优点</td><td>1. 前端做视图和交互 <br>2. 后端提供接口，数据<br>3. 前后端分离<br>4. 前端做路由<br>5. 服务器计算压力变轻</td><td>1. 响应快，用户体验好<br>2. 搜索引擎友好，有seo优化<br>3. nodejs层服务器渲染，前端性能优化更顺手<br></td></tr><tr><td>缺点</td><td>用户等待时间变长，尤其是请求数多且有一定先后顺序的时候</td><td>1. 增加服务器计算压力（虽可以做渲染缓存，但是毕竟多做了计算）<br>2. 如果不是增加node中间层，前后端分工不明，不能很好的并行开发</td></tr><tr><td>耗时比较</td><td>1. 数据请求：客户端在不同网络环境进行数据请求，外网htp请求开销大，导致时间差<br>2. 步骤：客户端需要等待js代码下载，加载完成再请求数据，渲染<br>3. 渲染内容：客户端渲染，是经历一个从无到有完整的渲染步骤</td><td>1. 数据请求：服务端在内网请求，数据响应速度快<br>2. 步骤：服务端是先请求数据再渲染可视部分，即服务端不需要等待js代码下载，并会返回一个已经有内容的页面<br>3. 渲染性能：服务端性能比客户端高，速度快<br>4. 渲染内容：服务端先渲染可视部分，客户端再做二次渲染</td></tr><tr><td>适用场景</td><td>单页面应用如: React, Vue等等前端框架</td><td>用户体验比较高的比如首屏加载，重复较多的公共页面可以使用服务器渲染，减少ajax请求，挺升用户体验<br>如：PHP文件、JSP文件、Python的Flask配合Jinja引擎、 Django框架、Java配合vm模版引擎、NodeJS配合Jade。适合多页面应用。其实现在大部分网站还是这种形式。</td></tr></tbody></table><p>总结：</p><ol><li>有些网站为了让单页面应用利于<strong>seo</strong>，会让服务器和客户端同构，使用React&#x2F;Vue渲染的方案。</li><li>对于同一个组件，服务端渲染“可视”的一部分，为确保组件有完整的生命周期和事件处理，客户端需要再次渲染。</li><li>服务端渲染实际也是需要客户端再次，开小很小的二次渲染。</li></ol><blockquote><p>是否需要使用SSR，取决于首屏加载速度对应用的重要程度。</p></blockquote><h1 id="服务端渲染基本实现"><a href="#服务端渲染基本实现" class="headerlink" title="服务端渲染基本实现"></a>服务端渲染基本实现</h1><h2 id="渲染一个Vue实例"><a href="#渲染一个Vue实例" class="headerlink" title="渲染一个Vue实例"></a>渲染一个Vue实例</h2><ol><li><p>创建一个新的文件夹，<code>cd</code> 进入</p></li><li><p>执行 <code>npm init -y</code>初始化项目生成<code>pakeage.json</code>文件，将我们在项目开发中所要用到的包，以及项目的详细信息等记录在其中。</p></li><li><p>在 <code>package.json</code> 中添加 <code>&quot;type&quot;: &quot;module&quot;</code> 使 Node.js 以 <a href="https://nodejs.org/api/esm.html#modules-ecmascript-modules">ES modules mode</a> 运行，nodejs中模块化默认是使用的CommonJS规范。</p></li><li><p>执行 <code>npm install vue</code></p></li><li><p>创建一个 <code>example.js</code> 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 此文件运行在 Node.js 服务器上</span><br><span class="hljs-keyword">import</span> &#123; createSSRApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-comment">// Vue 的服务端渲染 API 位于 `vue/server-renderer` 路径下</span><br><span class="hljs-keyword">import</span> &#123; renderToString &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue/server-renderer&#x27;</span><br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createSSRApp</span>(&#123;<br>  <span class="hljs-attr">data</span>: <span class="hljs-function">() =&gt;</span> (&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">1</span> &#125;),<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;button @click=&quot;count++&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;`</span><br>&#125;)<br><br><span class="hljs-comment">// renderToString的作用是将vue实例渲染成字符串后返回</span><br><span class="hljs-title function_">renderToString</span>(app).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">html</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(html)<br>&#125;)<br></code></pre></td></tr></table></figure><p><a href="https://cn.vuejs.org/api/ssr.html#rendertostring"><code>renderToString()</code></a> 接收一个 Vue 应用实例作为参数，返回一个 Promise，当 Promise resolve 时得到应用渲染的 HTML。</p><p>接着运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">node example.js<br></code></pre></td></tr></table></figure><p>命令行中会打印出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;button&gt;<span class="hljs-number">1</span>&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>然后我们可以把 Vue SSR 的代码移动到一个服务器请求处理函数里，它将应用的 HTML 片段包装为完整的页面 HTML。</p><p>接下来的几步我们将会使用 <a href="https://expressjs.com/"><code>express</code></a>：</p></li></ol><ul><li><p>执行 <code>npm install express</code></p></li><li><p>创建下面的 <code>server.js</code> 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;express&#x27;</span><br><span class="hljs-keyword">import</span> &#123; createSSRApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; renderToString &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue/server-renderer&#x27;</span><br><br><span class="hljs-keyword">const</span> server = <span class="hljs-title function_">express</span>()<br><br>server.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createSSRApp</span>(&#123;<br>        <span class="hljs-attr">data</span>: <span class="hljs-function">() =&gt;</span> (&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">1</span> &#125;),<br>        <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;button @click=&quot;count++&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;`</span><br>    &#125;)<br><br>    <span class="hljs-title function_">renderToString</span>(app).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">html</span>) =&gt;</span> &#123;<br>        res.<span class="hljs-title function_">send</span>(<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;!DOCTYPE html&gt;</span><br><span class="hljs-string">    &lt;html&gt;</span><br><span class="hljs-string">      &lt;head&gt;</span><br><span class="hljs-string">        &lt;title&gt;Vue SSR Example&lt;/title&gt;</span><br><span class="hljs-string">      &lt;/head&gt;</span><br><span class="hljs-string">      &lt;body&gt;</span><br><span class="hljs-string">        &lt;div id=&quot;app&quot;&gt;<span class="hljs-subst">$&#123;html&#125;</span>&lt;/div&gt;</span><br><span class="hljs-string">      &lt;/body&gt;</span><br><span class="hljs-string">    &lt;/html&gt;</span><br><span class="hljs-string">    `</span>)<br>    &#125;)<br>&#125;)<br><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ready&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h2 id="客户端激活"><a href="#客户端激活" class="headerlink" title="客户端激活"></a>客户端激活</h2><p>如果点击按钮，会发现数字并没有改变。这段 HTML 在客户端是完全静态的，因为我们没有在浏览器中加载 Vue。</p><p>为了使客户端的应用可交互，Vue 需要执行一个<strong>激活</strong>步骤。在激活过程中，Vue 会创建一个与服务端完全相同的应用实例，然后将每个组件与它应该控制的 DOM 节点相匹配，并添加 DOM 事件监听器。</p><p>如何在服务器和客户端之间共享相同的应用代码呢？首先，让我们将应用的创建逻辑拆分到一个单独的文件 <code>app.js</code> 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app.js (在服务器和客户端之间共享)</span><br><span class="hljs-keyword">import</span> &#123; createSSRApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createApp</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createSSRApp</span>(&#123;<br>    <span class="hljs-attr">data</span>: <span class="hljs-function">() =&gt;</span> (&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">1</span> &#125;),<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;button @click=&quot;count++&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;`</span><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>该文件及其依赖项在服务器和客户端之间共享——我们称它们为<strong>通用代码</strong>。编写通用代码时有一些注意事项，我们将在下面讨论。</p><p>在客户端入口导入通用代码，创建应用并执行挂载：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// client.js</span><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./app.js&#x27;</span><br><br><span class="hljs-title function_">createApp</span>().<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p>服务器在请求处理函数中使用相同的应用创建逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;express&#x27;</span><br><span class="hljs-comment">// 未抽取前</span><br><span class="hljs-comment">// import &#123; createSSRApp &#125; from &#x27;vue&#x27;</span><br><span class="hljs-comment">// 抽取后</span><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./app.js&#x27;</span><br><span class="hljs-keyword">import</span> &#123; renderToString &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue/server-renderer&#x27;</span><br><br><span class="hljs-keyword">const</span> server = <span class="hljs-title function_">express</span>()<br><br>server.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 未抽取前完整写法</span><br>    <span class="hljs-comment">// const app = createSSRApp(&#123;</span><br>    <span class="hljs-comment">//     data: () =&gt; (&#123; count: 1 &#125;),</span><br>    <span class="hljs-comment">//     template: `&lt;button @click=&quot;count++&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;`</span><br>    <span class="hljs-comment">// &#125;)</span><br><br>    <span class="hljs-comment">// 抽取了共同代码到app.js以后可以这样用</span><br>    <span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>()<br><br>    <span class="hljs-title function_">renderToString</span>(app).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">html</span>) =&gt;</span> &#123;<br>        res.<span class="hljs-title function_">send</span>(<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;!DOCTYPE html&gt;</span><br><span class="hljs-string">    &lt;html&gt;</span><br><span class="hljs-string">      &lt;head&gt;</span><br><span class="hljs-string">        &lt;title&gt;Vue SSR Example&lt;/title&gt;</span><br><span class="hljs-string">      &lt;/head&gt;</span><br><span class="hljs-string">      &lt;body&gt;</span><br><span class="hljs-string">        &lt;div id=&quot;app&quot;&gt;<span class="hljs-subst">$&#123;html&#125;</span>&lt;/div&gt;</span><br><span class="hljs-string">      &lt;/body&gt;</span><br><span class="hljs-string">    &lt;/html&gt;</span><br><span class="hljs-string">    `</span>)<br>    &#125;)<br>&#125;)<br><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ready&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>此外，为了在浏览器中加载客户端文件，我们还需要：</p><ol><li>在 <code>server.js</code> 中添加 <code>server.use(express.static(&#39;.&#39;))</code> 来托管客户端文件。</li><li>将 <code>&lt;script type=&quot;module&quot; src=&quot;/client.js&quot;&gt;&lt;/script&gt;</code> 添加到 HTML 外壳以加载客户端入口文件。</li><li>通过在 HTML 外壳中添加 <a href="https://github.com/WICG/import-maps">Import Map</a> （通过导入import map（模块和对应url的映射），然后我们就可以在HTML或者CSS中接受使用url导入模块的上下文替换成<code>import:</code> URL scheme来导入模块。）以支持在浏览器中使用 <code>import * from &#39;vue&#39;</code>。</li></ol><p>完善后的<code>server.js</code>文件 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;express&#x27;</span><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./app.js&#x27;</span><br><span class="hljs-keyword">import</span> &#123; renderToString &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue/server-renderer&#x27;</span><br><br><span class="hljs-keyword">const</span> server = <span class="hljs-title function_">express</span>()<br><br>server.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>()<br><br>    <span class="hljs-title function_">renderToString</span>(app).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">html</span>) =&gt;</span> &#123;<br>        res.<span class="hljs-title function_">send</span>(<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;!DOCTYPE html&gt;</span><br><span class="hljs-string">    &lt;html&gt;</span><br><span class="hljs-string">      &lt;head&gt;</span><br><span class="hljs-string">        &lt;title&gt;Vue SSR Example&lt;/title&gt;</span><br><span class="hljs-string">         &lt;script type=&quot;importmap&quot;&gt;</span><br><span class="hljs-string">          &#123;</span><br><span class="hljs-string">            &quot;imports&quot;: &#123;</span><br><span class="hljs-string">              &quot;vue&quot;: &quot;https://unpkg.com/vue@3/dist/vue.esm-browser.js&quot;</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">          &#125;</span><br><span class="hljs-string">        &lt;/script&gt;</span><br><span class="hljs-string">        &lt;script type=&quot;module&quot; src=&quot;/client.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-string">      &lt;/head&gt;</span><br><span class="hljs-string">      &lt;body&gt;</span><br><span class="hljs-string">        &lt;div id=&quot;app&quot;&gt;<span class="hljs-subst">$&#123;html&#125;</span>&lt;/div&gt;</span><br><span class="hljs-string">      &lt;/body&gt;</span><br><span class="hljs-string">    &lt;/html&gt;</span><br><span class="hljs-string">    `</span>)<br>    &#125;)<br>&#125;)<br><br>server.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;.&#x27;</span>))<br><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ready&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="Nuxt"><a href="#Nuxt" class="headerlink" title="Nuxt"></a>Nuxt</h3><p><a href="https://nuxt.com/">Nuxt</a> 是一个构建于 Vue 生态系统之上的全栈框架，它为编写 Vue SSR 应用提供了丝滑的开发体验。更棒的是，你还可以把它当作一个静态站点生成器来用。</p><h3 id="Quasar"><a href="#Quasar" class="headerlink" title="Quasar"></a>Quasar</h3><p><a href="https://quasar.dev/">Quasar</a> 是一个基于 Vue 的完整解决方案，它可以让你用同一套代码库构建不同目标的应用，如 SPA、SSR、PWA、移动端应用、桌面端应用以及浏览器插件。除此之外，它还提供了一整套 Material Design 风格的组件库。</p><h3 id="Vite-SSR"><a href="#Vite-SSR" class="headerlink" title="Vite SSR"></a>Vite SSR</h3><p>Vite 提供了内置的 <a href="https://cn.vitejs.dev/guide/ssr.html">Vue 服务端渲染支持</a>，但它在设计上是偏底层的。如果你想要直接使用 Vite，可以看看 <a href="https://vite-plugin-ssr.com/">vite-plugin-ssr</a>，一个帮你抽象掉许多复杂细节的社区插件。</p><p>你也可以在<a href="https://github.com/vitejs/vite-plugin-vue/tree/main/playground/ssr-vue">这里</a>查看一个使用手动配置的 Vue + Vite SSR 的示例项目，以它作为基础来构建。请注意，这种方式只有在你有丰富的 SSR 和构建工具经验，并希望对应用的架构做深入的定制时才推荐使用。</p>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务端渲染</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BOM</title>
    <link href="/2023/07/03/BOM/"/>
    <url>/2023/07/03/BOM/</url>
    
    <content type="html"><![CDATA[<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><p><code>BOM</code> 是使用 <code>JavaScript</code> 开发 <code>Web</code> 应用程序的核心，提供了与网页无关的浏览器功能对象。</p><h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><p><code>window</code> 对象在浏览器中有两重身份：</p><ul><li><p><code>JavaScript</code>运行的全局对象<code>Global</code>，所有用<code>var</code>声明的全局变量和函数都可以通过<code>window.xxx</code>调用。</p></li><li><p>浏览器窗口的 <code>JavaScript</code> 接口。很多浏览器API和构造函数都是挂在window对象上面，还有一些全局方法。</p><blockquote><p>全局方法eg：setTimeout和setInterval其实都是挂在window对象上的，window.setTimeout 、window.setInterval。</p><p>浏览器接口eg：window.top、window.parent、window.self、window.screenLeft、window.innerWidth、window.scrollX、window.open</p></blockquote></li></ul><h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><p>提供了当前窗口中加载文档的信息，以及通常的导航功能。</p><p><code>location</code>对象既是 <code>window</code> 的属性，也是 <code>document</code> 的属性。也就是说，<code>window.location</code> 和 <code>document.location</code> 指向同一个对象。</p><p>假设浏览器当前加载的 URL 是 <a href="http://foouser:barpassword@www.wrox.com/WileyCDA/?q=javascript#contents%EF%BC%8Clocation">http://foouser:barpassword@www.wrox.com:80/WileyCDA/?q=javascript#contents，location</a> 对象的内容如下表所示。</p><table><thead><tr><th>属 性</th><th>值</th><th>说 明</th></tr></thead><tbody><tr><td>location.hash</td><td>“#contents”</td><td>URL 散列值（井号后跟零或多个字符），如果没有则为空字符串</td></tr><tr><td>location.host</td><td>“<a href="http://www.wrox.com/">www.wrox.com:80</a>“</td><td>服务器名及端口号</td></tr><tr><td>location.hostname</td><td>“<a href="http://www.wrox.com/">www.wrox.com</a>“</td><td>服务器名</td></tr><tr><td>location.href</td><td>“<a href="http://www.wrox.com/WileyCDA/?q=javascript#contents">http://www.wrox.com:80/WileyCDA/?q=javascript#contents</a>“</td><td>当前加载页面的完整 URL。location 的 toString()方法返回这个值</td></tr><tr><td>location.pathname</td><td>“&#x2F;WileyCDA&#x2F;“</td><td>URL 中的路径和（或）文件名</td></tr><tr><td>location.port</td><td>“80”</td><td>请求的端口。如果 URL中没有端口，则返回空字符串</td></tr><tr><td>location.protocol</td><td>“http:”</td><td>页面使用的协议。通常是”http:”或”https:”</td></tr><tr><td>location.search</td><td>“?q&#x3D;javascript”</td><td>URL 的查询字符串。这个字符串以问号开头</td></tr><tr><td>location.username</td><td>“foouser”</td><td>域名前指定的用户名</td></tr><tr><td>location.password</td><td>“barpassword”</td><td>域名前指定的密码</td></tr><tr><td>location.origin</td><td>“<a href="http://www.wrox.com/">http://www.wrox.com</a>“</td><td>URL 的源地址。只读</td></tr></tbody></table><p>location 的多数信息都可以通过上面的属性获取。之外，location还有一些方法：</p><ul><li><p>assign()  过修改 location 对象修改浏览器的地址(启动导航到新 URL ，同时在浏览器历史记录中增加一条记录)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">location.<span class="hljs-title function_">assign</span>(<span class="hljs-string">&quot;http://www.wrox.com&quot;</span>);<br><span class="hljs-comment">// 隐式调用</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span> = <span class="hljs-string">&quot;http://www.wrox.com&quot;</span>; <br>location.<span class="hljs-property">href</span> = <span class="hljs-string">&quot;http://www.wrox.com&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p>replace()  重新加载后不会增加历史记录</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">location.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;http://www.wrox.com/&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p>reload()   重新加载当前显示的页面</p></li></ul><h2 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h2><p>浏览器信息对象。</p><ul><li><p>window.navigator.uerAgent：返回浏览器的用户代理字符串</p></li><li><p>getUserMedia()：返回与可用媒体设备硬件关联的流</p></li><li><p>navigator.plugins：可以获取当前浏览器安装的所有插件还有许多，用到的时候自行查阅。</p></li></ul><h2 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h2><p>一般用来获取客户端显示器信息，比如宽高和像素高度。用的极少，属性自行查阅。</p><h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><p>历史记录对象，表示当前窗口从打开开始到调用现在的所有历史记录对象。</p><p>为了信息安全，不能查看和打印所有的历史记录url，但是可以通过history.go()在记录中自由前进和后退。</p><ul><li>history.go()  入参是一个数字，正数表示浏览记录前进几页，负数表示浏览记录返回几页</li><li>history.forward()  history.go(1)的简写</li><li>history.back()       history.go(-1)的简写</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>html</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOM</title>
    <link href="/2023/07/03/DOM/"/>
    <url>/2023/07/03/DOM/</url>
    
    <content type="html"><![CDATA[<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>文档对象模型（DOM，Document Object Model）是 HTML 和 XML 文档的编程接口。</p><blockquote><p>DOM相当于为JS提供了一个便捷操作HTML的接口</p></blockquote><h2 id="节点层级"><a href="#节点层级" class="headerlink" title="节点层级"></a>节点层级</h2><p>任何 HTML 或 XML 文档都可以用 DOM 表示为一个由节点构成的层级结构。节点的类型有很多种，不同类型有不同的特性和方法等。</p><h3 id="Node类型-x2F-节点类型"><a href="#Node类型-x2F-节点类型" class="headerlink" title="Node类型&#x2F;节点类型"></a>Node类型&#x2F;节点类型</h3><p> 在 JavaScript中，所有节点类型都继承 Node 类型，因此所有类型都共享相同的基本属性和方法。</p><ul><li>基础属性<ul><li>nodeType、nodeName、nodeValue</li></ul></li><li>节点关系属性<ul><li>childNodes、parentNode、previousSibling、nextSibling、firstChild、lastChild</li></ul></li><li>增删替查属性<ul><li>appendChild、insertBefore、replaceChild、removeChild</li></ul></li><li>其他属性（不常用）<ul><li>cloneNode、normalize</li></ul></li></ul><h3 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h3><p>虽然所有的html节点都已经能映射和取到，但由于某些类型的常用性和特殊性，所以还要再细化出Document类型。</p><ul><li><p>文档属性</p><ul><li>title、domain、referrer、url</li></ul></li><li><p>查找元素方法</p><ul><li>getElementbyId()、getElementsByTagName()、getElementsByName()</li></ul></li><li><p>特殊集合</p><ul><li>document.anchors 包含文档中所有带 name 属性的<a>元素。</a></li><li>document.forms 包含文档中所有<form>元素（与 document.getElementsByTagName (“form”)返回的结果相同）。</form></li><li>document.images 包含文档中所有<img>元素（与 document.getElementsByTagName (“img”)返回的结果相同）。</li><li>document.links 包含文档中所有带 href 属性的<a>元素。</a></li></ul><p>这些特殊集合始终存在于 HTMLDocument 对象上，而且与所有 HTMLCollection 对象一样，其内容也会实时更新以符合当前文档的内容。</p></li></ul><h3 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h3><p>Node类型和Element类型有什么关系和区别？</p><p>Element类型继承自Node类型，是Node节点的子类，表示元素类型，一般包含元素相关的一些通用属性和方法。</p><p>所有 HTML 元素上都有的标准属性：</p><ol><li>id，元素在文档中的唯一标识符；</li><li>title，包含元素的额外信息，通常以提示条形式展示；</li><li>lang，元素内容的语言代码（很少用）；</li><li>dir，语言的书写方向（”ltr”表示从左到右，”rtl”表示从右到左，同样很少用）；</li><li>className，相当于 class 属性，用于指定元素的 CSS 类（因为 class 是 ECMAScript 关键字，所以不能直接用这个名字）。</li></ol><ul><li><p>取得属性</p><p>getAttribute()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;myDiv&quot;</span>); <br><span class="hljs-title function_">alert</span>(div.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&quot;id&quot;</span>)); <span class="hljs-comment">// &quot;myDiv&quot; </span><br><span class="hljs-title function_">alert</span>(div.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&quot;class&quot;</span>)); <span class="hljs-comment">// &quot;bd&quot; </span><br><span class="hljs-title function_">alert</span>(div.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&quot;title&quot;</span>)); <span class="hljs-comment">// &quot;Body text&quot; </span><br><span class="hljs-title function_">alert</span>(div.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&quot;lang&quot;</span>)); <span class="hljs-comment">// &quot;en&quot; </span><br><span class="hljs-title function_">alert</span>(div.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&quot;dir&quot;</span>)); <span class="hljs-comment">// &quot;ltr&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>设置属性</p><p>setAttribute()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">div.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;someOtherId&quot;</span>); <br>div.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;class&quot;</span>, <span class="hljs-string">&quot;ft&quot;</span>); <br>div.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;Some other text&quot;</span>); <br>div.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;lang&quot;</span>,<span class="hljs-string">&quot;fr&quot;</span>); <br>div.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;dir&quot;</span>, <span class="hljs-string">&quot;rtl&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>根据属性取得节点</p><ul><li>getNamedItem(<em>name</em>)，返回 nodeName 属性等于 <em>name</em> 的节点；</li><li>removeNamedItem(<em>name</em>)，删除 nodeName 属性等于 <em>name</em> 的节点；</li><li>setNamedItem(<em>node</em>)，向列表中添加 <em>node</em> 节点，以其 nodeName 为索引；</li><li>item(<em>pos</em>)，返回索引位置 <em>pos</em> 处的节点。</li></ul></li><li><p>创建元素</p><ul><li>document.createElement()   在新元素上设置这些属性只会附加信息。还没有添加到文档树，所以不会影响浏览器显示。</li><li>appendChild()、insertBefore()或 replaceChild()   把元素添加到文档树</li></ul></li></ul><h2 id="DOM编程"><a href="#DOM编程" class="headerlink" title="DOM编程"></a>DOM编程</h2><h3 id="操作DOM节点"><a href="#操作DOM节点" class="headerlink" title="操作DOM节点"></a>操作DOM节点</h3><p>增：创建再增加 cloneNode、createElement 再appendChild</p><p>删：removeChild等</p><p>改：.xxx get&#x2F;setAttribute </p><p>查：getElementByXXX</p><h3 id="动态修改样式"><a href="#动态修改样式" class="headerlink" title="动态修改样式"></a>动态修改样式</h3><ol><li>直接通过x.style.属性直接操作</li><li>写多个类，用js切换元素类名</li></ol><h3 id="动态操作JS脚本"><a href="#动态操作JS脚本" class="headerlink" title="动态操作JS脚本"></a>动态操作JS脚本</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>( <span class="hljs-string">&#x27;script&#x27;</span>)<br>a.<span class="hljs-property">src</span> =<span class="hljs-string">&#x27;XXXX&#x27;</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(a)<br></code></pre></td></tr></table></figure><h2 id="DOM扩展"><a href="#DOM扩展" class="headerlink" title="DOM扩展"></a>DOM扩展</h2><h3 id="选择器API"><a href="#选择器API" class="headerlink" title="选择器API"></a>选择器API</h3><p>querySelector()、querySelectorAll()、 matches()</p><h3 id="元素遍历API"><a href="#元素遍历API" class="headerlink" title="元素遍历API"></a>元素遍历API</h3><p>IE9 之前的版本不会把元素间的空格当成空白节点，而其他浏览器则会。这样就导致了 childNodes和 firstChild 等属性上的差异。</p><p>Element Traversal API 为 DOM 元素添加了 5 个属性弥补这个差异：</p><ul><li>childElementCount，返回子元素数量（不包含文本节点和注释）；</li><li><strong>firstElementChild</strong>，指向第一个 Element 类型的子元素（Element 版 firstChild）；</li><li><strong>lastElementChild</strong>，指向最后一个 Element 类型的子元素（Element 版 lastChild）；</li><li>previousElementSibling ，指向前一个 Element 类型的同胞元素（ Element 版previousSibling）；</li><li>nextElementSibling，指向后一个 Element 类型的同胞元素（Element 版 nextSibling）。</li></ul><h3 id="HTML5新增API"><a href="#HTML5新增API" class="headerlink" title="HTML5新增API"></a>HTML5新增API</h3><ul><li><p>class类名相关操作</p><ul><li>getElementsByClassName()，classList()， className()</li></ul></li><li><p>元素焦点相关事件API：</p><ul><li>document.activeElement获得当前聚焦元素，并且文档支持tab键切换焦点也可一元素通过focus()方法设置焦点</li></ul></li><li><p>document对象强化</p><ul><li>readyState  文档加载状态</li><li>compatMode 渲染模式</li><li>head 或者<Head>标签</Head></li></ul></li><li><p>characterSet字符集</p></li><li><p>data-xxx自定义数据，元素通过dataset.xxx获取这个自定义属性</p></li><li><p>inner&#x2F;outer Html  分别表示从对象的起始位置到终止位置的全部内容，不包括html标签和包括html标签</p></li><li><p>scrollIntoView 将窗口滚动到当前元素进入视口</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>html</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue的特点</title>
    <link href="/2023/06/27/Vue%E7%9A%84%E7%89%B9%E7%82%B9/"/>
    <url>/2023/06/27/Vue%E7%9A%84%E7%89%B9%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue的特点"><a href="#Vue的特点" class="headerlink" title="Vue的特点"></a>Vue的特点</h1><ol><li><p>采用组件化模式，提高代码复用率、且让代码更好维护。</p></li><li><p>声明式编码，让编码人员无需直接操作DOM，提高开发效率。</p></li><li><p>使用虚拟DOM+优秀的Diff算法，尽量复用DOM节点。</p></li></ol><h1 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h1><p>目的：虚拟DOM设计的最初目的，就是更好的跨平台，比如Node js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟DOM，因为虚拟DOM本身是js对象。</p><p>虚拟<code>DOM</code>的作用：</p><ul><li>维护视图和状态的关系<ul><li>虚拟DOM可以记录上一次数据的变化，只更新状态变化的部分</li></ul></li><li>复杂视图情况下提升渲染性能<ul><li>比较数据变化差异，只更新差异部分的场景，使用虚拟DOM性能更优</li></ul></li><li>除了渲染成 真实DOM 以外，还可以渲染成其他平台使用的内容：<ul><li>实现SSR（服务端渲染），把虚拟DOM转换成普通的HTML字符串，常用框架：<ul><li>Nuxt.js - 基于vue的服务端渲染框架</li><li>Next.js - 基于React的服务端渲染框架</li></ul></li><li>原生应用（Weex&#x2F;React Native）</li><li>小程序（mpvue&#x2F;uni-app）</li><li>等</li></ul></li></ul><p><strong>在Vue中应用</strong>：用到了前两个作用，具体而言：</p><p>在代码渲染到页面之前，vue会把代码转换成一个虚拟DOM并缓存起来、再生成页面真实DOM，当数据发生变化时，<strong>生成的新的虚拟DOM会和旧的虚拟DOM做比较</strong>，这里用到是一个Diff算法，只重新渲染改变了的部分。这样可以减少对DOM的修改次数，提高渲染性能。</p><p>优点：通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。</p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/markdown/image-20230627100313302.png" alt="image-20230627100313302" style="zoom: 67%;"><h1 id="Vue中key的作用"><a href="#Vue中key的作用" class="headerlink" title="Vue中key的作用"></a>Vue中key的作用</h1><p><code>key</code>是虚拟<code>DOM</code>对象的标识，当状态中的数据发生变化时，<code>Vue</code>会根据[新数据]生成[新的虚拟<code>DOM</code>]，进行[新虚拟<code>DOM</code>]与[旧虚拟<code>DOM</code>]的差异比较。</p><p><code>key</code>的作用：弥补了虚拟<code>DOM</code>比较的一些漏洞，<code>key</code>作为唯一标识可以辅助虚拟<code>DOM</code>做比较，使虚拟<code>DOM</code>比较的时候更加精确筛选出相同或不同的部分。</p><h2 id="v-if中使用key"><a href="#v-if中使用key" class="headerlink" title="v-if中使用key"></a>v-if中使用key</h2><p>当没有<code>key</code>时，虚拟<code>DOM</code>比较的结果在一些情况下不符合预期。比如不同<code>input</code>的比较，由于输入框内输入的文字是真实<code>DOM</code>，不会参与虚拟<code>DOM</code>比较，虚拟<code>DOM</code>只能识别到相同的<code>input</code>元愫，会认为没有变化，之前复用之前的真实<code>DOM</code>，那么切换前后用户的输入不会被清除掉，这显然是不够智能的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span>&gt;</span>第一个输入框<span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-else</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span>&gt;</span>第二个输入框的<span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/markdown/image-20230627112510200.png" alt="image-20230627112510200"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template v-<span class="hljs-keyword">if</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;first&quot;</span>&gt;</span>第一个输入框<span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-else</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;second&quot;</span>&gt;</span>第二个输入框的<span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/markdown/image-20230627112939877.png" alt="image-20230627112939877"></p><p>当加上<code>key</code>之后将<code>show</code>的值改变输入框内此前的输入也会清空。</p><h2 id="v-for中使用key"><a href="#v-for中使用key" class="headerlink" title="v-for中使用key"></a>v-for中使用key</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;root&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(p,index) of persons&quot;</span> <span class="hljs-attr">:key</span> = <span class="hljs-string">&quot;index&quot;</span>&gt;</span><br>                &#123;&#123;p.name&#125;&#125; - &#123;&#123;p.age&#125;&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#root&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript">            <span class="hljs-attr">persons</span>:[</span><br><span class="language-javascript">                &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;001&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">18</span>&#125;,</span><br><span class="language-javascript">                &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;002&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;李四&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">19</span>&#125;,</span><br><span class="language-javascript">                &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;003&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;王五&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">20</span>&#125;,</span><br><span class="language-javascript">            ]</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">        </span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>      <br></code></pre></td></tr></table></figure><p><code>key</code>使用<code>index</code>有两个问题，使用<code>p.id</code>就不会有这两个问题。</p><ul><li>使用<code>index</code>（默认）时效率低，可复用性差</li></ul><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/markdown/image-20230627104513124.png" alt="image-20230627104513124" style="zoom:50%;"><ul><li>使用<code>p.id</code>时，可复用性高</li></ul><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/markdown/image-20230627104757548.png" alt="image-20230627104757548" style="zoom:50%;"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>虚拟<code>DOM</code>中<code>key</code>的作用:</p><p><code>key</code>是虚拟<code>DOM</code>对象的标识，当状态中的数据发生变化时，<code>Vue</code>会根据[新数据]生成[新的虚拟<code>DOM</code>]，进行[新虚拟<code>DOM</code>]与[旧虚拟<code>DOM</code>]的差异比较。</p></li><li><p>比较规则</p><ul><li>旧虚拟<code>DOM</code>中找到了与新虚拟<code>DOM</code>相同的<code>key</code><ul><li>若虚拟<code>DOM</code>中内容没变，直接使用之前的真实<code>DOM</code></li><li>若虛拟<code>DOM</code>中内容变了，则生成新的真实<code>DOM</code>，随后替换掉页面中之前的真实<code>DOM</code>。</li></ul></li><li>旧虚拟<code>DOM</code>中未找到与新虚拟<code>DOM</code>相同的key<ul><li>创建新的真实<code>DOM</code>，随后渲染到到页面。</li></ul></li></ul></li><li><p>用<code>index</code>作为<code>key</code>可能会引发的问题</p><ul><li>若对数据进行：逆序添加、逆序删除等破坏顺序操作<ul><li>会产生没有必要的真实<code>DOM</code>更新&#x3D;&#x3D;&gt;界面效果没问题，但效率低。</li></ul></li><li>如果结构中还包含输入类的<code>DOM</code><ul><li>会产生错误<code>DOM</code>更新 &#x3D;&#x3D;&gt; 界面有问题。</li></ul></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue生命周期</title>
    <link href="/2023/06/26/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2023/06/26/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h2 id="基本生命周期钩子"><a href="#基本生命周期钩子" class="headerlink" title="基本生命周期钩子"></a>基本生命周期钩子</h2><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/ markdown/生命周期.png" alt="image-生命周期" style="zoom: 80%;"><p>从开始创建、初始化数据、编译模版、挂载DOM——&gt;渲染、更新——&gt;渲染、卸载等一系列过程，整个过程就是Vue的生命周期。</p><ol><li><p><strong>beforeCreate（创建前）</strong>：初始化：生命周期函数的声明、事件规则等，但数据代理还未开始此时，数据和方法都还不能被访问到。 </p></li><li><p><strong>created（创建后）</strong>：<strong>数据监测、数据代理</strong>已经完成，可通过vm访问到data、method等。此时渲染的节点还未挂载到 DOM，不能访问到$el属性。</p><p>created——&gt;beforeMount：模板解析完成(插值语法、@click这些都开始解析了)，<strong>生成了虚拟DOM</strong>，但还没有转为真实DOM。</p></li><li><p><strong>beforeMount（挂载前）</strong>：页面呈现的还是未经Vue编译的DOM结构，此阶段对DOM的操作，最终都不起作用。</p><blockquote><p>因为虚拟DOM已经生成，下一阶段就转为真实DOM要替换掉原来的el了。</p></blockquote><p>beforeMount——&gt;mounted：将内存中的虚拟DOM转为真实DOM插入页面。将真实DOM存在vm.$el上，赋给el。</p></li><li><p><strong>mounted（挂载后）</strong>：页面呈现的就是经过Vue编译后的<strong>真实DOM</strong>。可以做一些初始化的事，比如发送ajax请求、开启定时器、发送网路请求、订阅消息、绑定自定义事件等。</p></li></ol><p>—————————————————————–到此之前都是初始化操作，后面是<strong>更新</strong>的流程</p><ol><li><p><strong>beforeUpdate（更新前）</strong>：一旦修改数据，就会调用。此时<strong>数据是修改后的的</strong>，但<strong>页面是旧的</strong>。页面和数据尚未保持同步。</p><p>beforeUpdate——&gt;updated：根据新数据，生成新的虚拟DOM，与旧的虚拟DOM进行<strong>比较</strong>，完成Model—&gt;View的更新。</p></li><li><p><strong>updated（更新后）</strong>： 此时数据是新的，页面也是新的，页面和数据保持<strong>同步</strong>。</p></li><li><p><strong>beforeDestroy（销毁前）</strong>： 实例销毁之前调用。这一步，实例仍然完全可用，this仍能获取到实例。 一般这个阶段会解绑自定义事件、取消订阅消息等。虽然自定义事件会失效，对数据的修改不也再生效，但是原生DOM事件依然有效。</p></li><li><p><strong>destroy（销毁后）</strong>：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>当前的n值是：&#123;&#123;n&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>点我<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;bye&quot;</span>&gt;</span>点我销毁vm<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 阻止vue在启动时生成生成提示</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 创建Vue实例</span></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#root&#x27;</span>, <span class="hljs-comment">// el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串</span></span><br><span class="language-javascript">        <span class="hljs-attr">data</span>: &#123;   <span class="hljs-comment">// data中用于存储数据，数据供el所指定的容器去使用</span></span><br><span class="language-javascript">            <span class="hljs-attr">n</span>: <span class="hljs-number">1</span></span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">               <span class="hljs-variable language_">this</span>.<span class="hljs-property">n</span>++</span><br><span class="language-javascript">            &#125;,</span><br><span class="language-javascript">            <span class="hljs-title function_">bye</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;bye&#x27;</span>)</span><br><span class="language-javascript">                <span class="hljs-variable language_">this</span>.$destroy()</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)  <span class="hljs-comment">// 没有_data等等，一切才刚刚开始</span></span><br><span class="language-javascript">            <span class="hljs-comment">// debugger</span></span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;created&#x27;</span>)</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)  <span class="hljs-comment">// 数据代理已经完成，有_data等</span></span><br><span class="language-javascript">            <span class="hljs-comment">// debugger</span></span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-title function_">beforeMount</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeMount&#x27;</span>)</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)  <span class="hljs-comment">// 此时已经生成了虚拟DOM，还没转为真实DOM，所以看DOM结构是还没被解析的样子</span></span><br><span class="language-javascript">            <span class="hljs-comment">// debugger</span></span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;mounted&#x27;</span>)</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>)  <span class="hljs-comment">// 此时已经转为真实DOM替换了原先的页面存在vm.$el和el上</span></span><br><span class="language-javascript">            <span class="hljs-comment">// debugger</span></span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-title function_">beforeUpdate</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">n</span>)  <span class="hljs-comment">// 修改vm上的n后打印出来是已修改的,但页面是旧的</span></span><br><span class="language-javascript">            <span class="hljs-comment">// debugger</span></span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-title function_">updated</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;updated&#x27;</span>)</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">n</span>) <span class="hljs-comment">// 修改vm上的n后打印出来是已修改的,页面也是新的</span></span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeDestroy&#x27;</span>)</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">n</span>)   <span class="hljs-comment">// 可以拿到数据也可以调用方法</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-property">n</span> = <span class="hljs-number">90</span>  <span class="hljs-comment">// ，但是所有对数据的修改不会再触发更新</span></span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-title function_">destroy</span>(<span class="hljs-params"></span>) &#123;   <span class="hljs-comment">// 几乎什么也没干</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="三个特殊钩子"><a href="#三个特殊钩子" class="headerlink" title="三个特殊钩子"></a>三个特殊钩子</h2><p>**$nextTick()**： nextTick所指定的回调，会在DOM节点更新完毕后再执行。</p><blockquote><p>并非我们修改了数据，Vue就会立刻重新解析模板，而是将函数执行完毕以后再去重新解析。</p></blockquote><p>使用场景：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">handleEdit</span>(<span class="hljs-params">todo</span>) &#123;<br>    todo.<span class="hljs-property">isEdit</span><br>    <span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">inputTitle</span>.<span class="hljs-title function_">focus</span>()<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>**activated()**：路由组件被激活时调用，能看到这个组件时</p><p>**deactivated()**：路由组件失活时调用，不看这个组件时</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 父组件中<br>&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;h2&gt;Home组件内容&lt;/h2&gt;<br>        &lt;div&gt;<br>            &lt;ul class=<span class="hljs-string">&quot;nav nav-tabs&quot;</span>&gt;<br>                &lt;li&gt;<br>                    &lt;router-link class=<span class="hljs-string">&quot;list-group-item&quot;</span> active-class=<span class="hljs-string">&quot;active&quot;</span> to=<span class="hljs-string">&quot;/home/news&quot;</span>&gt;News<br>                    &lt;/router-link&gt;<br>                &lt;/li&gt;<br>            &lt;/ul&gt;<br>            &lt;keep-alive include=<span class="hljs-string">&quot;News&quot;</span>&gt;<br>                &lt;router-view&gt;&lt;/router-view&gt;<br>            &lt;/keep-alive&gt;<br>        &lt;/div&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>// 子组件<br><span class="hljs-function"><span class="hljs-title">activated</span></span>() &#123;<br>    this.timer = setInterval(() =&gt; &#123;<br>    this.opacity -= <span class="hljs-number">0.01</span><br>    if (this.opacity &lt;= <span class="hljs-number">0</span>) this.opacity = <span class="hljs-number">1</span><br>    &#125;,<span class="hljs-number">16</span>)   <br>&#125;,<br>deactivated() &#123;<br>clearInterval(this.timer)<br>&#125;,<br><br></code></pre></td></tr></table></figure><p>用<code>keep-alive</code>包裹的路由组件在切换时不会进行立即销毁，而是缓存到内存中并执行<code>deactivated</code>钩子函数，命中缓存渲染后会执行<code>activated</code>钩子函数。</p>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VueX</title>
    <link href="/2023/06/23/VueX/"/>
    <url>/2023/06/23/VueX/</url>
    
    <content type="html"><![CDATA[<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><h2 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h2><p>Vuex是专门在Vue中实现集中式状态(数据)管理的一个Vue插件，对Vue应用中多个组件的共享状态进行集中式的管理(读&#x2F;写)也是一种组件间通信的方式，且适用于任意组件间通信。</p><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/markdown/image-20221022151715491.png" alt="image-20221022151715491"></p><ul><li>Actions(对象)：行为，当动作相关的值需要发送ajax请求才能获取的时候，才需要Actions</li><li>Mutations(对象)：修改加工</li><li>State(对象)：数据</li></ul><p>以上三个都是由<strong>store</strong>管理，相关api也是<strong>store</strong>身上的。</p><p>State里面存放数据，在Vue组件中欲修改这个数据，如果修改动作涉及到的数据还需要发送ajax请求调用dispatch()，由Action去拿到要操作的所有值，如果事先就明确值要如何修改不再牵扯到ajax请求，可以直接跳过Action，调用<strong>commit</strong>，交给<strong>Mutations做数据处理</strong>。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>多个组件依赖于同一状态</li><li>来自不同组件的行为需要变更同一状态</li></ul><p>即<strong>共享</strong></p><h2 id="基础环境搭建"><a href="#基础环境搭建" class="headerlink" title="基础环境搭建"></a>基础环境搭建</h2><ol><li><p>下载安装<code>vuex</code> :<code>npm i vuex</code></p></li><li><p>创建<code>src/store/index.js </code>该文件需要<strong>引入并使用</strong>Vuex，创建Vuex中最为核心的<code>store</code></p><blockquote><p>要求Vue.use(Vuex)要在创建store实例之前使用，所以把Vue.use(Vuex) 放在暴露store的文件里</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 引入Vue和Vuex</span><br><span class="hljs-keyword">import</span> Vue from <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> Vuex from <span class="hljs-string">&#x27;vuex&#x27;</span><br><span class="hljs-comment">// 使用Vuex</span><br>Vue.use(Vuex) <br><span class="hljs-comment">//准备actions用于响应组件中的动作</span><br><span class="hljs-type">const</span> <span class="hljs-variable">actions</span> <span class="hljs-operator">=</span> &#123;&#125;<br><span class="hljs-comment">//准备mutations用于操作数据（state）</span><br><span class="hljs-type">const</span> <span class="hljs-variable">mutations</span> <span class="hljs-operator">=</span> &#123;&#125;<br><span class="hljs-comment">//准备state用于存储数据</span><br><span class="hljs-type">const</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> &#123;&#125;<br><br><span class="hljs-comment">//创建并暴露store</span><br>export <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.Store(&#123;<br>    actions,<br>    mutations,<br>    state<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="3"><li>在<code>src/main.js</code> 中创建<code>vm</code>时传入<code>store</code>配置项</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> Vue from <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> App from <span class="hljs-string">&#x27;./App.vue&#x27;</span> <br><span class="hljs-keyword">import</span> store from <span class="hljs-string">&#x27;./store&#x27;</span> <span class="hljs-comment">//引入store</span><br>Vue.config.productionTip = <span class="hljs-literal">false</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  render: h =&gt; h(App),<br>  store<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>某组件从vuex读数据和改数据的案例</p><ol><li><p>在<strong>store.js</strong>中初始化数据<code>state</code></p></li><li><p>在组件中要处理数据的逻辑中，调用<code>dispatch</code>传递操作方法和数据，与之对应的<code>store.js</code>中的<code>actions</code>对象中定义这个函数</p></li><li><p>在<code>actions</code>中定义的函数中调用commit，与之对应的Mutations上也要有对应的函数进行处理逻辑</p><blockquote><p>组件中读取<code>vuex</code>中的数据<code>$store.state.数据</code></p><p>若组件中没有网络请求或其他业务逻辑，组件中也可越过<code>actions</code> ，即不写<code>dispatch</code> ，直接编写<code>commit</code></p></blockquote></li></ol><p><code>src/components/Count.vue</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.在组件中用$store调commit或dispatch方法，传函数名和参数</span><br>&lt;h1&gt;当前求和为：&#123;&#123;$store.state.sum &#125;&#125;&lt;/h1&gt; <br>methods:&#123;<br>    increment()&#123;<br>        <span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;JIA&#x27;</span>,<span class="hljs-built_in">this</span>.n)<br>    &#125;,<br>    decrement()&#123;<br>        <span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;JIAN&#x27;</span>,<span class="hljs-built_in">this</span>.n)<br>    &#125;,<br>    incrementOdd()&#123;<br>        <span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;jianOdd&#x27;</span>,<span class="hljs-built_in">this</span>.n)<br>    &#125;,<br>    incrementWait()&#123;<br>        <span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;jianWait&#x27;</span>, <span class="hljs-built_in">this</span>.n)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>src/store/index.js </code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//引入Vue和Vuex</span><br><span class="hljs-keyword">import</span> Vue from <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> Vuex from <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-comment">//使用Vuex插件</span><br>Vue.use(Vuex)<br>    <br><span class="hljs-comment">//准备actions用于响应组件中的动作（逻辑处理），context中有dispatch、commit、state等，是一个mini的$store</span><br><span class="hljs-type">const</span> <span class="hljs-variable">actions</span> <span class="hljs-operator">=</span> &#123;<br>    jianOdd(context, value) &#123;<br>        <span class="hljs-keyword">if</span> (context.state.sum % <span class="hljs-number">2</span>) &#123;<br>            context.commit(<span class="hljs-string">&#x27;JIA&#x27;</span>, value)<br>        &#125;<br>    &#125;,<br>    jianWait(context, value) &#123;<br>        setTimeout(() =&gt; &#123;<br>            context.commit(<span class="hljs-string">&#x27;JIA&#x27;</span>, value)<br>        &#125;, <span class="hljs-number">500</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 准备mutations用于操作数据（state）</span><br><span class="hljs-type">const</span> <span class="hljs-variable">mutations</span> <span class="hljs-operator">=</span> &#123;<br>    JIA(state, value) &#123;<br>        state.sum += value<br>    &#125;,<br>    JIAN(state, value) &#123;<br>        state.sum -= value<br>    &#125;,<br>&#125;<br><span class="hljs-comment">// 1.准备state用于存储数据</span><br><span class="hljs-type">const</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> &#123;<br>    sum: <span class="hljs-number">0</span>  <span class="hljs-comment">//当前的和</span><br>&#125; <br><br><span class="hljs-comment">// 创建并暴露store</span><br>export <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.Store(&#123;<br>    actions,<br>    mutations,<br>    state,<br>&#125;)<br></code></pre></td></tr></table></figure><p>tips：组件中读取vuex中的数据: &#x3D;&#x3D;$store.state.sum&#x3D;&#x3D;   ;   组件中修改vuex中的数据：&#x3D;&#x3D;$store.dispatch(‘action中的方法名’，数据)&#x3D;&#x3D;，若是没有网络请求或其他的业务</p><p>逻辑，组件中也可以越过actions，直接使用&#x3D;&#x3D;$store.commit(‘mutations中的方法名’，数据)&#x3D;&#x3D;</p><h2 id="getters配置项"><a href="#getters配置项" class="headerlink" title="getters配置项"></a>getters配置项</h2><ol><li><p>概念：可以使用<code>getters </code>加工state，相当于写在store.js中的一个<code>全局计算属性</code>，可以通过$store.getters.bigSum拿到</p></li><li><p>配置和使用</p><blockquote><p>理解：state&#x3D;&gt;data    getters&#x3D;&gt;computed</p></blockquote></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1.store.js中配置</span><br><span class="hljs-comment">//准备getters用于state中的数据进行加工</span><br><span class="hljs-keyword">const</span> getters = &#123;<br>    <span class="hljs-title function_">bigSum</span>(<span class="hljs-params">state</span>) &#123;<br>        <span class="hljs-comment">//要写返回值</span><br>        <span class="hljs-keyword">return</span> state.<span class="hljs-property">sum</span> * <span class="hljs-number">10</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//创建并暴露store</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>    actions,<br>    mutations,<br>    state,<br>    getters<br>&#125;)<br><br><span class="hljs-comment">//2.组件中使用</span><br>&lt;h3&gt;当前求和放大十倍：&#123;&#123; $store.<span class="hljs-property">getters</span>.<span class="hljs-property">bigSum</span>&#125;&#125;&lt;/h3&gt;<br></code></pre></td></tr></table></figure><h2 id="四个map方法的使用"><a href="#四个map方法的使用" class="headerlink" title="四个map方法的使用"></a>四个map方法的使用</h2><p>为了避免一直写$store.state.数据拿数据的优化。</p><p><code>mapState</code>与<code>mapGetters</code>优化计算属性写法:</p><ol><li><code>mapState</code>方法：映射<code>state</code>中的数据为计算属性</li><li><code>mapGetters</code>方法: 映射<code>getters</code>中的数据为计算属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;script&gt;<br><span class="hljs-keyword">import</span> &#123;mapState&#125; from <span class="hljs-string">&#x27;vuex&#x27;</span><br>export <span class="hljs-keyword">default</span> &#123;<br>    computed:&#123;<br>        <span class="hljs-comment">//借助mapState生成计算属性，从state中读取数据。 (对象写法)</span><br>        ...mapState(&#123; he:<span class="hljs-string">&#x27;sum&#x27;</span>, xuexiao:<span class="hljs-string">&#x27;school&#x27;</span>, xueke:<span class="hljs-string">&#x27;subject&#x27;</span>&#125;),<br>        <span class="hljs-comment">//借助mapState生成计算属性，从state中读取数据。( 数组写法)</span><br>        ...mapState([<span class="hljs-string">&#x27;sum&#x27;</span>, <span class="hljs-string">&#x27;school&#x27;</span>, <span class="hljs-string">&#x27;subject&#x27;</span>]),<br><br>        <span class="hljs-comment">//借助mapGetters生成计算属性，从getters中读取数据。 (对象写法)</span><br>        ...mapGetters(&#123; bigSum:<span class="hljs-string">&#x27;bigSum&#x27;</span>&#125;),<br>        <span class="hljs-comment">//借助mapGetters生成计算属性，从getters中读取数据。( 数组写法)</span><br>        ...mapGetters([<span class="hljs-string">&#x27;bigSum&#x27;</span>])<br><br>        &#125;<br><br>    等价于<br>        computed: &#123;<br>            he() &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.$store.state.sum<br>            &#125;,<br>            xuexiao() &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.$store.state.school<br>            &#125;,<br>            xueke() &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.$store.state.subject<br>            &#125;,<br>            bigSum() &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.$store.getters.bigSum<br>            &#125;    <br>        &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><code> mapMutations</code>与<code>mapActions</code>优化方法写法： </p><ol><li><p><code>mapMutations</code>方法：生成与<code>actions</code>对话的方法，即:包含<code>$store .dispatch(xxx)</code>的函数</p></li><li><p><code>mapActions</code>方法：生成与<code>mutations</code>对话的方法，即:包含<code>$store. commit(xxx)</code>的函数</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs react">&lt;button @click=&quot;increment(n)&quot;&gt;+&lt;/button&gt;<br>&lt;button @click=&quot;decrement(n)&quot;&gt;-&lt;/button&gt;<br>&lt;button @click=&quot;incrementOdd(n)&quot;&gt;当前求和为奇数再加&lt;/button&gt;<br>&lt;button @click=&quot;incrementWait(n)&quot;&gt;等一等再加&lt;/button&gt;<br><br>methods:&#123;<br>//借助mapMutations生成对应的方法，方法中会调用commit去联系mutations(对象写法)<br>. mapMutations (&#123;increment:&#x27;JIA&#x27;,decrement: &#x27;JIAN&#x27;&#125;),<br>//借助mapMutations生成对应的方法，方法中会调用commit去联系mutations (数组写法)<br>... mapMutations([&#x27;JIA&#x27;,&#x27;JIAN&#x27;]),<br>    <br>//借助mapActions生成对应的方法，方法中会调用dispatch去联系actions(对象写法)<br>...mapActions(&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;)<br>//借助mapActions生成对应的方法，方法中会调用dispatch去联系actions(数组写法)<br>...mapActions([&#x27;jiaOdd&#x27;,&#x27;jiaWait&#x27;])<br>        &#125;<br></code></pre></td></tr></table></figure><h2 id="Vuex模块化-namespace"><a href="#Vuex模块化-namespace" class="headerlink" title="Vuex模块化+namespace"></a>Vuex模块化+namespace</h2><p>目的是为了让代码更好维护</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1.在store.js中</span><br><span class="hljs-keyword">const</span> countAbout = &#123;<br>    <span class="hljs-attr">namespaced</span>:<span class="hljs-literal">true</span>,<span class="hljs-comment">//开启命名空间</span><br>    <span class="hljs-attr">state</span>:&#123;<span class="hljs-attr">x</span>:<span class="hljs-number">1</span>&#125;,<br>    <span class="hljs-attr">mutations</span>: &#123; ... &#125;,<br>    <span class="hljs-attr">actions</span>: &#123; ... &#125;,<br>    <span class="hljs-attr">getters</span>: &#123;<br>        <span class="hljs-title function_">bigSum</span>(<span class="hljs-params">state</span>)&#123;<br>            <span class="hljs-keyword">return</span> state.<span class="hljs-property">sum</span> * <span class="hljs-number">10</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> personAbout = &#123;<br>    <span class="hljs-attr">namespaced</span>:<span class="hljs-literal">true</span>,<span class="hljs-comment">//开启命名空间</span><br>    <span class="hljs-attr">state</span>:&#123; ... &#125;,<br>    <span class="hljs-attr">mutations</span>: &#123; .... &#125;,<br>    <span class="hljs-attr">actions</span>: &#123; ... &#125;,<br>    <span class="hljs-attr">getters</span>:&#123;<br>        <span class="hljs-title function_">firstPersonName</span>(<span class="hljs-params">state</span>)&#123;<br>            <span class="hljs-keyword">return</span> state.<span class="hljs-property">personList</span>[<span class="hljs-number">0</span>].<span class="hljs-property">name</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>    <span class="hljs-attr">modules</span>:&#123;<br>       countAbout,<br>       personAbout   <br>    &#125; <br>&#125;)<br><br><span class="hljs-comment">//2.组件中读取和修改数据</span><br><span class="hljs-comment">//读取state数据</span><br><span class="hljs-comment">//直接读取</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">personAbout</span>.<span class="hljs-property">list</span><br><span class="hljs-comment">//借助mapState读取</span><br>...<span class="hljs-title function_">mapState</span>(<span class="hljs-string">&#x27;countAbout&#x27;</span>,[<span class="hljs-string">&#x27;sum&#x27;</span>,<span class="hljs-string">&#x27;school&#x27;</span>,<span class="hljs-string">&#x27;subject&#x27;</span>])<br><br><span class="hljs-comment">//读取getters数据</span><br><span class="hljs-comment">//直接读取</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">getters</span>[<span class="hljs-string">&#x27;personAbout/firstPersonName&#x27;</span>]<br><span class="hljs-comment">//借助mapGetters读取</span><br>...<span class="hljs-title function_">mapState</span>(<span class="hljs-string">&#x27;countAbout&#x27;</span>,[<span class="hljs-string">&#x27;bigSum&#x27;</span>])<br><br><span class="hljs-comment">//开启命名空间后，组件中调用dispatch</span><br><span class="hljs-comment">//直接dispatch</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;personAbout/addPersonWang&#x27;</span>,person)<br><span class="hljs-comment">//借助mapActions:</span><br>...<span class="hljs-title function_">mapActions</span>(<span class="hljs-string">&#x27;countAbout&#x27;</span>,&#123;<span class="hljs-attr">incrementOdd</span>:<span class="hljs-string">&#x27;jiaOdd&#x27;</span>,<span class="hljs-attr">incrementWait</span>:<span class="hljs-string">&#x27;jiaWait&#x27;</span>&#125;)<br><br><span class="hljs-comment">//开启命名空间后，组件中调用commit</span><br><span class="hljs-comment">//直接commit</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;personAbout/ADD_PERSON&#x27;</span>,person)<br><span class="hljs-comment">//借助mapMutations:</span><br>...<span class="hljs-title function_">mapActions</span>(<span class="hljs-string">&#x27;countAbout&#x27;</span>,&#123;<span class="hljs-attr">incrementOdd</span>:<span class="hljs-string">&#x27;JIA&#x27;</span>,<span class="hljs-attr">decrement</span>:<span class="hljs-string">&#x27;JIAN&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue-Router</title>
    <link href="/2023/06/23/Vue%E8%B7%AF%E7%94%B1/"/>
    <url>/2023/06/23/Vue%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue-Router"></a>Vue-Router</h1><h2 id="1-1-相关理解"><a href="#1-1-相关理解" class="headerlink" title="1.1 相关理解"></a>1.1 相关理解</h2><h3 id="1-1-1-vue-router-的理解"><a href="#1-1-1-vue-router-的理解" class="headerlink" title="1.1.1 vue-router 的理解"></a>1.1.1 vue-router 的理解</h3><p><code>vue</code>的一个插件库，专门用来实现<code>SPA</code>（单页面跳转）应用。路由器检测到页面url变化就匹配路由，展示不同的组件。  </p><h3 id="1-1-2-路由的理解"><a href="#1-1-2-路由的理解" class="headerlink" title="1.1.2 路由的理解"></a>1.1.2 路由的理解</h3><p>1.什么是路由? </p><ul><li>一个路由就是一组映射关系（key - value）</li><li><code>key</code>为路径，<code>value</code>可能是<code>function</code>或<code>component</code></li></ul><p>2.路由分类</p><ul><li><p>后端路由 </p><ul><li>理解：<code>value</code>是<code>function</code>，于处理客户端提交的请求</li><li>工作过程：服务器接收到一个请求时，根据请求路径找到匹配的函数来处理请求，返回响应数据</li></ul></li><li><p>前端路由</p><ul><li>理解：<code>value</code>是<code>component</code>，用于展示页面内容</li><li>工作过程：当浏览器的路径改变时，对应的组件就会显示</li></ul></li></ul><h3 id="x3D-x3D-1-1-3-路由器的两种工作模式-x3D-x3D"><a href="#x3D-x3D-1-1-3-路由器的两种工作模式-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;1.1.3 路由器的两种工作模式&#x3D;&#x3D;"></a>&#x3D;&#x3D;1.1.3 路由器的两种工作模式&#x3D;&#x3D;</h3><p>一个url带#就是hash模式，不带#号就是history模式。</p><blockquote><p>从#开始一直到结束的值都是hash值，不会随着http请求发送给服务器，只是前端路由处理。</p></blockquote><ul><li><code>hash</code>值不会包含在<code>http</code>请求中，即刷新不会被当成请求发给服务器。兼容性较好。</li><li><code>history</code>模式地址干净美观，但兼容性较差，需要后端处理识别url是前端路由跳转还是请求后端资源。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>    <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;hash&#x27;</span>,<br>    <span class="hljs-attr">routes</span>:[...]<br>&#125;)<br></code></pre></td></tr></table></figure><p>Express服务器如何解决history带来的问题：使用connect-history-api-fallback中间件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">// 1. npm i connect-history-api-fallback</span><br><span class="hljs-keyword">const</span> history = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;connect-history-api-fallback&#x27;</span>)<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br><span class="hljs-comment">// 2. 使用connect-history-api-fallback中间件</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">history</span>())<br><span class="hljs-comment">// 3. static下是前端打包后的dist文件，此时打开该服务器才可以访问前端资源</span><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(_dirname+<span class="hljs-string">&#x27;/static&#x27;</span>))<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;express server running at http://127.0.0.1&#x27;</span>)&#125;)<br></code></pre></td></tr></table></figure><h2 id="1-2-基本路由"><a href="#1-2-基本路由" class="headerlink" title="1.2 基本路由"></a>1.2 基本路由</h2><ol><li><p>安装<code>vue-router</code>：<code>npm  i  vue-router</code></p></li><li><p>在main.js中引入VueRouter并应用插件，编写<code>router</code>配置项</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 引入VueRouter路由器</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueRouter</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-comment">// 引入组件</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">About</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../pages/About&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../pages/Home&#x27;</span><br><br><span class="hljs-comment">// 应用插件</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">VueRouter</span>)<br><br><span class="hljs-comment">// 创建router路由器实例对象，去管理一组一组的路由规则</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span> (&#123;<br>     <span class="hljs-attr">routes</span>: [<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>,<br>            <span class="hljs-attr">component</span>: <span class="hljs-title class_">About</span>,<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>            <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span><br>        &#125;, <br>&#125;)<br> <br><br><span class="hljs-comment">// 可以识别路由,即根据url变化</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br>  <span class="hljs-attr">router</span>: router  <span class="hljs-comment">// 引入并应用了VueRouter插件以后就可以写这个配置项</span><br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p><code>router</code>配置项可以单独建一个router的文件夹在index.js里面写，然后再在main.js中导入即可</p></blockquote><ol start="3"><li>在template中配置url如何改变，以及变化的组件在哪显示</li></ol><ul><li>在template中使用<router-link>改变url  相当于<a>标签</a></router-link></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//active-class= &quot;active&quot;，该元素被点击时实现active类的样式</span><br>&lt;router-link <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;list-group-item &quot;</span> active-<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;active&quot;</span> to=<span class="hljs-string">&quot;/about&quot;</span>&gt;<span class="hljs-title class_">About</span>&lt;/router-link&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-group-item&quot;</span> <span class="hljs-attr">active-class</span>=<span class="hljs-string">&quot;active&quot;</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>指定展示位 <router-view></router-view></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;router-view&gt;&lt;/router-view&gt;<br><br><span class="hljs-comment">// 如果需要缓存路由组件，使不看这个组件时该组件不被销毁，可以用keep-alive</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">include</span>=<span class="hljs-string">&quot;News&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">&quot;[&#x27;News&#x27;,&#x27;Message&#x27;]&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></span><br></code></pre></td></tr></table></figure><blockquote><p><router-link>有push和replace属性来控制url的历史记录仪，默认开启的是push模式（栈先进后出），想要无痕模式的效果就写replace（每次干掉前一条，替代成为前一条）</router-link></p></blockquote><h2 id="1-3-路由点击时样式"><a href="#1-3-路由点击时样式" class="headerlink" title="1.3 路由点击时样式"></a>1.3 路由点击时样式</h2><ol><li>active-class</li></ol><p>在router-link中写入active-class</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;router-link to=<span class="hljs-string">&quot;/home&quot;</span> active-<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;active&quot;</span>&gt;首页&lt;/router-link&gt;<br></code></pre></td></tr></table></figure><p>由于active-class选择样式时根据路由中的路径去从左往右匹配，然后显示，前面的路径相同时便都可以匹配到。故最好在router-link中写入&#x3D;&#x3D;<strong>exact</strong>&#x3D;&#x3D;。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;router-link to=<span class="hljs-string">&quot;/home&quot;</span> active-<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;active&quot;</span> exact&gt;首页&lt;/router-link&gt;<br></code></pre></td></tr></table></figure><p>再在style中写样式，active是自命名的，也可以取为其他名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">.<span class="hljs-property">active</span> &#123;<br>    border-<span class="hljs-attr">bottom</span>: 2px solid #3a92e4;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>router-link-active</li></ol><p>直接使用样式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">.<span class="hljs-property">router</span>-link-active &#123;<br>  span &#123;<br>    border-<span class="hljs-attr">bottom</span>: 2px solid #3a92e4;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>若有多个路由样式不一样，则用类.router-link-active 分别控制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;router-link to=<span class="hljs-string">&quot;/home&quot;</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;menu-home&quot;</span>&gt;首页&lt;/router-link&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/my&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;menu-my&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span><br><br>.<span class="hljs-property">menu</span>-home.<span class="hljs-property">router</span>-link-active &#123;<br>   border-<span class="hljs-attr">bottom</span>: 2px solid #3a92e4;<br>&#125;<br><br>.<span class="hljs-property">menu</span>-my.<span class="hljs-property">router</span>-link-active &#123;<br>   border-<span class="hljs-attr">bottom</span>: 2px solid #ef4238;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-4-嵌套路由"><a href="#1-4-嵌套路由" class="headerlink" title="1.4 嵌套路由"></a>1.4 嵌套路由</h2><p>其他不变只是配置项用children</p><ol><li>编写<code>router</code>配置项</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span> (&#123;<br>     <span class="hljs-attr">routes</span>: [<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>,<br>            <span class="hljs-attr">component</span>: <span class="hljs-title class_">About</span>,<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>            <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span>,<br>            <span class="hljs-attr">children</span>:[<br>               &#123;<br>                   <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;news&#x27;</span>,  <span class="hljs-comment">//此处一定不要写/news</span><br>                   <span class="hljs-attr">component</span>:<span class="hljs-title class_">News</span><br>               &#125; <br>            ]<br>        &#125;, <br>&#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li>在template中配置url如何改变，写完整路径</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;router-link <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;list-group-item&quot;</span> active-<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;active&quot;</span> to=<span class="hljs-string">&quot;/home/news&quot;</span>&gt;<span class="hljs-title class_">Home</span>&lt;/router-link&gt;<br></code></pre></td></tr></table></figure><p><strong>总结：<code>template</code>中首先调用<router-link>改变url ，路由器实例检测到url变化会开始检测配置的路由，有符合的就找到应该替换的组件准备展示，由<code>template</code>中<code>&lt;router-view&gt;</code>指定该组件展示位置。</router-link></strong></p><blockquote><p>$router是VueRouter的一个实例，他包含了所有的路由，包括路由的跳转方法，钩子函数等，也包含一些子对象（例如history）。</p><p>$route是一个跳转的路由对象（路由信息对象），每一个路由都会有一个自己的$route对象，里面存储着自己的路由信息（包含参数信息）。</p></blockquote><h2 id="1-5-路由传参"><a href="#1-5-路由传参" class="headerlink" title="1.5 路由传参"></a>1.5 路由传参</h2><p>如果需求是点击不同按钮跳转后的页面结构类似，只是内容不同，比如点不同文章，进去是不同文章的详情页。就需要对跳转路由传参。</p><h3 id="query参数"><a href="#query参数" class="headerlink" title="query参数"></a>query参数</h3><p>写在<code>template</code>中，用<code>router-link</code>代替a改变url</p><p>传递参数</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;router-link :to = <span class="hljs-string">&quot;&#123;</span><br><span class="hljs-string">path:&#x27;/home/message/detail&#x27;,</span><br><span class="hljs-string">    query:&#123;</span><br><span class="hljs-string">        id: m.id,</span><br><span class="hljs-string">        title: m.title</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;&quot;</span>&gt; 跳转 &lt;/router-link&gt;<br></code></pre></td></tr></table></figure><p>接收参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">$route.<span class="hljs-property">query</span>.<span class="hljs-property">id</span><br>$route.<span class="hljs-property">query</span>.<span class="hljs-property">title</span><br></code></pre></td></tr></table></figure><h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><p>作用：简化路由跳转</p><p>用name给路由命名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span> (&#123;<br>     <span class="hljs-attr">routes</span>: [<br>        &#123;<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;about&#x27;</span>,<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>,<br>            <span class="hljs-attr">component</span>: <span class="hljs-title class_">About</span>,<br>        &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><p>简化跳转</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;router-link :to = <span class="hljs-string">&quot;&#123;</span><br><span class="hljs-string">name:&#x27;about&#x27;,</span><br><span class="hljs-string">    query:&#123;</span><br><span class="hljs-string">        id: m.id,</span><br><span class="hljs-string">        title: m.title</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="params参数"><a href="#params参数" class="headerlink" title="params参数"></a>params参数</h3><p>配置路由</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">children</span>:[<br>    &#123;<br>        <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiangiqng&#x27;</span>,<br>        <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;detail/:id/:title&#x27;</span>, <span class="hljs-comment">//使用占位符声明接收params参数</span><br>        <span class="hljs-attr">component</span>:<span class="hljs-title class_">Detail</span><br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>传递参数</p><p>param写法中路径不能写path，只能写<code>name</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;router-link :to = <span class="hljs-string">&quot;&#123;</span><br><span class="hljs-string">name:&#x27;about&#x27;,</span><br><span class="hljs-string">    params:&#123;</span><br><span class="hljs-string">        id: m.id,</span><br><span class="hljs-string">        title: m.title</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>接收参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">$route.<span class="hljs-property">params</span>.<span class="hljs-property">id</span><br>$route.<span class="hljs-property">params</span>.<span class="hljs-property">title</span><br></code></pre></td></tr></table></figure><h2 id="1-6-编程式路由导航"><a href="#1-6-编程式路由导航" class="headerlink" title="1.6 编程式路由导航"></a>1.6 编程式路由导航</h2><p>不借助<router-link>实现路由的跳转，更灵活。</router-link></p><p>&#x3D;&#x3D;<code>this.$router.push(&#123;&#125;)  </code>        内传的对象与<code>&lt;router-link&gt;</code>中的<code>to</code>相同&#x3D;&#x3D;</p><p><code>this.$router.replace(&#123;&#125;)</code></p><p><code>this.$router.forward()</code>     前进</p><p><code>this.$router.back()</code>           后退</p><p><code>this.$router.go(n)</code>             可前进也可后退，n为正数前进n，负数后退</p><h2 id="1-7-路由守卫"><a href="#1-7-路由守卫" class="headerlink" title="1.7 路由守卫"></a>1.7 路由守卫</h2><p>作用：对路由进行权限控制</p><p>分类：全局守卫、独享守卫、组件内守卫</p><p>全局守卫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span> (&#123;<br>     <span class="hljs-attr">routes</span>: [<br>        &#123;<br>            <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;guanyu&#x27;</span>,<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>,<br>            <span class="hljs-attr">component</span>: <span class="hljs-title class_">About</span>,<br>            <span class="hljs-attr">meta</span>:&#123;<span class="hljs-attr">isAuth</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">title</span>:<span class="hljs-string">&#x27;消息&#x27;</span>&#125; <span class="hljs-comment">//是否需要权限校验</span><br>        &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//全局前置路由守卫，初始化和每次路由切换之前被调用</span><br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// if (to.path === &#x27;/home/news&#x27; || to.path === &#x27;/home/message&#x27;)</span><br>    <span class="hljs-comment">// if (to.name === &#x27;xinwen&#x27; || to.name === &#x27;xiaoxi&#x27;)</span><br>    <span class="hljs-keyword">if</span> (to.<span class="hljs-property">meta</span>.<span class="hljs-property">isAuth</span>)  <span class="hljs-comment">//判断是否需要鉴权</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;school&#x27;</span>) === <span class="hljs-string">&#x27;school&#x27;</span>) &#123;<br>            <span class="hljs-title function_">next</span>()<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;学校名不对,无权限查看！&#x27;</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 放行 </span><br>        <span class="hljs-title function_">next</span>()<br>    &#125;<br>&#125;)<br><br><span class="hljs-comment">//全局后置路由守卫，初始化和每次路由切换之后被调用</span><br>router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = to.<span class="hljs-property">meta</span>.<span class="hljs-property">title</span> || <span class="hljs-string">&#x27;路由学习&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>独享守卫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// beforeEnter和children同级 </span><br><span class="hljs-attr">beforeEnter</span>: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">if</span> (to.<span class="hljs-property">meta</span>.<span class="hljs-property">isAuth</span>)  <span class="hljs-comment">//判断是否需要鉴权</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;school&#x27;</span>) === <span class="hljs-string">&#x27;school&#x27;</span>) &#123;<br>        <span class="hljs-title function_">next</span>()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;学校名不对,无权限查看！&#x27;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">next</span>()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>组件内守卫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//跟mounted()&#123;&#125;同级</span><br><br><span class="hljs-comment">//通过路由规则,进入该组件时被调用</span><br>beforeRouteEnter (to, <span class="hljs-keyword">from</span>, next) &#123; &#125;<br><span class="hljs-comment">//通过路由规则，离开该组件时被调用</span><br>beforeRouteLeave (to, <span class="hljs-keyword">from</span>, next) &#123; &#125;<br></code></pre></td></tr></table></figure><blockquote><p>后置守卫是切换完就调，组件内守卫beforeRouteLeave是离开该组件时调用</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue响应式原理</title>
    <link href="/2023/06/22/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <url>/2023/06/22/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>所谓 <code>vue</code> 的响应式，即组件 <code>data</code> 的数据一旦变化，就会立刻触发视图的更新。</p><h1 id="Vue检测数据的原理"><a href="#Vue检测数据的原理" class="headerlink" title="Vue检测数据的原理"></a>Vue检测数据的原理</h1><h2 id="Vue监测对象数据改变的原理"><a href="#Vue监测对象数据改变的原理" class="headerlink" title="Vue监测对象数据改变的原理"></a>Vue监测对象数据改变的原理</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>= <span class="hljs-string">&quot;root&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学校名称<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#root&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;尚硅谷&#x27;</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li><code>vm</code>会将<code>data</code>加工后赋值给自身的属性<code>_data</code>，且始终保持一致，并且直接通过<code>defineproperty()</code>加上<code>_data</code>中的属性</li><li>当读取<code>vm.name</code>，其实是调用了<code>vm</code>上的<code>getter</code>，把<code>vm._data</code>里面的<code>name</code>返回</li><li>当修改<code>vm.name</code>，其实是调用了<code>vm</code>上的<code>setter</code>，把<code>vm._data</code>里面的<code>name</code>修改</li></ol><p><code>1</code>中加工后，<code>_data</code>中的数据不再直接给，而是通过get、set方法，当读取或者修改<code>_data</code>中数据时就会调用get、set方法，set方法中写了一个重新解析模板的调用，会引起页面变化。故<code>vue</code>能做到响应式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-comment">// 1.准备好data数据</span><br>    <span class="hljs-keyword">let</span> data = &#123;<br>      <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;北京&#x27;</span><br>    &#125;<br><br>    <span class="hljs-comment">// 创建一个监视的实例对象，用于监视data中属性的变化</span><br>    <span class="hljs-keyword">const</span> obs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>(data)<br><br>    <span class="hljs-comment">// 准备一个vm实例对象</span><br>    <span class="hljs-keyword">let</span> vm = &#123;&#125;<br>    vm.<span class="hljs-property">_data</span> = data = obs  <span class="hljs-comment">// 这样vm._data和data中的数据都是动态的数据（getter、setter）</span><br><br>    <span class="hljs-comment">//  2. 创建监视对象的构造函数，使用defineProperty给实例添加data中的属性，动态返回data中的数据和修改</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Observer</span>(<span class="hljs-params">obj</span>) &#123;<br>      <span class="hljs-comment">// 汇总对象中所有的属性形成一个数组</span><br>      <span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)<br>      <span class="hljs-comment">// 遍历</span><br>      keys.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">k</span>)=&gt;</span>&#123;<br>          <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-variable language_">this</span>,k,&#123;<br>              <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;<br>                  <span class="hljs-keyword">return</span> obj[k]<br>              &#125;,<br>              <span class="hljs-title function_">set</span>(<span class="hljs-params">val</span>)&#123;<br>                  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;k&#125;</span>被改了，我要去解析模板，生成虚拟DOM...我要开始忙了`</span>)<br>                  obj[k] = val<br>              &#125;<br>          &#125;)<br>      &#125;)<br>    &#125;<br> &lt;/script&gt;<br></code></pre></td></tr></table></figure><p>vue更完善的是，当data中嵌套有对象时，vue会一直递归的创建getter、setter，直到非对象。</p><blockquote><p>vm将源数据data中的数据加工（getter、setter）后存储到下划线data上，进行实际的读取和赋值响应式更新。同时又把数据返回到vm上方便模板里面直接用，而不是繁琐的。</p><p>data中是源数据并且vm.data不存在，下划线data是有数据劫持的，并且有vm._data。</p></blockquote><h2 id="Vue-set的使用"><a href="#Vue-set的使用" class="headerlink" title="Vue.set的使用"></a>Vue.set的使用</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello,&#123;&#123;student.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello,&#123;&#123;student.sex&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello,&#123;&#123;student.age&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#root&#x27;</span>, <span class="hljs-comment">// el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串</span></span><br><span class="language-javascript">        <span class="hljs-attr">data</span>: &#123;   <span class="hljs-comment">// data中用于存储数据，数据供el所指定的容器去使用</span></span><br><span class="language-javascript">            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;你好&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">student</span>: &#123;</span><br><span class="language-javascript">                <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;wang&#x27;</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">hobby</span>: [<span class="hljs-string">&#x27;打篮球&#x27;</span>,<span class="hljs-string">&#x27;打网球&#x27;</span>,<span class="hljs-string">&#x27;打足球&#x27;</span>]</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>事先没有在<code>data</code>中写的对象属性，如果以后想动态添加：</p><p>直接用<code>vm._data.student_sex</code>是不管用的，这种方法不会创建getter、setter方法（不是系统用<code>defineProperty</code>创建的）</p><p>更不可能直接在vm上添加，<code>vm.sex</code>，因为<code>vm</code>上的属性也是动态的从<code>vm._data</code>上取的，自己写的<code>vm.sex</code>一方面不会有getter、setter方法去拿，另一方面就算能去<code>vm._data</code>上拿，<code>vm._data</code>上也没有对应<code>getter、setter</code>方法。</p><p>Vue提供了相关的api实现动态向对象里添加属性(具有响应特性，数据变化能反映到页面)、修改数组的方法：</p><p><strong>Vue.set(target, key , val)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">set</span>(vm.<span class="hljs-property">_data</span>.<span class="hljs-property">student</span>,<span class="hljs-string">&#x27;sex&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>)<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">set</span>(vm.<span class="hljs-property">student</span>,<span class="hljs-string">&#x27;age&#x27;</span>,<span class="hljs-string">&#x27;19&#x27;</span>)<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">set</span>(vm.<span class="hljs-property">student</span>.<span class="hljs-property">hobby</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;打台球&#x27;</span>)<br></code></pre></td></tr></table></figure><p>另外一个在vm上可以有相同作用的api是<code>vm.$set</code>，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">vm.$set(vm.<span class="hljs-property">_data</span>.<span class="hljs-property">student</span>,<span class="hljs-string">&#x27;sex&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>)<br>vm.$set(vm.<span class="hljs-property">student</span>,<span class="hljs-string">&#x27;age&#x27;</span>,<span class="hljs-string">&#x27;19&#x27;</span>)<br>vm.$set(vm.<span class="hljs-property">student</span>.<span class="hljs-property">hobby</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;打台球&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>注意对象不能是Vue实例或者Vue实例的根数据对象。即target不能是vm或vm._data</p></blockquote><h2 id="Vue监测数组数据改变的原理"><a href="#Vue监测数组数据改变的原理" class="headerlink" title="Vue监测数组数据改变的原理"></a>Vue监测数组数据改变的原理</h2><p>vue不会给数组里面的每一项创建getter、 setter，也就是说通过索引值修改数组里的某一项，不是响应式的。只有通过vue提供的包装过的数组方法，才是响应式的关于vue数组方法详见<a href="https://airfe.gitee.io/blog/2023/05/22/%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8BArray/">集合引用类型Array</a></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">vm.<span class="hljs-property">_data</span>.<span class="hljs-property">student</span>.<span class="hljs-property">hobby</span>.<span class="hljs-property">push</span><br></code></pre></td></tr></table></figure><p>但是对data中的数组操作这些方法调用的并不是原始Array.prototype上的方法，是经过vue封装了的，vue做了两件事，第一件事就是实现跟Array.prototype上方法同样的功能（改变数组），第二间事情是重新解析模板生成虚拟DOM等等。</p><h2 id="重新解析模板"><a href="#重新解析模板" class="headerlink" title="重新解析模板"></a>重新解析模板</h2><p>每个组件实例都对应一个 <strong>watcher</strong> 实例，它会在组件渲染的过程中把属性记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher重新计算，从而使它关联的组件重新渲染。</p><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/markdown/image-20230626153710510.png" alt="image-20230626153710510"></p><h1 id="Vue2的基本原理（总结）"><a href="#Vue2的基本原理（总结）" class="headerlink" title="Vue2的基本原理（总结）"></a>Vue2的基本原理（总结）</h1><p>借助于<code>defineproperty</code>实现数据代理和数据劫持，把<code>data</code>里的属性都设置了<code>getter、setter</code>, 在<code>getter</code>中除了简单的把值返回，<code>Vue实例</code>的观察程序实例<code>watcher</code>会进行收集依赖，也就是标签和数据属性的对应关系。当这些依赖的<code>setter</code>被调用时，<code>watcher</code>会重新计算，进行视图更新。</p><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p><code>Vue2</code>使用<code>Object.defineProperty</code>进行数据拦截，但有些时候无法拦截到。有以下缺陷</p><p><strong>1）深度监听，需要递归到底，一次性计算量大</strong></p><p>在遍历对象或数组时，需要进行深度监听，即需要递归到底，这会使得一次性计算量非常大。（这个问题在 <code>vue3.0</code> 中已经解决，<code>vue3.0</code>使用<code>proxy</code>，其解决原理是不一定要一次性递归，而是可以我们什么时候用，什么时候再递归。这个将放在后面的文章中讲解）</p><p><strong>2）无法监听对象新增属性&#x2F;删除属性</strong></p><p><code>Object.defineProperty()</code> 在进行新增对象的属性和删除属性时，视图是无法进行更新的，也就是数据监听不到，这一点在平常的开发中需要特别注意！否则有时候我们在取数据时总会莫名其妙地都不知道自己错在哪里。通常解决这个问题的方法是，使用 <code>Vue.set</code> 和 <code>Vue.delete</code> 来进行<strong>新增属性</strong>和<strong>删除属性</strong>，这样就可以解决数据无法监听的问题。</p><p><strong>3）无法原生监听数组，需要特殊处理</strong></p><p><code>Object.defineProperty()</code> 这个 <code>API</code> 本身<strong>无法监听原生数组</strong>，下标方式修改数组数不会触发组件的重新渲染，需要通过<strong>重新定义数组原型</strong>的方式，来对数组进行数据监听。</p>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue基础知识</title>
    <link href="/2023/06/22/Vue%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/06/22/Vue%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Vue基础"><a href="#一、Vue基础" class="headerlink" title="一、Vue基础"></a>一、Vue基础</h1><h2 id="1-1-模板语法"><a href="#1-1-模板语法" class="headerlink" title="1.1 模板语法"></a>1.1 模板语法</h2><p>Vue模板语法包括两大类</p><ol><li><p><strong>差值语法</strong></p><p>功能: 用于解析标签体内容。</p><p>写法: ， xxx是<strong>js表达式</strong>。且可以直接读取到data中的所有属性。</p></li><li><p><strong>指令语法</strong></p><p>功能: 用于解析标签(包括：标签属性、标签体内容、绑定事件…..)。</p><p>举例:<code>&lt;a v-bind:href=&quot;xxx&quot;&gt; </code>或简写为<code> &lt;a :href=&quot;xxx&quot;&gt;</code>，xxx同样要写<strong>js表达式</strong>，</p><p>且可以直接读取到data中的所有属性。<code>xxx</code>解析显示的是去引号之后的值。</p><blockquote><p>Vue中有很多的指令，且形式都是<code>v-？？？</code>,此处只是拿<code>v-bind</code>举例。</p></blockquote></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!--插值语法--&gt;<br>&lt;h2&gt;&#123;&#123;firstName + &#x27; &#x27; + lastName&#125;&#125;&lt;/h2&gt;<br>&lt;!--指定语法--&gt;<br>//动态指定元素标签值<br>&lt;a :href=&quot;url&quot;&gt;点我去百度学习&lt;/a&gt; <br>//动态设置元素标签同时多个值的状态<br>&lt;h2 :class=&quot;&#123;active:isActive, line:isline&#125;&quot;&gt;点我去百度学习&lt;/h2&gt;<br>//根据表达式动态指定标签值<br>&lt;div :class=&quot;leftOrRight === &#x27;left&#x27; ? &#x27;left&#x27; : &#x27;right&#x27;&quot;&gt;<br></code></pre></td></tr></table></figure><blockquote><p>标签里的标签属性不能用差值语法来动态指定，若要动态设置标签属性用指令语法中的v-bind（语法糖为冒号：）</p></blockquote><h2 id="1-2-数据绑定"><a href="#1-2-数据绑定" class="headerlink" title="1.2 数据绑定"></a>1.2 数据绑定</h2><p><code>Vue</code>中有两种数据绑定的方式</p><ol><li><p><strong>单向绑定</strong><code>v-bind</code></p><p>只能从data流向页面</p></li><li><p><strong>双向绑定</strong><code>v-model</code></p><p>不仅能从data流向页面，还可以页面流向data</p><blockquote><p>双向绑定一般都应用在表单类元素上，如<code>&lt;input&gt;``&lt;select&gt;``&lt;textarea&gt;</code></p><p>v-model:value可以简写为v-model因为v-model默认收集的就是value 值</p></blockquote></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">单向数据绑定: &lt;input type=&quot;text&quot; :value= ”name&quot;&gt;&lt;br/&gt;<br>双向数据绑定: &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;&lt;br/&gt;<br></code></pre></td></tr></table></figure><h2 id="1-3-事件处理"><a href="#1-3-事件处理" class="headerlink" title="1.3 事件处理"></a>1.3 事件处理</h2><h3 id="1-3-1-事件的基本用法"><a href="#1-3-1-事件的基本用法" class="headerlink" title="1.3.1 事件的基本用法"></a>1.3.1 事件的基本用法</h3><ol><li><p>&#x3D;&#x3D;使用<code>v-on:xxx</code>或<code>@xx</code>绑定事件，其中xxx是事件名&#x3D;&#x3D;</p></li><li><p>事件的回调需要配置在<code>methods </code>对象中，最终会在<code>vm</code>上</p></li><li><p><code>methods </code>中配置的函数,<code>不要用箭头函数</code>，否则this就不是<code>vm</code>了</p></li><li><p><code>methods</code> 中配置的函数，都是被<code>Vue </code>所管理的函数，this 的指向是<code>vm</code>或<code>组件实例对象</code></p></li><li><p><code>@c1ick=&quot; demo&quot;</code>和<code>@c1ick=&quot; demo($event)&quot;</code>效果一致，但后者可以传参</p></li></ol><h3 id="1-3-2-事件修饰符"><a href="#1-3-2-事件修饰符" class="headerlink" title="1.3.2 事件修饰符"></a>1.3.2 事件修饰符</h3><p>Vue中的事件修饰符:</p><ol><li><strong>prevent</strong>:    阻止默认事件(常用)</li><li><strong>stop</strong>:          阻止事件冒泡(常用)</li><li><strong>once</strong>:         事件只触发一次(常用) </li><li>capture:    使用事件的捕获(与冒泡顺序相反)模式</li><li>self:            只有event.target是当前操作的元素时才触发事件</li><li>passive:     事件的默认行为立即执行，无需等待事件回调执行完毕</li></ol><blockquote><p>修饰符可以连续写，比如可以这么用: @click.prevent.stop&#x3D;” showInfo”</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 阻止事件冒泡(常用) --&gt;<br>&lt;div class=&quot;demo1&quot; @click=&quot;showInfo&quot; &gt;<br>&lt;button @click.stop=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt;<br>&lt;/div&gt;<br>&lt;!-- 事件只触发一次(常用) --&gt;<br>&lt;button @click.once=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt;<br>&lt;!--使用事件的捕获模式--&gt;<br>&lt;div class= &quot;box1&quot; @click.capture=&quot;showMsg(1)&quot;&gt;<br>    div1<br>    &lt;div class=&quot;box2&quot; @click=&quot;showMsg(2)&quot;&gt;<br>        div2<br>    &lt;/div&gt;<br>&lt;/div&gt;<br>&lt;!--只有event.target是当前操作的元素时才触发事件; --&gt;<br>&lt;div class=&quot;demo1&quot; @click.self=&quot; showInfo&quot;&gt;<br>&lt;button @click=&quot;showInfo&quot; &gt;点我提示信息&lt;/ button&gt;<br>&lt;/div&gt;<br>&lt;!--事件的默认行为立即执行，无需等待事件回调执行完毕; - - &gt;<br>&lt;!-- scrol1是滚动条滚动，passsive没有影响--&gt;<br>&lt;!-- whee1是鼠标滚轮滚动，passive有影响--&gt;<br>&lt;ul @wheel.passive=&quot;demo&quot; class=&quot;list&quot;&gt;<br>    &lt;1i&gt;1&lt;/1i&gt;<br>    &lt;li&gt;2&lt;/li&gt;<br>    &lt;li&gt;3&lt;/li&gt;<br>    &lt;li&gt;4&lt;/li&gt;<br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><h3 id="1-3-2-鼠标事件"><a href="#1-3-2-鼠标事件" class="headerlink" title="1.3.2 鼠标事件"></a>1.3.2 鼠标事件</h3><ul><li><p>单击事件&#x2F;双击事件 <code>@click() / @dblclick()</code></p></li><li><p>按下触发&#x2F;抬起触发  <code>@mousedown() / @mouseup()</code></p></li><li><p>当鼠标指针在<code>指定的元素中移动时</code>，就会发生 mousemove 事件移动一个像素，就会发生一次 <code>mousemove  @mousemove()</code></p></li><li><p>当鼠标指针离开被选元素时，会发生 mouseleave 事件   <code>@mouseleave()</code></p></li><li><p>当鼠标指针从元素上移开时，发生 mouseout 事件          <code>@mouseout()</code></p><blockquote><p>与 mouseleave 事件不同，不论鼠标指针离开<code>被选元素还是任何子元素，</code>都会触发 mouseout 事件。</p></blockquote></li><li><p>当鼠标指针进入<code>被选元素时，</code>会发生 mouseenter 事件   <code>@mouseenter()</code></p></li><li><p>当鼠标指针位于元素上方时，会发生 mouseover 事件   <code>@mouseover()</code></p><blockquote><p>注意：与 mouseenter 事件不同，mouseover 事件在鼠标指针进入<code>被选元素或任意子元素时</code>都会被触发，mouseenter 事件只有在鼠标指针进入<code>被选元素</code>时被触发。</p></blockquote></li></ul><h3 id="1-3-3-键盘事件"><a href="#1-3-3-键盘事件" class="headerlink" title="1.3.3 键盘事件"></a>1.3.3 键盘事件</h3><blockquote><p>键盘上的每个按键都有自己的名称和编码，例如: Enter (13) 。而Vue还对一些常用按键起了别名方便使用</p></blockquote><ul><li><p>Vue中常用的按键别名</p><ul><li>回车<code>enter</code></li><li>删除<code>delete</code>捕获“删除”和“退格”键</li><li>退出<code>esc</code></li><li>空格<code>space</code></li><li>换行<code>tab</code>特殊，必须配合<code>keydown </code>使用</li><li>上<code>up</code></li><li>下| <code>down</code></li><li>左<code>left</code></li><li>右<code>right</code></li></ul></li><li><p>Vue 未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为<code>kebab-case</code>(多单词小写,短横线写法)</p></li><li><p>系统修饰键(用法特殊)，ctrl alt shift meta(meta就是win键)</p><ul><li>配合<code>keyup </code>使用:按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发指定ctr+y使用<code>@keyup.ctr.y </code></li><li>配合<code>keydown</code> 使用：正常触发事件</li></ul></li><li><p><strong>Vue.config.keyCodes.自定义键名</strong> &#x3D; 键码，可以去定制按键别名</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>欢迎打开&#123;&#123;name&#125;&#125;笔记<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;按下回车提示输入”@keyup.enter=&quot;</span><span class="hljs-attr">showInfo</span>&quot;&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;按下tab提示输入”@keydown.tab=&quot;</span><span class="hljs-attr">showInfo</span>&quot;&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;按下回车提示输入”@keydown.huiche=&quot;</span> <span class="hljs-attr">showInfo</span>&quot;&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                                                                        <br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"> </span><br><span class="language-javascript">    <span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span><span class="hljs-comment">//阻止vue: 在启动时生成生产提示。</span></span><br><span class="language-javascript">    <span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">keyCodes</span>.<span class="hljs-property">huiche</span> = <span class="hljs-number">13</span><span class="hljs-comment">//定义了一个别名按键</span></span><br><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#root&quot;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">            &#125;,</span><br><span class="language-javascript">            <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-title function_">showInfo</span>(<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-comment">// console.log(e.key,e.keyCode)</span></span><br><span class="language-javascript">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>)</span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="1-4-计算属性和侦听属性"><a href="#1-4-计算属性和侦听属性" class="headerlink" title="1.4 计算属性和侦听属性"></a>1.4 计算属性和侦听属性</h2><h3 id="1-4-1computed计算属性"><a href="#1-4-1computed计算属性" class="headerlink" title="1.4.1computed计算属性"></a>1.4.1<code>computed</code>计算属性</h3><ol><li>定义：要用的属性不存在，<code>需要通过已有属性计算得来</code></li><li>原理:底层借助了<code>objcet .defineproperty()</code>方法提供的<code>getter</code> 和<code>setter</code></li><li><code>get</code>函数什么时候执行?<br>a. 初次读取时会执行一次，并做<strong>缓存</strong><br>b. 当依赖的数据发生改变时会被再次调用</li><li>优势：与<code>methods</code>实现相比，<code>内部有缓存机制(复用)</code>，效率更高，调试方便</li></ol><blockquote><p>计算属性最终会出现在vm上，直接读取使用即可</p><p>如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变</p><p>如果计算属性确定不考虑修改，可以使用计算属性的简写形式</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br>     姓：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;firstName&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>     名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;lastName&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>     测试：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;x&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span> // 这里修改 不会调 fullName的get方法<br>     全名：<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>     <span class="hljs-comment">&lt;!-- 全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br/&gt; --&gt;</span><br>     <span class="hljs-comment">&lt;!-- 全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br/&gt; --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">     <span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span></span><br><span class="language-javascript">     <span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">         <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#root&#x27;</span>,</span><br><span class="language-javascript">         <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">             <span class="hljs-attr">firstName</span>:<span class="hljs-string">&#x27;张&#x27;</span>,</span><br><span class="language-javascript">             <span class="hljs-attr">lastName</span>:<span class="hljs-string">&#x27;三&#x27;</span>,</span><br><span class="language-javascript">             <span class="hljs-attr">x</span>:<span class="hljs-string">&#x27;你好&#x27;</span></span><br><span class="language-javascript">         &#125;,</span><br><span class="language-javascript">         <span class="hljs-attr">computed</span>: &#123;</span><br><span class="language-javascript">         <span class="hljs-comment">// 完整写法</span></span><br><span class="language-javascript">         <span class="hljs-comment">// fullName: &#123;</span></span><br><span class="language-javascript">         <span class="hljs-comment">// get() &#123;</span></span><br><span class="language-javascript">         <span class="hljs-comment">// console.log(&#x27;get被调用了&#x27;)</span></span><br><span class="language-javascript">         <span class="hljs-comment">// return this.firstName + &#x27;-&#x27; + this.lastName</span></span><br><span class="language-javascript">         <span class="hljs-comment">// &#125;,</span></span><br><span class="language-javascript">         <span class="hljs-comment">// set(value) &#123;</span></span><br><span class="language-javascript">         <span class="hljs-comment">// console.log(&#x27;set&#x27;, value)</span></span><br><span class="language-javascript">         <span class="hljs-comment">// const arr = value.split(&#x27;-&#x27;)</span></span><br><span class="language-javascript">         <span class="hljs-comment">// this.firstName = arr[0]</span></span><br><span class="language-javascript">         <span class="hljs-comment">// this.lastName = arr[1]</span></span><br><span class="language-javascript">         <span class="hljs-comment">// &#125;</span></span><br><span class="language-javascript">         <span class="hljs-comment">// &#125;</span></span><br><span class="language-javascript">         <span class="hljs-comment">// 只读取不修改时可以简写</span></span><br><span class="language-javascript">         <span class="hljs-title function_">fullName</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">             <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;get被调用了&#x27;</span>)</span><br><span class="language-javascript">             <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27;-&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span></span><br><span class="language-javascript">             &#125;</span><br><span class="language-javascript">         &#125;</span><br><span class="language-javascript">     &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>计算属性可以被修改，要修改的话就要写setter函数，在setter函数中修改掉其依赖的data中的属性才会真正修改计算属性值。</p><p>修改计算属性——&gt;setter——&gt;影响到getter返回值</p><h3 id="1-4-2-watch侦听属性"><a href="#1-4-2-watch侦听属性" class="headerlink" title="1.4.2 watch侦听属性"></a>1.4.2 <code>watch</code>侦听属性</h3><ul><li>基本属性<ul><li>当被监视的属性变化时，回调函数自动调用，进行相关操作 </li><li>监视的属性必须存在，才能进行监视，既可以监视 **data中的普通属性 ，也可以监视计算属性 **</li><li>配置项属性<strong>immediate:false</strong> ，<strong>改为 true</strong>，则初始化时调用一次 <strong>handler(newValue,oldValue)</strong> </li><li>监视有两种写法<ul><li>创建 <strong>Vue 时传入 watch: {} 配置</strong> </li><li>通过 vm.$watch() 监视</li></ul></li></ul></li><li>深度侦听<ul><li>Vue 中的 watch 默认不监测对象内部值的改变（一层） </li><li>在 watch 中配置 deep:true 可以监测对象内部值的改变（多层） </li><li>Vue 自身可以监测对象内部值的改变，但 Vue 提供的 watch 默认不可以 </li><li>使用 watch 时根据监视数据的具体结构，决定是否采用深度监视</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>天气案例_监视属性_简写<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>今天天气很&#123;&#123; info &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeWeather&quot;</span>&gt;</span>切换天气<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>a的值是：&#123;&#123;number.a&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span> <br>     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;numbers.a++&quot;</span>&gt;</span>点击a+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">     <span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span></span><br><span class="language-javascript">     <span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">         <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#root&#x27;</span>,</span><br><span class="language-javascript">         <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">             <span class="hljs-attr">isHot</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">             <span class="hljs-attr">numbers</span>: &#123;</span><br><span class="language-javascript">                 <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">                 <span class="hljs-attr">b</span>: <span class="hljs-number">1</span></span><br><span class="language-javascript">             &#125;</span><br><span class="language-javascript">         &#125;,</span><br><span class="language-javascript">         <span class="hljs-attr">computed</span>: &#123;<span class="hljs-title function_">info</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">isHot</span> ? <span class="hljs-string">&#x27;炎热&#x27;</span> : <span class="hljs-string">&#x27;凉爽&#x27;</span>&#125;&#125;,</span><br><span class="language-javascript">         <span class="hljs-attr">methods</span>: &#123;<span class="hljs-title function_">changeWeather</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">isHot</span> = !<span class="hljs-variable language_">this</span>.<span class="hljs-property">isHot</span>&#125;&#125;,</span><br><span class="language-javascript">         <span class="hljs-attr">watch</span>: &#123;</span><br><span class="language-javascript">             <span class="hljs-comment">// 正常写法</span></span><br><span class="language-javascript">             <span class="hljs-comment">// isHot: &#123;</span></span><br><span class="language-javascript">                 <span class="hljs-comment">// immediate:true, // 初始化时让handler调用一下</span></span><br><span class="language-javascript">                 <span class="hljs-comment">// deep:true, // 深度监视</span></span><br><span class="language-javascript">                 <span class="hljs-comment">// 当isHot发生改变时handler被调用</span></span><br><span class="language-javascript">                 <span class="hljs-comment">// handler(newValue, oldValue) &#123;</span></span><br><span class="language-javascript">             <span class="hljs-comment">// console.log(&#x27;isHot被修改了&#x27;, newValue, oldValue)</span></span><br><span class="language-javascript">                 <span class="hljs-comment">// &#125;</span></span><br><span class="language-javascript">             <span class="hljs-comment">// &#125;,</span></span><br><span class="language-javascript">             <span class="hljs-comment">// 简写</span></span><br><span class="language-javascript">             <span class="hljs-title function_">isHot</span>(<span class="hljs-params">newValue, oldValue</span>) &#123;</span><br><span class="language-javascript">                 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;isHot被修改了&#x27;</span>, newValue, oldValue, <span class="hljs-variable language_">this</span>)</span><br><span class="language-javascript">             &#125;,</span><br><span class="language-javascript">             <span class="hljs-comment">// 监视多级结构中某个属性的变化</span></span><br><span class="language-javascript">             <span class="hljs-string">&#x27;numbers.a&#x27;</span>: &#123;</span><br><span class="language-javascript">                 <span class="hljs-title function_">handler</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">             <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a被修改了&#x27;</span>)</span><br><span class="language-javascript">                 &#125;</span><br><span class="language-javascript">             &#125;,</span><br><span class="language-javascript">             <span class="hljs-comment">// 监视多级结构中所有属性变化</span></span><br><span class="language-javascript">             <span class="hljs-attr">numbers</span>: &#123;</span><br><span class="language-javascript">                 <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">                 <span class="hljs-title function_">handler</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">             <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;numbers被修改了&#x27;</span>)</span><br><span class="language-javascript">                 &#125;</span><br><span class="language-javascript">             &#125;</span><br><span class="language-javascript">         &#125;</span><br><span class="language-javascript">     &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-4-3-计算属性VS侦听属性"><a href="#1-4-3-计算属性VS侦听属性" class="headerlink" title="1.4.3 计算属性VS侦听属性"></a>1.4.3 计算属性VS侦听属性</h3><ul><li>computed能完成的功能，watch都可以完成。</li><li>watch能完成的功能，computed不一定能完成，例如: watch可  进行异步操作。</li><li>两个重要的小原则:<ul><li>所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm或组件实例对象。</li><li>所有不被Vue所管理的函数(&#x3D;&#x3D;定时器的回调函数、ajax的回调函数等&#x3D;&#x3D;)，最好写成&#x3D;&#x3D;箭头函数&#x3D;&#x3D;(没有自身的this)，这样this的指向才是vm或组件实例对象。</li></ul></li></ul><p><strong>使用计算属性</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>     <span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#root&#x27;</span>,<br>     <span class="hljs-attr">data</span>:&#123;<br>         <span class="hljs-attr">firstName</span>:<span class="hljs-string">&#x27;张&#x27;</span>,<br>         <span class="hljs-attr">lastName</span>:<span class="hljs-string">&#x27;三&#x27;</span><br>     &#125;,<br>     <span class="hljs-attr">computed</span>:&#123;<br>         <span class="hljs-title function_">fullName</span>(<span class="hljs-params"></span>)&#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27;-&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span><br>         &#125;<br>     &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>使用监听属性</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">new Vue(&#123;<br>     el:&#x27;#root&#x27;,<br>     data:&#123;<br>         firstName:&#x27;张&#x27;,<br>         lastName:&#x27;三&#x27;,<br>         fullName:&#x27;张-三&#x27;<br>     &#125;,<br>     watch:&#123;<br>         firstName(val)&#123;<br>         setTimeout(()=&gt;&#123;<br>             this.fullName = val + &#x27;-&#x27; + this.lastName<br>         &#125;,1000);<br>     &#125;,<br>     lastName(val)&#123;<br>         this.fullName = this.firstName + &#x27;-&#x27; + val<br>     &#125;<br>     &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="1-5-绑定样式和条件渲染"><a href="#1-5-绑定样式和条件渲染" class="headerlink" title="1.5 绑定样式和条件渲染"></a>1.5 绑定样式和条件渲染</h2><h3 id="1-5-1-绑定class样式"><a href="#1-5-1-绑定class样式" class="headerlink" title="1.5.1 绑定class样式"></a>1.5.1 绑定class样式</h3><blockquote><p>写法:  <code>:class=&quot;xxx&quot;</code>xxx可以是字符串、数组、对象</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-comment">&lt;!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定类名 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;basic&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;mood&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br> <span class="hljs-comment">&lt;!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;basic&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;classArr&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br> <span class="hljs-comment">&lt;!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;basic&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;classObj&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><br>data:&#123;<br>     name: &#x27;尚硅谷&#x27;,<br>     mood: &#x27;normal&#x27;,<br>     classArr: [&#x27;atguigu1&#x27;, &#x27;atguigu2&#x27;, &#x27;atguigu3&#x27;],<br>     classObj: &#123;<br>         atguigu1: false,<br>         atguigu2: false,<br>     &#125;, <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-5-2-绑定style样式"><a href="#1-5-2-绑定style样式" class="headerlink" title="1.5.2 绑定style样式"></a>1.5.2 绑定style样式</h3><blockquote><p>写法：<code>:style=&quot;&#123;fontSize: xxx&#125;&quot; </code>中xxx是动态值</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--绑定style样式--对象写法--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;basic&quot;</span> <span class="hljs-attr">:sty1e</span>=<span class="hljs-string">&quot;sty1e0bj&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>data:&#123;<br>    styleObj: &#123;<br>        fontSize:40px,<br>        color:red<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-5-3-条件渲染"><a href="#1-5-3-条件渲染" class="headerlink" title="1.5.3 条件渲染"></a>1.5.3 条件渲染</h3><h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h4><ul><li><p>写法跟if-else语法类似</p><p>&#x3D;&#x3D;v-if&#x3D;“表达式”&#x3D;&#x3D;</p><p>&#x3D;&#x3D;v-else-if&#x3D;“表达式”&#x3D;&#x3D;</p><p>&#x3D;&#x3D;v-else&#x3D;&#x3D;</p></li></ul><blockquote><p>适用于：切换频率较低的场暴，因为不展示的<strong>DOM</strong>元素直接被移除</p><p>注意:<code>v-if </code>可以和<code>v-else-if</code> <code>v-else</code>起使用，但要求<strong>结构不能被打断</strong></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 使用v-if做条件渲染 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;n === 1&quot;</span>&gt;</span>Angular<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;n === 2&quot;</span>&gt;</span>React<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;n === 3&quot;</span>&gt;</span>Vue<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h4><ul><li>写法：<code>v-show=&quot;表达式&quot;</code></li></ul><blockquote><p>适用于：切换频率较高的场暴</p><p>特点：不展示的<code>DOM</code>元素被移除，仅仅是使用样式隐藏掉<code>display：none</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 使用v-show做条件渲染 --&gt;<br>&lt;h2 v-show=&quot;false&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt;<br>&lt;h2 v-show=&quot;1 === 1&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt;<br></code></pre></td></tr></table></figure><h2 id="1-6-列表渲染和数据监视"><a href="#1-6-列表渲染和数据监视" class="headerlink" title="1.6 列表渲染和数据监视"></a>1.6 列表渲染和数据监视</h2><h3 id="1-6-1-列表渲染"><a href="#1-6-1-列表渲染" class="headerlink" title="1.6.1 列表渲染"></a>1.6.1 列表渲染</h3><h4 id="1-6-1-1-基本列表"><a href="#1-6-1-1-基本列表" class="headerlink" title="1.6.1.1 基本列表"></a>1.6.1.1 基本列表</h4><p><code>v-for</code> 指令用于展示列表数据</p><ul><li>语法： <code>&lt;li v-for=&quot;(item, index) of items&quot; :key=&quot;index&quot;&gt;</code>，这里 key 可以是 index ，更好的是遍历对象的唯一标识 可遍历：数组、对象、字符串（用的少）、指定次数（用的少）</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-comment">&lt;!-- 遍历数组 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>人员列表（遍历数组）<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(p,index) of persons&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span>&#123;&#123; p.name &#125;&#125;-&#123;&#123; p.age &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- 遍历对象 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>汽车信息（遍历对象）<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value,k) of car&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;k&quot;</span>&gt;</span>&#123;&#123; k &#125;&#125;-&#123;&#123; value &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- 遍历字符串 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>测试遍历字符串（用得少）<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(char,index) of str&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span>&#123;&#123; char &#125;&#125;-&#123;&#123; index &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- 遍历指定次数 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>测试遍历指定次数（用得少）<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(number,index) of 5&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span>&#123;&#123; index &#125;&#125;-&#123;&#123; number &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><br> data: &#123;<br>     persons: [<br>         &#123; id: &#x27;001&#x27;, name: &#x27;张三&#x27;, age: 18 &#125;,<br>         &#123; id: &#x27;002&#x27;, name: &#x27;李四&#x27;, age: 19 &#125;,<br>         &#123; id: &#x27;003&#x27;, name: &#x27;王五&#x27;, age: 20 &#125;<br>     ],<br>     car: &#123;<br>         name: &#x27;奥迪A8&#x27;,<br>         price: &#x27;70万&#x27;,<br>         color: &#x27;黑色&#x27;<br>     &#125;,<br>     str: &#x27;hello&#x27;<br> &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/markdown/image-20221013214237981.png" alt="image-20221013214237981"></p><h4 id="1-6-1-2-列表过滤"><a href="#1-6-1-2-列表过滤" class="headerlink" title="1.6.1.2 列表过滤"></a>1.6.1.2 列表过滤</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>人员列表<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入名字&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;keyWord&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(p,index) of filPersons&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;p.id&quot;</span>&gt;</span><br>             &#123;&#123; p.name &#125;&#125;-&#123;&#123; p.age &#125;&#125;-&#123;&#123; p.sex &#125;&#125;<br>         <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>data: &#123;<br>    keyWord: &#x27;&#x27;,<br>    persons: [<br>        &#123; id: &#x27;001&#x27;, name: &#x27;马冬梅&#x27;, age: 19, sex: &#x27;女&#x27; &#125;,<br>        &#123; id: &#x27;002&#x27;, name: &#x27;周冬雨&#x27;, age: 20, sex: &#x27;女&#x27; &#125;,<br>        &#123; id: &#x27;003&#x27;, name: &#x27;周杰伦&#x27;, age: 21, sex: &#x27;男&#x27; &#125;,<br>        &#123; id: &#x27;004&#x27;, name: &#x27;温兆伦&#x27;, age: 22, sex: &#x27;男&#x27; &#125;<br>    ],<br>    filPersons: []<br>    &#125;,<br>    watch: &#123;<br>        keyWord: &#123;<br>        immediate: true,<br>        handler(val) &#123;<br>        this.filPersons = this.persons.filter((p) =&gt; &#123;<br>        return p.name.indexOf(val) !== -1<br>        &#125;)<br>        &#125;<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="1-6-2-数据监视"><a href="#1-6-2-数据监视" class="headerlink" title="1.6.2 数据监视"></a>1.6.2 数据监视</h3><p>更新时的一个问题</p><p><code>this.persons[0] = &#123;id:&#39;001&#39;,name:&#39;马老师,age:50,sex:&#39;男&quot;&#125;</code>更改<code>data</code>数据，<code>Vue</code>不监听，模板不改变。</p><p>原理</p><ol><li><p><code>vue</code>会监视<code>data</code>中所有层次的数据</p></li><li><p>如何监测<code>对象</code>中的数据?<br>通过<code>setter</code>实现监视，且要在<code>new Vue()</code>时就传入要监测的数据</p><ul><li>对象<code>创建后</code>追加的属性，Vue 默认不做响应式处理</li><li>如需给后添加的属性做响应式，请使用如下API<ul><li>&#x3D;&#x3D;Vue. set(target, propertyName&#x2F; index, value)&#x3D;&#x3D;，即<code>Vue.set(对象,&#39;属性&#39;,&#39;属性值&#39;)</code></li><li>&#x3D;&#x3D;vm. $set(target , propertyName&#x2F; index,value )&#x3D;&#x3D;</li></ul></li></ul></li><li><p>如何监测<code>数组</code>中的数据?</p><p>通过包裹数组更新元素的方法实现，本质就是做了两件事</p><p>a. 调用原生对应的方法对数组进行更新，是对整个数组做改动，因为vue并不为数组中某一个元素单独生成getter，setter方法</p><p>b. 重新解析模板，进而更新页面</p></li><li><p>在<code>Vue</code>修改数组中的某个元素一定要用如下方法</p><ul><li>&#x3D;&#x3D;push()&#x3D;&#x3D;：该方法是在数组最后添加数据，并返回数组长度</li><li>&#x3D;&#x3D;pop()&#x3D;&#x3D;：删除最后一个元素，并返回删除的元素值</li><li>&#x3D;&#x3D;shift()&#x3D;&#x3D;：删除数组的第一个元素，返回第一个删除的值</li><li>&#x3D;&#x3D;unshift()&#x3D;&#x3D;：向数组开头添加元素，返回数组长度</li><li>&#x3D;&#x3D;reverse()&#x3D;&#x3D;：翻转数组</li><li>&#x3D;&#x3D;sort(function(a,b){return a-b})&#x3D;&#x3D;：数组排序升序&#x2F;b-a降序</li><li>&#x3D;&#x3D;splice(index,howmany,arr1,arr2…)&#x3D;&#x3D; ：用于添加或删除数组中的元素。从【index】位置开始删除howmany个元素，并将arr1、arr2…数据从index位置依次插入。howmany为0时，则不删除元素。</li></ul><blockquote><p>特别注意:<code> Vue.set()</code> 和<code>vm.$set()</code>.不能给<code>vm</code>或<code>vm</code>的根数据对象( <code>data</code>等)添加属性</p></blockquote></li></ol><h2 id="1-7-收集表单数据"><a href="#1-7-收集表单数据" class="headerlink" title="1.7 收集表单数据"></a>1.7 收集表单数据</h2><p>收集表单数据 </p><ul><li><p>若 <input type="text">，则<code>v-model</code>收集的是 <code>value</code> 值，用户输入的内容就是<code>value</code>值 </p></li><li><p>若 <input type="radio"> ，则<code> v-model</code> 收集的是<code>value</code>值，且要给标签配置 <code>value</code> 属性 </p></li><li><p>若 <input type="checkbox"></p><ul><li>没有配置<code>value</code>属性，那么收集的是<code>checked</code>属性（勾选 or 未勾选，是布尔值）</li><li>配置了 value 属性 </li><li><code>v-model </code>的初始值是<code>非数组</code>，那么收集的就是<code>checked</code>（勾选 or 未勾选，是布尔值）</li><li><code>v-model</code>的初始值是<code>数组</code>，那么收集的就是<code>value</code>组成的数组</li></ul></li></ul><p> v-model 的三个修饰符</p><ul><li><code>lazy </code>失去焦点后再收集数据</li><li><code>number </code>输入字符串转为有效的数字 </li><li><code>trim </code>输入首尾空格过滤</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">form</span> @<span class="hljs-attr">submit.prevent</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>     账号：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.trim</span>=<span class="hljs-string">&quot;userInfo.account&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>     密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;userInfo.password&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>     年龄：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">&quot;userInfo.age&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>     性别：<br>     男<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;userInfo.sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span><br>     女<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;userInfo.sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>     爱好：<br>     学习<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;userInfo.hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;study&quot;</span>&gt;</span><br>     打游戏<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;userInfo.hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;game&quot;</span>&gt;</span><br>     吃饭<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;userInfo.hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;eat&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>     所属校区<br>     <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;userInfo.city&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>请选择校区<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;beijing&quot;</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;shanghai&quot;</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;shenzhen&quot;</span>&gt;</span>深圳<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;wuhan&quot;</span>&gt;</span>成都<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>     其他信息：<br>     <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">&quot;userInfo.other&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;userInfo.agree&quot;</span>&gt;</span>阅读并接受<br>     <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.yuque.com/cessstudy&quot;</span>&gt;</span>《用户协议》<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"> <span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span></span><br><span class="language-javascript"> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">     <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#root&#x27;</span>,</span><br><span class="language-javascript">     <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">         <span class="hljs-attr">userInfo</span>: &#123;</span><br><span class="language-javascript">             <span class="hljs-attr">account</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">             <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">             <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,</span><br><span class="language-javascript">             <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;female&#x27;</span>,</span><br><span class="language-javascript">             <span class="hljs-attr">hobby</span>: [],</span><br><span class="language-javascript">             <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;beijing&#x27;</span>,</span><br><span class="language-javascript">             <span class="hljs-attr">other</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">             <span class="hljs-attr">agree</span>: <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript">         &#125;</span><br><span class="language-javascript">     &#125;,</span><br><span class="language-javascript">     <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">         <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">userInfo</span>))</span><br><span class="language-javascript">         &#125;</span><br><span class="language-javascript">     &#125;</span><br><span class="language-javascript"> &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="1-8-内置指令和自定义指令"><a href="#1-8-内置指令和自定义指令" class="headerlink" title="1.8 内置指令和自定义指令"></a>1.8 内置指令和自定义指令</h2><h3 id="1-8-1-内置指令"><a href="#1-8-1-内置指令" class="headerlink" title="1.8.1 内置指令"></a>1.8.1 内置指令</h3><p>前面提到过的指令：</p><ul><li><code>v- bind</code>       单向绑定解析表达式，可简写为<code>:</code></li><li><code>v-model</code>       双向数据绑定</li><li><code>v-for </code>           遍历数组&#x2F;对象&#x2F;字符串.</li><li><code>v-on   </code>             绑定事件监听，可简写为@</li><li><code>v-show</code>         条件渲染(动态控制节点是否展示)</li><li><code>v- if </code>           条件渲染(动态控制节点是否存存在)</li><li><code>v-else-if </code>   条件渲染 (动态控制节点是否存存在)</li><li><code>v-else </code>         条件渲染(动态控制节点是否存存在)</li></ul><h4 id="1-8-1-1-v-text"><a href="#1-8-1-1-v-text" class="headerlink" title="1.8.1.1 v-text"></a>1.8.1.1 v-text</h4><p>作用：向其所在的节点中渲染<code>文本内容</code>(不解析标签，全部当成文本)</p><p>与插值语法的区别：<code>v-text</code>会替换掉节点中的内容，<code>&#123;&#123;xxx&#125;&#125;</code> 则不会，更灵活</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>你好，&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>new Vue(&#123;<br>    el:&#x27;#root&#x27;,<br>    data:&#123;<br>        name:&#x27;cess&quot; ，<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="1-8-1-2-v-html"><a href="#1-8-1-2-v-html" class="headerlink" title="1.8.1.2 v-html"></a>1.8.1.2 v-html</h4><p>作用：向指定节点中渲染包含<code>html</code>结构的内容（解析标签）</p><p>与插值语法的区别:</p><ul><li><code>v-html</code> 会替换掉节点中所有的内容， <code>&#123;&#123;xxx&#125;&#125;</code> 则不会</li><li><code>v-html</code>可以识别<code>html</code>结构</li></ul><blockquote><p>严重注意v-html有安全性问题! !</p></blockquote><ul><li>在网站上动态渲染任意<code>html</code>是非常危险的，容易导致XSS攻击</li><li>一定要在可信的内容上使用<code>v-html</code> ，永远不要用在用户提交的内容上! ! !</li></ul><h4 id="1-8-1-3-v-clock"><a href="#1-8-1-3-v-clock" class="headerlink" title="1.8.1.3 v-clock"></a>1.8.1.3 v-clock</h4><ul><li>本质是一个特殊属性，<code>Vue</code>实例创建完毕并接管容器后，会删掉<code>v-cloak</code>属性</li><li>使用<code>css</code>配合<code>v-cloak</code> 可以解决网速慢时页面展示出<code>&#123;&#123;xxx&#125;&#125;</code>的问题</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>v-cloak指令<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">sty1e</span>&gt;</span><br>    //选中所有含有v-cloak属性的标签<br>    [v-cloak] &#123;<br>        display:none;<br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-cloak</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>//延迟5秒收到vue.js<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost: 8080/resource/5s/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>= <span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.1og(<span class="hljs-number">1</span>)</span><br><span class="language-javascript">    <span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span></span><br><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#root&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">data</span>:&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;cess&#x27;</span>&#125;</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-8-1-4-v-once"><a href="#1-8-1-4-v-once" class="headerlink" title="1.8.1.4 v-once"></a>1.8.1.4 v-once</h4><ul><li><code>v-once</code>所在节点在初次动态渲染后，就视为静态内容了</li><li>以后数据的改变不会引起起<code>v-once</code>所在结构的更新，可以用于优化性能</li></ul><h4 id="1-8-1-5-v-pre"><a href="#1-8-1-5-v-pre" class="headerlink" title="1.8.1.5 v-pre"></a>1.8.1.5 v-pre</h4><ul><li>跳过v-pre所在节点的编译过程</li><li>可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译</li></ul><h3 id="1-8-2-自定义指令"><a href="#1-8-2-自定义指令" class="headerlink" title="1.8.2 自定义指令"></a>1.8.2 自定义指令</h3><p><code>directives </code>，与methods同级</p><blockquote><p>指令定义时不加v-，但使用时要加v-</p><p>指令名如果是多个单词，要使用kebab -case命名方式，不要用camelCase命名</p></blockquote><h4 id="1-8-2-1-函数式"><a href="#1-8-2-1-函数式" class="headerlink" title="1.8.2.1 函数式"></a>1.8.2.1 函数式</h4><p>需求1：定义一个v-big指令， 和v-text功能类似，但会把绑定的数值放大10倍。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>放大10倍后的n值是: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-big</span>=<span class="hljs-string">&quot;n&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;n++&quot;</span>&gt;</span>点我n+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br>directives: &#123;<br>    // big函数何时会被调用?<br>    // 1.指令与元素成功绑定时(一上来) 2.指令所在的模板被重新解析时<br>    big(element, binding) &#123;<br>        element.innerText = binding.value * 10<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-8-2-2-对象式"><a href="#1-8-2-2-对象式" class="headerlink" title="1.8.2.2 对象式"></a>1.8.2.2 对象式</h4><p>需求2：定义一个v- Fbind指令，和v bind功能拳似，但可以让:其所绑定的input元素默认获取焦点。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text” v-fbind:value=&quot;</span><span class="hljs-attr">n</span>&quot;&gt;</span> <br>                                    <br>directives: &#123;<br>    fbind:&#123;<br>        //指令与元素成功绑定时(上来)<br>        bind(element,binding)&#123;<br>           element.innerText = binding.value<br>        &#125;,<br>        //指令所在元素被插入页面时                          <br>        inserted(element,binding)&#123;<br>           element.focus()                     <br>        &#125;,<br>        //指令所在的模板被重新解析时                           <br>        update(element,binding)&#123;<br>           element.innerText = binding.value                        <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、Vue-Cli"><a href="#二、Vue-Cli" class="headerlink" title="二、Vue-Cli"></a>二、Vue-Cli</h1><h2 id="2-1-初始化脚手架"><a href="#2-1-初始化脚手架" class="headerlink" title="2.1 初始化脚手架"></a>2.1 初始化脚手架</h2><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/markdown/image-20221016130824024.png" alt="image-20221016130824024"></p><h2 id="2-2-ref-props-mixin-plugin-scoped"><a href="#2-2-ref-props-mixin-plugin-scoped" class="headerlink" title="2.2 ref props mixin plugin scoped"></a>2.2 ref props mixin plugin scoped</h2><h3 id="2-2-1-ref属性"><a href="#2-2-1-ref属性" class="headerlink" title="2.2.1 ref属性"></a>2.2.1 ref属性</h3><p><code>ref</code>被用来给元素或子组件注册引|用信息(id的替代者)</p><ul><li>应用在html 标签上获取的是真实DOM元素，应用在组件标签上获取的是组件实例对象vc</li><li>使用方式<ul><li>打标识：<code>&lt;h1 ref=&quot;xx&quot;&gt;&lt;/h1&gt;</code>或<code>&lt;School ref=&quot;xxx&quot; &gt;&lt;/School&gt;</code></li><li>获取：<code> this.$refs.xxx</code></li></ul></li></ul><h3 id="2-2-2-props配置项"><a href="#2-2-2-props配置项" class="headerlink" title="2.2.2 props配置项"></a>2.2.2 props配置项</h3><p><code>props</code>让组件接收外部传过来的数据，更适用于<code>父传子</code>。与methods同级</p><ul><li><p>传递数据<code>&lt;Demo name=&quot;xx” :age=&quot;18&quot;/&gt;</code> 这里age前加<code>:</code>,通过v-bind使得里面的18是数字</p></li><li><p>接收数据</p><p>第一种方式(只接收)        <code>props:[&#39;name&#39;,&#39; age&#39;]</code></p><p>第二种方式(限制类型)    <code> props:&#123;name:String,age:Number&#125;</code></p><p>第三种方式(限制类型、限制必要性、指定默认值)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">name</span>: &#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<span class="hljs-comment">//类型</span><br>        <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,<span class="hljs-comment">// 必要性</span><br>        <span class="hljs-attr">default</span>: <span class="hljs-string">&#x27;cess&#x27;</span><span class="hljs-comment">//默认值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>tip: props是<code>只读</code>的，Vue底层会监测你对props 的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props 的内容到data中，然后去修改data中的数据。</p></blockquote><p>父<code>src/App.vue</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Student</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;李四” sex=&quot;</span><span class="hljs-attr">女</span>”<span class="hljs-attr">:age</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Student</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;王五” sex=&quot;</span><span class="hljs-attr">男</span>” <span class="hljs-attr">:age</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    import Student from &#x27; ./ components/Student’<br>    export default &#123;<br>        name:&#x27;App&#x27;,<br>        components:&#123; Student &#125;<br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>子<code>src/components/Student.vue</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学生姓名: &#123;&#123; name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学生性别: &#123;&#123; sex &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学生年龄: &#123;&#123; myAge + 1 &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;updateAge&quot;</span>&gt;</span>尝 试修改收到的年龄<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>//接收的同时对数据:进行类型限制+默认值的指定+必要性的限制<br>props:&#123;<br>    name:&#123;<br>        type: string，//name的类型 是字符串<br>        required: true //name是必要的<br>    &#125;,<br>    age:&#123;<br>        type:Number,<br>        default:99//默认值<br>    &#125;,<br>    sex:&#123;<br>        type:String,<br>        required:true<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-3-mixin混入"><a href="#2-2-3-mixin混入" class="headerlink" title="2.2.3 mixin混入"></a>2.2.3 mixin混入</h3><ul><li><p>功能：可以把多个组件共用的配置提取成一个混入对象，与data同级</p></li><li><p>使用方式</p><ul><li>定义混入<code>src/mixin.js</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> hunhe = &#123;<br>    <span class="hljs-attr">methods</span>:&#123;<br>        <span class="hljs-title function_">showName</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> )<br>        &#125;<br>    &#125;,<br>    <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.1og(<span class="hljs-string">&#x27;你好啊! &#x27;</span>)<br>    &#125;,<br> &#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> hunhe2 = &#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">x</span>:<span class="hljs-number">100</span>,<br>            <span class="hljs-attr">y</span>:<span class="hljs-number">200</span><br>        &#125;<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用混入</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showName&quot;</span>&gt;</span> 学校名称: &#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//引入一个hunhe</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123;hunhe , hunhe2&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../mixin&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;School&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">mixins</span>: [hunhe, hunhe2] <span class="hljs-comment">//局部混入</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-2-4-plugin插件"><a href="#2-2-4-plugin插件" class="headerlink" title="2.2.4 plugin插件"></a>2.2.4 plugin插件</h3><ul><li><p>功能：增强Vue</p></li><li><p>本质：包含install 方法的一个对象，install 的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据</p></li><li><p>定义插件<code>src/plugin.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-title function_">install</span>(<span class="hljs-params">Vue,x,y,z</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.1og(x,Y,z)<br>        <span class="hljs-comment">//全局过滤器</span><br>        <span class="hljs-title class_">Vue</span>. <span class="hljs-title function_">filter</span>(<span class="hljs-string">&#x27;mySlice&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<span class="hljs-keyword">return</span> value. <span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,<span class="hljs-number">4</span>)&#125;)<br>        <br>        <span class="hljs-comment">//定义全局指令</span><br>        <span class="hljs-title class_">Vue</span>. <span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;fbind&#x27;</span>,&#123;<br>            <span class="hljs-comment">//指令与元素成功绑定时(一上来)</span><br>            <span class="hljs-title function_">bind</span>(<span class="hljs-params">element,binding</span>)&#123;element.<span class="hljs-property">value</span> = binding.<span class="hljs-property">value</span>&#125;,<br>            <span class="hljs-comment">//指令所在元素被插入页面时</span><br>            <span class="hljs-title function_">inserted</span>(<span class="hljs-params">element,binding</span>)&#123;element.<span class="hljs-title function_">focus</span>()&#125;,<br>            <span class="hljs-comment">//指令所在的模板被重新解析时</span><br>            <span class="hljs-title function_">update</span>(<span class="hljs-params">element,binding</span>)&#123;element.<span class="hljs-property">value</span> = binding.<span class="hljs-property">value</span>&#125;<br>        &#125;)<br>        <span class="hljs-comment">//定义混入</span><br>        <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>(&#123;<br>            <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">100</span>,<span class="hljs-attr">y</span>:<span class="hljs-number">200</span>&#125;&#125;,<br>        &#125;)<br>        <span class="hljs-comment">//给Vue原型_上添加一个方法(vm和vc就都能用了)</span><br>         <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hello</span> = <span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27; 你好啊&#x27;</span>)&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用插件：<code>Vue.use() </code>   <code> src/main.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> plugins <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;/plugins&#x27;</span> <span class="hljs-comment">// 引入插件</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(plugins,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) <span class="hljs-comment">//应用(使用)插件</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>:<span class="hljs-string">&quot;#app&quot;</span>,<br>    <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p><code>src/ components/ School. vue</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学校名称: &#123;&#123; name | mySlice &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学校地址: &#123;&#123; address &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">c1ick</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>点我测试一个he11o方法<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    export default &#123;<br>        name:&#x27;School&#x27;,<br>        data() &#123;<br>            return &#123;<br>                name:&#x27;尚硅谷atguigu&#x27;,<br>                address:&quot;北京&#x27;,<br>            &#125;<br>        &#125;,   <br>        methods: &#123;<br>            test()&#123;<br>                this. hello()<br>            &#125;<br>        &#125;<br>    &#125;，<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-2-5-scoped样式"><a href="#2-2-5-scoped样式" class="headerlink" title="2.2.5 scoped样式"></a>2.2.5 scoped样式</h3><ul><li>作用:让样式在局部生效，防止冲突</li><li>写法：<code>&lt;style scoped&gt;</code></li></ul><h2 id="2-3-本地存储-自定义事件"><a href="#2-3-本地存储-自定义事件" class="headerlink" title="2.3 本地存储 自定义事件"></a>2.3 本地存储 自定义事件</h2><h3 id="2-3-1-本地存储"><a href="#2-3-1-本地存储" class="headerlink" title="2.3.1 本地存储"></a>2.3.1 本地存储</h3><p>存储内容大小一般支持5MB左右(不同浏览器可能还不一样)</p><p>浏览器端通过<code>Window. sessionStorage</code>和<code>Window. localStorage</code>属性来实现本地存储机制<br>相关API</p><ul><li><code>xxxStorage. setItem( &#39;key&#39;, &#39;value&#39; )</code>该访法接受一个键和值作为参数, 会把键值对添加到存储中,<br>如果键名存在，则更新其对应的值</li><li><code>xxxStorage. getItem( &#39;key&#39;)</code>该访法接受一个键名作为参数, 返回键名对应的值</li><li><code>xxxStorage. removeItem( &#39;key&#39; )</code>该访法接受一个键名作为参数, 并把该键名从存储中删除</li><li><code>xxxStorage.clear()</code>该访法会清空存储中的所有数据</li></ul><blockquote><p>SessionStorage 存储的内容会随着浏览器窗口关闭而消失</p><p>LocalStorage 存储的内容,需要手动清除才会消失</p><p>xxxStorage. getItem(xxx) 如果xxx对应的value获取不到，那么getItem() 的返回值是null</p><p>JSON. parse(null)的结果依然是null</p></blockquote><h3 id="2-3-2-自定义事件"><a href="#2-3-2-自定义事件" class="headerlink" title="2.3.2 自定义事件"></a>2.3.2 自定义事件</h3><ul><li><p>一种<code>组件间</code>通信的方式，适用于<code>子传父</code></p></li><li><p>使用场景：子组件想给父组件传数据，那么就要在父组件中给子组件绑定自定义事件(事件的回调在父组件中)</p></li><li><p>绑定自定义事件</p><ul><li><p>第一种方式，在父组件中<code>&lt;Demo @事件名=&quot;方法&quot;/&gt;</code>或<code>&lt;Demo v-on:事件名=&quot;方法&quot;/&gt;</code></p><p>在<code>src/App.vue</code>父组件中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Student</span> @<span class="hljs-attr">atguigu</span>=<span class="hljs-string">&quot;demo&quot;</span>/&gt;</span><br><br>methods: &#123;<br>    demo(name)&#123;<br>        console.log(&#x27;demo被调用了!&#x27;,name)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>src/components/Student.vue</code>子组件中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sendStudentName”&gt; 把学生名给App &lt;/button&gt;</span></span><br><span class="hljs-string"><span class="hljs-tag"></span></span><br><span class="hljs-string"><span class="hljs-tag">methods:&#123;</span></span><br><span class="hljs-string"><span class="hljs-tag">    sendStudentName()&#123;</span></span><br><span class="hljs-string"><span class="hljs-tag">        //触发Student组件实例身上的atguigu事件</span></span><br><span class="hljs-string"><span class="hljs-tag">        this.$emit(&#x27;atguigu&#x27;,this.name)</span></span><br><span class="hljs-string"><span class="hljs-tag">    &#125;</span></span><br><span class="hljs-string"><span class="hljs-tag">&#125;</span></span><br></code></pre></td></tr></table></figure></li><li><p>第二种方式，在父组件中绑定自定义事件<code>this.$refs.demo.$on(&#39;事件名&#39;,方法)</code></p><p>在<code>src/App.vue</code>父组件中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Student</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;student&quot;</span>/&gt;</span><br><br>methods: &#123;<br>    demo(name)&#123;<br>        console.log(&#x27;demo被调用了!&#x27;,name)<br>    &#125;<br>&#125;,<br>mounted()&#123;<br>    this.$refs.student.$on(&#x27;atguigu&#x27;,this.demo)<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>src/components/Student.vue</code>子组件中触发自定义事件<code>this.$emit(&#39;事件名&#39;,数据)</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sendStudentName”&gt; 把学生名给App &lt;/button&gt;</span></span><br><span class="hljs-string"><span class="hljs-tag"></span></span><br><span class="hljs-string"><span class="hljs-tag">methods:&#123;</span></span><br><span class="hljs-string"><span class="hljs-tag">    sendStudentName()&#123;</span></span><br><span class="hljs-string"><span class="hljs-tag">        //触发Student组件实例身上的atguigu事件</span></span><br><span class="hljs-string"><span class="hljs-tag">        this.$emit(&#x27;atguigu&#x27;,this.name)</span></span><br><span class="hljs-string"><span class="hljs-tag">    &#125;</span></span><br><span class="hljs-string"><span class="hljs-tag">&#125;</span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>解绑自定义事件<code>this.$off(&#39;事件名&#39;)</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>= <span class="hljs-string">&quot;unbind&quot;</span>&gt;</span> 解绑atguigu事件 <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br>mounted()&#123;<br>    unbind()&#123;<br>        this.$off(&#x27;atguigu&#x27;)         //解绑多个自定义事件<br>        this.$off([&#x27;atguigu&#x27;,demo&#x27;]) //解绑多个自定义事件<br>        this.$off()                  //解绑所有自定义事件<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>组件也可以绑定原生<code>DOM</code>事件，需要使用<code>native </code>修饰符<code>@click.native=&quot;show&quot;</code>，上面绑定自定义事件，即使绑定的是原生事件也会被认为是自定义的，需</p><p>要加<code>native</code> ，加了后就将此事件给组件的根元素</p><p>在<code>src/App.vue</code>组件中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Student</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;student&quot;</span>  @<span class="hljs-attr">click.native</span>=<span class="hljs-string">&quot;show&quot;</span>/&gt;</span><br><br>methods:&#123;<br>    show()&#123;<br>        alert(123)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>注意：通过<code>this.$refs.xxx.$on( &#39;事件名&#39;,回调函数)</code>绑定自定义事件时，回调函数要么配置在<code>methods</code>中，要么用箭头函数，否则<code>this</code>指向会出问题</p><blockquote><p>因为默认该回调函数中的this是触发事件的vue实例，写在methods中的this一定是当前实例，后者优先级更高</p></blockquote></li></ul><h2 id="2-4-全局事件总线-消息的订阅与发布"><a href="#2-4-全局事件总线-消息的订阅与发布" class="headerlink" title="2.4 全局事件总线 消息的订阅与发布"></a>2.4 全局事件总线 消息的订阅与发布</h2><h3 id="2-4-1-全局事件总线"><a href="#2-4-1-全局事件总线" class="headerlink" title="2.4.1 全局事件总线"></a>2.4.1 全局事件总线</h3><p>一种可以在<code>任意组件间</code>通信的方式，本质上就是一个对象， 它必须满足以下条件</p><ul><li>所有的组件对象都必须能看见他</li><li>这个对象必须能够使用<code>$on</code>  <code>$emit</code>  <code>$off</code> 方法去绑定、触发和解绑事件</li></ul><p>使用步骤</p><ul><li>定义全局事件总线</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//创建周转实例$bus</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,<br>    <span class="hljs-attr">render</span>:<span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br>    <span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$bus</span> = <span class="hljs-variable language_">this</span>  <span class="hljs-comment">//安装全局事件总线,$bus就是当前应用的vm</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li><p>使用事件总线</p><ul><li>接收数据：A组件想接收数据，则在A组件中给<code>$bus</code>绑定自定义事件，事件的回调留在A组件自身</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$on(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">data</span>)=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&#x27;我是School组件,收到了数据&#x27;</span>,data)<br>    &#125;)<br>&#125;,<br><span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$off(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>传递数据，另一组件提供数据，<code>this.$bus.$emit(&#39;xxx&#39;, data)</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//另一组件触发</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$emit(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-4-2-消息的订阅与发布"><a href="#2-4-2-消息的订阅与发布" class="headerlink" title="2.4.2 消息的订阅与发布"></a>2.4.2 消息的订阅与发布</h3><p>消息订阅与发布(pubsub) 消息订阅与发布是一种组件间通信的方式，适用于<code>任意组件间</code>通信</p><p>使用步骤</p><ul><li>安装pubsub：<code>npm i pubsub-js</code></li><li>引入：<code>import pubsub from &#39;pubsub-js&#39;</code></li><li>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的回调留在A组件自身</li><li>提供数据: pubsub. publish( ‘xxx’, data)</li><li>最好在beforeDestroy 钩子中，使用pubsub . unsubscribe(pid)取消订阅</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!--发布方和接收方都需要引入--&gt;<br><span class="hljs-keyword">import</span> pubsub <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pubsub-js&#x27;</span><br><br>&lt;!--接收方想接收数据，则订阅消息，且订阅的回调留在本身--&gt;<br><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>)&#123; <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pubId</span> = pubsub.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">masgName,data</span>)=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;有人发布了hello消息,hello消息的回调执行了&#x27;</span>,mesgName,data)<br>    &#125;)<br>&#125;,<br>    <br><span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>) &#123;<br>    pubsub.<span class="hljs-title function_">unsubscribe</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">pubId</span>)<br>&#125;<br><br><br>&lt;!--传数据的一端发布消息--&gt;<br>pubsub.<span class="hljs-title function_">publish</span>(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-number">666</span>)<br><br><span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">send</span>(<span class="hljs-params"></span>)&#123;<br>        pubsub.<span class="hljs-title function_">publish</span>(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-number">666</span>) <span class="hljs-comment">//发布消息</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-5-nextTick-过渡与动画"><a href="#2-5-nextTick-过渡与动画" class="headerlink" title="2.5 $nextTick 过渡与动画"></a>2.5 $nextTick 过渡与动画</h2><h3 id="2-5-1-nextTic"><a href="#2-5-1-nextTic" class="headerlink" title="2.5.1 $nextTic"></a>2.5.1 $nextTic</h3><p><strong>这是一个生命周期钩子</strong></p><p><code>this.$nextTick(回调函数)</code>在下一次<code>DOM</code>更新结束后执行其指定的回调</p><p>什么时候用：当改变数据后，要基于更新后的新<code>DOM</code>进行某些操作时，要在<code>nextTick</code>所指定的回调函数中执行</p><h3 id="2-5-2-过渡与动画"><a href="#2-5-2-过渡与动画" class="headerlink" title="2.5.2 过渡与动画"></a>2.5.2 过渡与动画</h3><p><code>Vue</code>封装的过度与动画：在插入、更新或移除<code>DOM</code>元素时，在合适的时候给元素添加样式类名</p><ul><li>准备好样式，按vue规定的格式来<ul><li>元素进入的样式<ul><li><code>v-enter</code>                     进入的终点</li><li><code>v-enter-active</code>       进入过程中</li><li><code>v-enter-to</code>               进入的终点</li></ul></li><li>元素离开的样式<ul><li><code>v-leave</code>                     离开的终点</li><li><code>v-leave-active</code>       离开过程中</li><li><code>v-leave-to</code>               离开的终点</li></ul></li></ul></li><li>使用<code>&lt;transition&gt;</code> 包裹要过度的元素。可以配置<code>name</code>属性，但配置以后需要将上面样式名默认的<code>v</code>换为<code>name</code>中的属性值</li><li>要页面一开始就显示动画，需要添加<code>appear</code></li><li>若有多个元素需要过度,则需要使用<code>&lt;transition-group&gt;</code>，且每个元素都要指定key 值</li></ul><p>原生写法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">h1</span> v-show=&quot;isShow&quot; class=&quot;come&quot;&gt;你好啊! &lt;/<span class="hljs-selector-tag">h1</span>&gt;<br><br>&lt;style&gt;<br>    <span class="hljs-selector-class">.come</span>&#123;<br>        <span class="hljs-attribute">animation</span>: hello <span class="hljs-number">0.5s</span> linear;<br>    &#125;<br>    <span class="hljs-selector-class">.go</span>&#123;<br>        <span class="hljs-attribute">animation</span>: hello <span class="hljs-number">0.5s</span> linear reverse;//reverse反转<br>    &#125;<br><br>    <span class="hljs-keyword">@keyframes</span> hello &#123;<br>        <span class="hljs-selector-tag">from</span>&#123;<br>            <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">100%</span>);<br>        &#125;<br>        <span class="hljs-selector-tag">to</span>&#123;<br>            <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0px</span>);<br>        &#125;<br>    &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>Vue封装写法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-attribute">transition</span>&gt;<br>    &lt;<span class="hljs-selector-tag">h1</span> v-show=&quot;isShow&quot;&gt;你好啊!&lt;/<span class="hljs-selector-tag">h1</span>&gt;<br>&lt;/<span class="hljs-attribute">transition</span>&gt;<br><br>&lt;style&gt;<br>    <span class="hljs-selector-class">.v-enter-active</span>&#123;<br>        <span class="hljs-attribute">animation</span>: hello <span class="hljs-number">0.5s</span> linear;<br>    &#125;<br>    <span class="hljs-selector-class">.v-leave-active</span>&#123;<br>        <span class="hljs-attribute">animation</span>: hello <span class="hljs-number">0.5s</span> linear reverse;//reverse反转<br>    &#125;<br><br>    <span class="hljs-keyword">@keyframes</span> hello &#123;<br>        <span class="hljs-selector-tag">from</span>&#123;<br>            <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">100%</span>);<br>        &#125;<br>        <span class="hljs-selector-tag">to</span>&#123;<br>            <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0px</span>);<br>        &#125;<br>    &#125;<br>&lt;/style&gt;<br><br>//若有多个元素需要过渡<br>&lt;<span class="hljs-attribute">transition</span>-group name=&quot;hello&quot; appear&gt;<br>    &lt;<span class="hljs-selector-tag">h1</span> v-show=&quot;!isShow&quot; key=&quot;<span class="hljs-number">1</span>&quot;&gt;你好啊! &lt;/<span class="hljs-selector-tag">h1</span>&gt;<br>    &lt;<span class="hljs-selector-tag">h1</span> v-show=&quot;isShow&quot;  key-&quot;<span class="hljs-number">2</span>&quot;&gt;尚硅谷! &lt;/<span class="hljs-selector-tag">h1</span>&gt;<br>&lt;/<span class="hljs-attribute">transition</span>-group&gt;<br></code></pre></td></tr></table></figure><h3 id="2-5-3-集成第三方动画库Animate-css"><a href="#2-5-3-集成第三方动画库Animate-css" class="headerlink" title="2.5.3 集成第三方动画库Animate.css"></a>2.5.3 集成第三方动画库Animate.css</h3><ul><li>安装<code>npe install anlnate.css</code></li><li>引入<code>import &#39;animate.css&#39;</code></li><li>修改<code>transition</code>或者<code>transition-group</code>的name值</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-attribute">transition</span>-group appear<br>        name=&quot;animate_animated animate_bounce&quot;<br>        enter-active-class=&quot;animate_swing&quot;     //从官网选择进入的动画<br>        leave-active-class=&quot;animate_back0utUp&quot;&gt;//从官网选择离开的动画<br>&lt;<span class="hljs-selector-tag">h1</span> v-show=&quot;!isShow&quot; key=&quot;<span class="hljs-number">1</span>&quot;&gt;你好啊!&lt;/<span class="hljs-selector-tag">h1</span>&gt;<br>&lt;<span class="hljs-selector-tag">h1</span> v-show=&quot;isShow” key=&quot;<span class="hljs-number">2</span>&quot;&gt;尚硅谷!&lt;/<span class="hljs-selector-tag">h1</span>&gt;<br>&lt;/<span class="hljs-attribute">transition</span>-group&gt;<br></code></pre></td></tr></table></figure><h2 id="2-6-Ajax配置代理-slot插槽"><a href="#2-6-Ajax配置代理-slot插槽" class="headerlink" title="2.6 Ajax配置代理 slot插槽"></a>2.6 Ajax配置代理 slot插槽</h2><p>ajax就是基于浏览器提供的XMLHttpRequest对象来实现异步的 JavaScript 和 XML。</p><p>发送请求的方式：1.xhr（XMLHttpRequest实例） 2.jQuery <code>3.axios</code> 4.fetch</p><p>跨域是浏览器的同源策略引起的，在发送请求时引起。</p><h3 id="2-6-1-Ajax配置代理"><a href="#2-6-1-Ajax配置代理" class="headerlink" title="2.6.1 Ajax配置代理"></a>2.6.1 Ajax配置代理</h3><p>跨域问题解决方法有多种，可以前端解决也可以后端解决。比如CORS（后端处理），jsonp(前后端都要处理，用的少)，配置代理服务器(前端处理)</p><p>配置代理服务器:</p><p>方法一：优先匹配前端资源（不能配置多个代理）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//在vue.config.js中添加，开启代理服务器，端口号为前端要转发给的服务器端口号  </span><br><span class="hljs-attr">devServer</span>: &#123;<br>  <span class="hljs-attr">proxy</span>: <span class="hljs-string">&#x27;http://localhost:5000&#x27;</span><br>&#125;<br><br><br>axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://localhost:8080/students&#x27;</span>).<span class="hljs-title function_">then</span>(<br><span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求成功了&#x27;</span>,response.<span class="hljs-property">data</span>);<br>&#125;,<br><span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求失败了&#x27;</span>,error.<span class="hljs-property">message</span>);<br>&#125;       <br>)<br></code></pre></td></tr></table></figure><p>方法二：可以编写多个代理，并且严格控制请求资源走服务器还是前端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//在vue.config.js中添加</span><br><span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;                            <span class="hljs-comment">//匹配所有以/api开头的请求路径</span><br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:5000&#x27;</span>,   <span class="hljs-comment">//代理目标的基础路径</span><br>        <span class="hljs-attr">pathRewrite</span>: &#123; <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27; &#x27;</span> &#125;,<br>        <span class="hljs-attr">ws</span>: <span class="hljs-literal">true</span>,<span class="hljs-comment">//用于支持websocket</span><br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span><span class="hljs-comment">//用于控制请求头中的host值</span><br>      &#125;,<br>      <span class="hljs-string">&#x27;/demo&#x27;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:5001&#x27;</span>,<br>        <span class="hljs-attr">pathRewrite</span>: &#123; <span class="hljs-string">&#x27;^/demo&#x27;</span>: <span class="hljs-string">&#x27; &#x27;</span> &#125;,<br>        <span class="hljs-attr">ws</span>: <span class="hljs-literal">true</span>,<span class="hljs-comment">//用于支持websocket</span><br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span><span class="hljs-comment">//用于控制请求头中的host值，默认为true</span><br>      &#125;,<br>    &#125;<br>     <br><br><span class="hljs-title function_">getStudents</span>(<span class="hljs-params"></span>)&#123;<br>     axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://localhost:8080/api/students&#x27;</span>).<span class="hljs-title function_">then</span>(<br>        <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span>&#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求成功了&#x27;</span>,response.<span class="hljs-property">data</span>);<br>        &#125;,<br>        <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span>&#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求失败了&#x27;</span>,error.<span class="hljs-property">message</span>);<br>        &#125;       <br>      )<br>    &#125;,<br>    <span class="hljs-title function_">getCars</span>(<span class="hljs-params"></span>)&#123;<br>      axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://localhost:8080/demo/cars&#x27;</span>).<span class="hljs-title function_">then</span>(<br>        <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求成功了&#x27;</span>, response.<span class="hljs-property">data</span>);<br>        &#125;,<br>        <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求失败了&#x27;</span>, error.<span class="hljs-property">message</span>);<br>        &#125;<br>      )<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2-6-2-slot插槽"><a href="#2-6-2-slot插槽" class="headerlink" title="2.6.2 slot插槽"></a>2.6.2 slot插槽</h3><p>作用：让父组件可以向子组件指定位置插入<code>html</code>结构，也是一种组件间通信的方式，适用于为子组件传递一些模板片段。数据既可以是父中的，也可以是子中的。<strong>父组件&#x3D;&#x3D;&#x3D;&gt;子组件模板片段</strong>。</p><p>分类：默认插槽、具名插槽、作用域插槽。</p><p><code>&lt;slot&gt;</code> 元素是一个<strong>插槽出口</strong> (slot outlet)，标示了父元素提供的<strong>插槽内容</strong> (slot content) 将在哪里被渲染。</p><p>使用方式：</p><h4 id="a-默认插槽"><a href="#a-默认插槽" class="headerlink" title="a. 默认插槽"></a><strong>a. 默认插槽</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">//子组件Category中<br>&lt;h3&gt;&#123;&#123;title&#125;&#125;分类&lt;/h3&gt;<br>&lt;slot&gt;&lt;/slot&gt;<br><br>//父组件中<br>&lt;Category title=&quot;美食&quot;&gt;<br>  &lt;img src=&quot;https://s3.ax1x.com/2021/01/16/srJlq0.jpg&quot; alt=&quot;&quot;&gt;<br>&lt;/Category&gt;<br>&lt;Category title=&quot;游戏&quot;&gt;<br>  &lt;ul v-show=&quot;title!==&#x27;美食&#x27;&quot;&gt;<br>    &lt;li v-for=&quot;(item,index) in games&quot; :key=&quot;index&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;<br>  &lt;/ul&gt;<br>&lt;/Category&gt;<br>&lt;Category title=&quot;电影&quot;&gt;<br>  &lt;video controls src=&quot;http://clips.vorwaerts-gmbh.de/big_ buck_ bunny.mp4&quot;&gt;&lt;/video&gt;<br>&lt;/Category&gt;<br></code></pre></td></tr></table></figure><h4 id="b-具名插槽"><a href="#b-具名插槽" class="headerlink" title="b. 具名插槽"></a><strong>b. 具名插槽</strong></h4><p><code>v-slot:</code> 有对应的简写 <code>#</code>，因此 <code>&lt;template v-slot:header&gt;</code> 可以简写为 <code>&lt;template #header&gt;</code>。其意思就是“将这部分模板片段传入子组件的 header 插槽中”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs vue">//子组件&lt;BaseLayout&gt;中定义一个插槽(挖个坑，等着组件的使用者进行填充)<br>&lt;div class=&quot;container&quot;&gt;<br>  &lt;header&gt;<br>    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;<br>  &lt;/header&gt;<br>  &lt;main&gt;<br>    &lt;slot&gt;&lt;/slot&gt;<br>  &lt;/main&gt;<br>  &lt;footer&gt;<br>    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;<br>  &lt;/footer&gt;<br>&lt;/div&gt; <br>                                                   <br>//父组件中<br>&lt;BaseLayout&gt;<br>  &lt;template #header&gt;<br>    &lt;h1&gt;Here might be a page title&lt;/h1&gt;<br>  &lt;/template&gt;<br><br>  &lt;!-- 隐式的默认插槽 --&gt;<br>  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;<br>  &lt;p&gt;And another one.&lt;/p&gt;<br><br>  &lt;template #footer&gt;<br>    &lt;p&gt;Here&#x27;s some contact info&lt;/p&gt;<br>  &lt;/template&gt;<br>&lt;/BaseLayout&gt;<br></code></pre></td></tr></table></figure><h4 id="c-作用域插槽"><a href="#c-作用域插槽" class="headerlink" title="c. 作用域插槽"></a><strong>c. 作用域插槽</strong></h4><blockquote><p>由于父组件模板中的表达式只能访问父组件的作用域；子组件模板中的表达式只能访问子组件的作用域。</p><p>然而在某些场景下插槽的内容可能想要同时使用父组件域内和子组件域内的数据。需要一种方法来让子组件在渲染时将一部分数据提供插槽。</p></blockquote><h5 id="默认作用域插槽"><a href="#默认作用域插槽" class="headerlink" title="默认作用域插槽"></a>默认作用域插槽</h5><p>可以像对组件传递 props 那样，向一个插槽的出口上传递 attributes。通过子组件标签上的 <code>v-slot</code> 指令，直接接收到了一个插槽 props 对象。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--子组件&lt;MyComponent&gt; 的模板 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">:text</span>=<span class="hljs-string">&quot;greetingMessage&quot;</span> <span class="hljs-attr">:count</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 父组件中调用 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">&quot;slotProps&quot;</span>&gt;</span><br>  &#123;&#123; slotProps.text &#125;&#125; &#123;&#123; slotProps.count &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">MyComponent</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://cn.vuejs.org/assets/scoped-slots.1c6d5876.svg" alt="scoped slots diagram"></p><h5 id="具名作用域插槽"><a href="#具名作用域插槽" class="headerlink" title="具名作用域插槽"></a>具名作用域插槽</h5><p>向具名插槽中传入 props，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--子组件中 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;header&quot;</span> <span class="hljs-attr">message</span>=<span class="hljs-string">&quot;hello&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;footer&quot;</span> <span class="hljs-attr">message</span>=<span class="hljs-string">&quot;你好&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;MyComponent&gt;<br>  &lt;template #header=&quot;headerProps&quot;&gt;<br>    &#123;&#123; headerProps &#125;&#125;<br>  &lt;/template&gt;<br><br>  &lt;template #default=&quot;defaultProps&quot;&gt;<br>    &#123;&#123; defaultProps &#125;&#125;<br>  &lt;/template&gt;<br><br>  &lt;template #footer=&quot;footerProps&quot;&gt;<br>    &#123;&#123; footerProps &#125;&#125;<br>  &lt;/template&gt;<br>&lt;/MyComponent&gt;<br></code></pre></td></tr></table></figure><h1 id="三、Vue-UI-组件库"><a href="#三、Vue-UI-组件库" class="headerlink" title="三、Vue UI 组件库"></a>三、Vue UI 组件库</h1><h2 id="3-1-常用UI组件库-1-移动端常用UI组件库"><a href="#3-1-常用UI组件库-1-移动端常用UI组件库" class="headerlink" title="3.1 常用UI组件库.1 移动端常用UI组件库"></a>3.1 常用UI组件库.1 移动端常用UI组件库</h2><ol><li><a href="https://vant-ui.github.io/vant/#/zh-CN">Vant</a></li><li><a href="https://didi.github.io/cube-ui/#/zh-CN">Cube UI</a></li><li><a href="http://mint-ui.github.io/#!/zh-cn">Mint UI</a></li><li><a href="http://mint-ui.github.io/#!/zh-cn">http://mint-ui.github.io/#!/zh-cn</a></li></ol><h3 id="3-1-2-PC端常用U组件库"><a href="#3-1-2-PC端常用U组件库" class="headerlink" title="3.1.2 PC端常用U组件库"></a>3.1.2 PC端常用U组件库</h3><ol><li><a href="https://element.eleme.cn/#/zh-CN">Element UI</a></li><li><a href="https://www.iviewui.com/">IView UI</a></li></ol><h2 id="3-2-element-ui基本使用"><a href="#3-2-element-ui基本使用" class="headerlink" title="3.2 element-ui基本使用"></a>3.2 element-ui基本使用</h2><ol><li><p>安装<code>element-ui</code>：<code>npm i element-ui -S</code></p></li><li><p>完整引入</p><p><code>src/main.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ElementUI</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span>;<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">ElementUI</span>);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>)<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>按需引入</p><ol><li><p>安装<code>babel-plugin-component</code>：<code>npm install babel-plugin-component -D</code></p></li><li><p>修改<code>babel.config.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">presets</span>:[<br>    <span class="hljs-string">&#x27;@vue/cli-plugin- babel/preset&#x27;</span>,<br>    [<span class="hljs-string">&quot;@babel/preset-env&quot;</span>, &#123;<span class="hljs-string">&quot;modules&quot;</span>: <span class="hljs-literal">false</span> &#125;]<br>],<br><span class="hljs-attr">plugins</span>: [<br>    [<br>      <span class="hljs-string">&#x27;component&#x27;</span>,<br>      &#123;<br>        <span class="hljs-attr">libraryName</span>: <span class="hljs-string">&#x27;element-ui&#x27;</span>,<br>        <span class="hljs-attr">styleLibraryName</span>: <span class="hljs-string">&#x27;theme-chalk&#x27;</span><br>      &#125;<br>    ]<br>  ],<br></code></pre></td></tr></table></figure></li><li><p>在<code> src</code> 文件夹中新建我们的 <code>element-ui </code>文件夹，并在里面新建一个<code>index.js </code>文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Scrollbar</span>, <span class="hljs-title class_">Button</span>, <span class="hljs-title class_">Input</span>, <span class="hljs-title class_">Tree</span>, <span class="hljs-title class_">Message</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$message</span> = <span class="hljs-title class_">Message</span>;<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Scrollbar</span>)<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Button</span>)<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Input</span>)<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Tree</span>)<br> <br><span class="hljs-keyword">import</span> <span class="hljs-title class_">CollapseTransition</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui/lib/transitions/collapse-transition&#x27;</span>;<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-title class_">CollapseTransition</span>.<span class="hljs-property">name</span>, <span class="hljs-title class_">CollapseTransition</span>)<br></code></pre></td></tr></table></figure><ul><li>弹窗类组件用 Vue.prototype，如 Message</li><li>大部分组件用 Vue.use，如 Input</li><li>少数组件需用Vue.component注册，如CollapseTransition</li></ul></li><li><p>在main.js中引入  import ‘.&#x2F;element-ui’。或者不要3，都写进main.js也行。</p></li></ol></li></ol><h1 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h1><p><a href="https://www.yuque.com/cessstudy/kak11d/hfeef2">参考笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Axios部分源码解读</title>
    <link href="/2023/06/19/Axios%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <url>/2023/06/19/Axios%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h1><p>基于promise的http客户端，可以在浏览器和node.js两个环境中运行。</p><p>浏览器端借助于Axios可以向服务端发送Ajax请求，node.js中可以用axios向远端服务发送http请求。</p><h2 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h2><ul><li>基于 Promise</li><li>支持浏览器和 node.js环境</li><li>可添加请求、响应拦截器和转换请求和响应数据</li><li>请求可以取消、中断</li><li>自动转换 JSON 数据</li><li>客户端支持防范 XSRF</li></ul><h2 id="源码目录结构"><a href="#源码目录结构" class="headerlink" title="源码目录结构"></a>源码目录结构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">├── /dist/ # 项目输出目录<br>├── /lib/ # 项目源码目录<br>│ ├── /adapters/ # 定义请求的适配器 xhr、http<br>│ │ ├── http.<span class="hljs-property">js</span> # 实现 http 适配器(包装 http 包)<br>│ │ └── xhr.<span class="hljs-property">js</span> # 实现 xhr 适配器(包装 xhr 对象)<br>│ ├── /cancel/ # 定义取消功能<br>│ ├── /core/ # 一些核心功能<br>│ │ ├── <span class="hljs-title class_">Axios</span>.<span class="hljs-property">js</span> # axios 的核心主类<br>│ │ ├── dispatchRequest.<span class="hljs-property">js</span> # 用来调用 http 请求适配器方法发送请求的函数<br>│ │ ├── <span class="hljs-title class_">InterceptorManager</span>.<span class="hljs-property">js</span> # 拦截器的管理器<br>│ │ └── settle.<span class="hljs-property">js</span> # 根据 http 响应状态，改变 <span class="hljs-title class_">Promise</span> 的状态<br>│ ├── /helpers/ # 一些辅助方法<br>│ ├── axios.<span class="hljs-property">js</span> # 对外暴露接口<br>│ ├── defaults.<span class="hljs-property">js</span> # axios 的默认配置<br>│ └── utils.<span class="hljs-property">js</span> # 公用工具<br>├── package.<span class="hljs-property">json</span> # 项目信息<br>├── index.<span class="hljs-property">d</span>.<span class="hljs-property">ts</span> # 配置 <span class="hljs-title class_">TypeScript</span> 的声明文件<br>└── index.<span class="hljs-property">js</span> # 入口文件<br></code></pre></td></tr></table></figure><h2 id="axios对象创建过程模拟实现"><a href="#axios对象创建过程模拟实现" class="headerlink" title="axios对象创建过程模拟实现"></a>axios对象创建过程模拟实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>        <span class="hljs-comment">// 构造函数</span><br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">Axios</span>(<span class="hljs-params">config</span>) &#123;<br>            <span class="hljs-comment">// 初始化</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">defaults</span> = config; <span class="hljs-comment">// 为了创建default默认属性</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">intercepters</span> = &#123;<br>                <span class="hljs-attr">request</span>: &#123;&#125;,<br>                <span class="hljs-attr">response</span>: &#123;&#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 原型添加相关的方法</span><br>        <span class="hljs-title class_">Axios</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">request</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">config</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;发送AJAX请求 请求的类型为&#x27;</span> ,config.<span class="hljs-property">method</span>);<br>        &#125;<br>        <span class="hljs-title class_">Axios</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">get</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">config</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(&#123;<span class="hljs-attr">method</span>:<span class="hljs-string">&#x27;GET&#x27;</span>&#125;);<br>        &#125;<br>        <span class="hljs-title class_">Axios</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">post</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">config</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(&#123;<span class="hljs-attr">method</span>:<span class="hljs-string">&#x27;POST&#x27;</span>&#125;);<br>        &#125;<br>        <span class="hljs-comment">// 声明函数</span><br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">createInstance</span>(<span class="hljs-params">config</span>) &#123;<br>            <span class="hljs-comment">// 实例化一个对象</span><br>            <span class="hljs-keyword">let</span> context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Axios</span>(config); <span class="hljs-comment">// 此时可以context.get() context.post() 但是不能当做函数使用即context()</span><br>            <span class="hljs-comment">// 创建请求函数,context.request(), 此时的this指向context的this</span><br>            <span class="hljs-keyword">let</span> instance = <span class="hljs-title class_">Axios</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">bind</span>(context); <span class="hljs-comment">// instanc 是一个函数，并且可以instance(&#123;&#125;),此时还不能使用instance.get</span><br>            <span class="hljs-comment">// 将Axios.prototype对象中的方法添加到instance函数对象中</span><br>            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-title class_">Axios</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>                instance[key] = <span class="hljs-title class_">Axios</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[key].<span class="hljs-title function_">bind</span>(context);  <span class="hljs-comment">// 给instance挂载,并使this始终指向context</span><br>            &#125;)<br>            <span class="hljs-comment">// 为instance函数对象添加属性default与intercepters</span><br>            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(context).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>                instance[key] = context[key];  <span class="hljs-comment">// 给instance挂载,并使this始终指向context</span><br>            &#125;)<br>            <span class="hljs-keyword">return</span> instance<br>        &#125;<br>        <span class="hljs-keyword">let</span> axios = <span class="hljs-title function_">createInstance</span>();<br>        <span class="hljs-comment">// 发送请求,既可以当成函数使用，也可以当做对象调方法使用</span><br>        <span class="hljs-comment">// axios.(&#123;method:&#x27;GET&#x27;&#125;)</span><br>        axios.<span class="hljs-title function_">get</span>(&#123;&#125;)<br>        axios.<span class="hljs-title function_">post</span>(&#123;&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="核心请求方法"><a href="#核心请求方法" class="headerlink" title="核心请求方法"></a>核心请求方法</h2><p>Axios.prototype.request可以说是整个axios请求的核心骨架，这里面主要做了对不同config的适配，以及关键的核心链式调用实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Axios</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">request</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">request</span>(<span class="hljs-params">config</span>) &#123;<br>  <span class="hljs-comment">// 判断参数类型 以支持不同的请求形式axios(&#x27;url&#x27;,config) / axios(config)</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> config === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    config = <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>] || &#123;&#125;;<br>    config.<span class="hljs-property">url</span> = <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>];<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    config = config || &#123;&#125;;<br>  &#125;<br><span class="hljs-comment">// 配置合并默认配置</span><br>  config = <span class="hljs-title function_">mergeConfig</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">defaults</span>, config);<br><br>  <span class="hljs-comment">// 转化请求的方法 转化为小写</span><br>  <span class="hljs-keyword">if</span> (config.<span class="hljs-property">method</span>) &#123;<br>    config.<span class="hljs-property">method</span> = config.<span class="hljs-property">method</span>.<span class="hljs-title function_">toLowerCase</span>();<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">defaults</span>.<span class="hljs-property">method</span>) &#123;<br>    config.<span class="hljs-property">method</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">defaults</span>.<span class="hljs-property">method</span>.<span class="hljs-title function_">toLowerCase</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    config.<span class="hljs-property">method</span> = <span class="hljs-string">&#x27;get&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">var</span> transitional = config.<span class="hljs-property">transitional</span>;<br><br>  <span class="hljs-keyword">if</span> (transitional !== <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-comment">// 针对性配置检测 1.0.0版本以后 transitional配置将移除 （好奇目前距离1.0版本好像距离很远，不知为何）</span><br>    validator.<span class="hljs-title function_">assertOptions</span>(transitional, &#123;<br>      <span class="hljs-attr">silentJSONParsing</span>: validators.<span class="hljs-title function_">transitional</span>(validators.<span class="hljs-property">boolean</span>, <span class="hljs-string">&#x27;1.0.0&#x27;</span>),<br>      <span class="hljs-attr">forcedJSONParsing</span>: validators.<span class="hljs-title function_">transitional</span>(validators.<span class="hljs-property">boolean</span>, <span class="hljs-string">&#x27;1.0.0&#x27;</span>),<br>      <span class="hljs-attr">clarifyTimeoutError</span>: validators.<span class="hljs-title function_">transitional</span>(validators.<span class="hljs-property">boolean</span>, <span class="hljs-string">&#x27;1.0.0&#x27;</span>)<br>    &#125;, <span class="hljs-literal">false</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// ........ 核心链式调用</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="拦截器实现"><a href="#拦截器实现" class="headerlink" title="拦截器实现"></a>拦截器实现</h2><p>拦截器在<code>axios.create</code>中<code>createInstance</code>去<code>new Axios</code>实例时构构建出来的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Axios</span>(<span class="hljs-params">instanceConfig</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">defaults</span> = instanceConfig;<br>  这里创建的请求和响应拦截器 通过统一的类构造出来的<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">interceptors</span> = &#123;<br>    <span class="hljs-attr">request</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterceptorManager</span>(),<br>    <span class="hljs-attr">response</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterceptorManager</span>()<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入&#x2F;core&#x2F;InterceptorManager.js中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">InterceptorManager</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span> = [];<br>&#125;<br><span class="hljs-comment">// 添加拦截器 添加成功、失败回调</span><br><span class="hljs-title class_">InterceptorManager</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">use</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">use</span>(<span class="hljs-params">fulfilled, rejected, options</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>.<span class="hljs-title function_">push</span>(&#123;<br>    <span class="hljs-attr">fulfilled</span>: fulfilled,<br>    <span class="hljs-attr">rejected</span>: rejected,<br>    <span class="hljs-attr">synchronous</span>: options ? options.<span class="hljs-property">synchronous</span> : <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">runWhen</span>: options ? options.<span class="hljs-property">runWhen</span> : <span class="hljs-literal">null</span><br>  &#125;);<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>&#125;;<br><br><span class="hljs-comment">// 注销指定拦截器</span><br><span class="hljs-title class_">InterceptorManager</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eject</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">eject</span>(<span class="hljs-params">id</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>[id]) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>[id] = <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 遍历执行</span><br><span class="hljs-title class_">InterceptorManager</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">forEach</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">forEach</span>(<span class="hljs-params">fn</span>) &#123;<br>  utils.<span class="hljs-title function_">forEach</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>, <span class="hljs-keyword">function</span> <span class="hljs-title function_">forEachHandler</span>(<span class="hljs-params">h</span>) &#123;<br>    <span class="hljs-comment">// 确定没被eject注销 才执行</span><br>    <span class="hljs-keyword">if</span> (h !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-title function_">fn</span>(h);<br>    &#125;<br>  &#125;);<br>&#125;;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">InterceptorManager</span>;<br></code></pre></td></tr></table></figure><h2 id="dispatchRequest"><a href="#dispatchRequest" class="headerlink" title="dispatchRequest"></a>dispatchRequest</h2><ul><li><p>处理请求头config配置</p></li><li><p>调用<code>adapter</code>适配器发起真正的请求，针对浏览器环境发起ajax请求，node环境发起http请求</p></li><li><p>构造响应数据， 会自动转换 JSON 数据</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchRequest</span>(<span class="hljs-params">config</span>) &#123;<br><span class="hljs-comment">// 提前取消请求</span><br>  <span class="hljs-title function_">throwIfCancellationRequested</span>(config);<br><br>  <span class="hljs-comment">// 赋个默认值</span><br>  config.<span class="hljs-property">headers</span> = config.<span class="hljs-property">headers</span> || &#123;&#125;;<br><br>  <span class="hljs-comment">// 转换数据</span><br>  config.<span class="hljs-property">data</span> = transformData.<span class="hljs-title function_">call</span>(<br>    config,<br>    config.<span class="hljs-property">data</span>,<br>    config.<span class="hljs-property">headers</span>,<br>    config.<span class="hljs-property">transformRequest</span><br>  );<br><br>  <span class="hljs-comment">// 合并headers配置</span><br>  config.<span class="hljs-property">headers</span> = utils.<span class="hljs-title function_">merge</span>(<br>    config.<span class="hljs-property">headers</span>.<span class="hljs-property">common</span> || &#123;&#125;,<br>    config.<span class="hljs-property">headers</span>[config.<span class="hljs-property">method</span>] || &#123;&#125;,<br>    config.<span class="hljs-property">headers</span><br>  );<br>  <span class="hljs-comment">// 删除多余的被合并过的数据</span><br>  utils.<span class="hljs-title function_">forEach</span>(<br>    [<span class="hljs-string">&#x27;delete&#x27;</span>, <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;head&#x27;</span>, <span class="hljs-string">&#x27;post&#x27;</span>, <span class="hljs-string">&#x27;put&#x27;</span>, <span class="hljs-string">&#x27;patch&#x27;</span>, <span class="hljs-string">&#x27;common&#x27;</span>],<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">cleanHeaderConfig</span>(<span class="hljs-params">method</span>) &#123;<br>      <span class="hljs-keyword">delete</span> config.<span class="hljs-property">headers</span>[method];<br>    &#125;<br>  );<br>  <span class="hljs-comment">// 适配器 axios是可以支持node端也支持浏览器端的 </span><br>  <span class="hljs-keyword">var</span> adapter = config.<span class="hljs-property">adapter</span> || defaults.<span class="hljs-property">adapter</span>;<br>  <span class="hljs-comment">// 执行请求</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">adapter</span>(config).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">onAdapterResolution</span>(<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-comment">// 提前取消请求情况</span><br>    <span class="hljs-title function_">throwIfCancellationRequested</span>(config);<br>    <span class="hljs-comment">// 做数据转换</span><br>    response.<span class="hljs-property">data</span> = transformData.<span class="hljs-title function_">call</span>(<br>      config,<br>      response.<span class="hljs-property">data</span>,<br>      response.<span class="hljs-property">headers</span>,<br>      config.<span class="hljs-property">transformResponse</span><br>    );<br>    <span class="hljs-keyword">return</span> response;<br>  &#125;, <span class="hljs-keyword">function</span> <span class="hljs-title function_">onAdapterRejection</span>(<span class="hljs-params">reason</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isCancel</span>(reason)) &#123;<br>      <span class="hljs-title function_">throwIfCancellationRequested</span>(config);<br>      <span class="hljs-comment">// 做数据转换</span><br>      <span class="hljs-keyword">if</span> (reason &amp;&amp; reason.<span class="hljs-property">response</span>) &#123;<br>        reason.<span class="hljs-property">response</span>.<span class="hljs-property">data</span> = transformData.<span class="hljs-title function_">call</span>(<br>          config,<br>          reason.<span class="hljs-property">response</span>.<span class="hljs-property">data</span>,<br>          reason.<span class="hljs-property">response</span>.<span class="hljs-property">headers</span>,<br>          config.<span class="hljs-property">transformResponse</span><br>        );<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(reason);<br>  &#125;);<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="适配器adapter"><a href="#适配器adapter" class="headerlink" title="适配器adapter"></a>适配器adapter</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDefaultAdapter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> adapter;<br>  <span class="hljs-comment">// 判断XMLHttpRequest对象是否存在 存在则代表为浏览器环境</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">XMLHttpRequest</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>    <span class="hljs-comment">// For browsers use XHR adapter</span><br>    adapter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./adapters/xhr&#x27;</span>);<br>    <span class="hljs-comment">// node环境 使用原生http发起请求</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> process !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(process) === <span class="hljs-string">&#x27;[object process]&#x27;</span>) &#123;<br>    adapter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./adapters/http&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> adapter;<br>&#125;<br></code></pre></td></tr></table></figure><p>.&#x2F;adapters&#x2F;xhr.js 则是对原生ajax <code>XMLHttpRequest</code>对象的的封装,.&#x2F;adapters&#x2F;http.js 则是对node <code>http</code>模块的封装，也会针对https做相应处理。具体封装细节各种边界细节情况都做了特殊处理 ，因为我们日常还是在浏览器端使用比较多，简单对<code>xhr</code>的封装源码做些整体。</p>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax</title>
    <link href="/2023/06/17/Ajax/"/>
    <url>/2023/06/17/Ajax/</url>
    
    <content type="html"><![CDATA[<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>Ajax诞生之前：在Ajax出现之前，JS没有原生的直接方法发送异步请求，早期互联网应用网页与服务器之间的通信通常是通过同步请求实现的。同步请求会导致整个页面在等待服务器响应时被冻结，用户无法进行其他操作，体验极差。</p><p>但也不是完全没有办法实现异步通信，有一些婉转的实现异步通信的方法，比如</p><ol><li>隐藏的帧： 将一个隐藏的 <code>&lt;iframe&gt;</code> 元素的源指向服务器资源，通过这个 iframe 来发起请求，然后使用 JavaScript 监听 iframe 的加载事件，从而模拟异步请求。但是这种方法并不常用，也不够灵活。</li><li><strong>定时器轮询（Polling with Timers）：</strong> 在 JavaScript 中使用定时器周期性地发起<strong>同步请求</strong>（请求是同步的，意味着仍然会阻塞其他的代码），模拟异步请求的效果。这种方式的缺点是，需要不断地轮询服务器，可能导致不必要的网络开销。</li></ol><p>而真正的异步通信-Ajax意味着请求发送后立即继续执行后续代码，直到响应返回时执行相应的回调函数。这种方法更加高效、实时，并且减轻了服务器的压力。</p><p>Ajax全称是：Asynchronous JavaScript And XML，翻译过来就是“异步的 Javascript 和 XML”。</p><blockquote><p>Ajax 是一个技术统称，是一个概念模型，它囊括了很多技术，并不特指某一技术，它很重要的特性之一就是让页面实现局部刷新。</p></blockquote><p>特点：<strong>局部刷新页面</strong>，无需重载整个页面。</p><p>简单来说，Ajax 是一种<strong>思想</strong>，XMLHttpRequest 只是实现 Ajax 的一种方式。其中 XMLHttpRequest 模块就是实现 Ajax 的一种很好的方式，这也是很多面试官喜欢让面试者手撕的代码之一。</p><p>利用 XMLHttpRequest 模块实现 Ajax。</p><h2 id="Ajax发送get请求"><a href="#Ajax发送get请求" class="headerlink" title="Ajax发送get请求"></a>Ajax发送get请求</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-comment">// 绑定事件</span><br>    btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">// 1.创建对象</span><br>    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>        <span class="hljs-comment">// 2.初始化，设置请求方法和url</span><br>        xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-string">&#x27;http://127.0.0.1:8000/server&#x27;</span>) <span class="hljs-comment">// 如果要加参数url后面跟？a=100&amp;b=200</span><br>    <span class="hljs-comment">// 3.发送</span><br>    xhr.<span class="hljs-title function_">send</span>()<br>    <span class="hljs-comment">// 4. 处理服务器返回的结果</span><br>        <span class="hljs-comment">// 当xhr的readyState属性改变都会触发onreadystatechange事件，而readyState表示当前处在请求/响应的哪个状态</span><br>    xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-comment">// 异步回调函数</span><br>            <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>) &#123;<br>                <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;响应结果&quot;</span>, xhr.<span class="hljs-property">response</span>)<br>                &#125;<br>            &#125;<br>        &#125;<br>&#125;<br>&lt;/script&gt;  <br></code></pre></td></tr></table></figure><h2 id="Ajax发送post请求"><a href="#Ajax发送post请求" class="headerlink" title="Ajax发送post请求"></a>Ajax发送post请求</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-comment">// 获取元素对象</span><br>    <span class="hljs-keyword">const</span> result = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;result&#x27;</span>)<br><span class="hljs-comment">// 绑定事件</span><br>result.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mouseover&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-comment">// 1.创建对象</span><br>        <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>        <span class="hljs-comment">// 2.初始化，设置类型与URL</span><br>        xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>,<span class="hljs-string">&#x27;http://127.0.0.1:8000/server&#x27;</span>)<br>        <span class="hljs-comment">// 3.发送</span><br>        xhr.<span class="hljs-title function_">send</span>()<br>        <span class="hljs-comment">// 4.事件绑定</span><br>        xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-comment">// 判断</span><br>            <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>)&#123;<br>                <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>)&#123;<br>                    <span class="hljs-comment">// 处理服务器端返回的结果</span><br>                    result.<span class="hljs-property">innerHTML</span> = xhr.<span class="hljs-property">response</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;  <br></code></pre></td></tr></table></figure><p>如果要加参数放在请求体里，多种格式可以用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 3. 发送</span><br><span class="hljs-comment">// xhr.send(&#x27;a=100&amp;b=200&amp;c=300&#x27;)</span><br><span class="hljs-comment">// xhr.send(&#x27;a:100&amp;b:200&amp;c:300&#x27;)</span><br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;124244&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 我们使用这种方式实现网络请求时，如果请求内部又包含请求，以此循环，就会出现回调地狱，这也是一个诟病，后来才催生了更加优雅的请求方式。</p></blockquote><h1 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h1><p>Fetch 是在 ES6 出现的，它使用了 ES6 提出的 promise 对象， 是一个基于 promise 的浏览器原生就支持的 API。</p><blockquote><p>不是对XMLHttpRequest的封装，是一种新的获取资源的接口方式。</p></blockquote><p><strong>特点：</strong></p><ul><li>使用 promise，不使用回调函数。</li><li>采用模块化设计，比如 rep、res 等对象分散开来，比较友好。</li><li>通过数据流对象处理数据，可以提高网站性能。</li></ul><p>Fetch 实现网络请求</p><ul><li>参数：resource、config</li><li>返回结果：值为Response对象的Promise</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">ajaxFetch</span>(<span class="hljs-params">url</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">fetch</span>(url).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(data)</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">ajaxFetch</span>(<span class="hljs-string">&#x27;https://smallpig.site/api/category/getCategory&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><blockquote><p>上段代码利用 Fetch 发送了一个最简单的 get 请求，其中最重要的特点之一就是采用了.then 链式调用的方式处理结果，这样不仅利于代码的可读，而且也解决了回调地狱的问题。</p></blockquote><h1 id="Fetch-VS-XMLHttpRequest"><a href="#Fetch-VS-XMLHttpRequest" class="headerlink" title="Fetch VS XMLHttpRequest"></a>Fetch VS XMLHttpRequest</h1><ul><li><p>请求</p><p>从发请求的接口参数开始看</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">fetch</span>( <span class="hljs-string">&#x27;/v1/accounts&#x27;</span>, &#123;<br>  <span class="hljs-attr">method</span>:    <span class="hljs-comment">// 发送方式</span><br>  <span class="hljs-attr">headers</span>:   <span class="hljs-comment">// 请求头</span><br>  <span class="hljs-attr">body</span>:      <span class="hljs-comment">// 请求体（请求所携带的参数）</span><br>  <span class="hljs-attr">credentials</span>: <span class="hljs-comment">// 控制请求是否带上 cookie 等机密信息</span><br>  <span class="hljs-attr">mode</span>:        <span class="hljs-comment">// 设置请求方式的标志位</span><br>  cache：<br>  <span class="hljs-attr">redirect</span>:<br>  <span class="hljs-attr">referrer</span>:<br>  <span class="hljs-attr">referrerPolicy</span>:<br>  <span class="hljs-attr">integrity</span>:<br>&#125; )<br></code></pre></td></tr></table></figure><ol><li><p>credentials</p><p>控制请求是否带上 cookie 等机密信息。fetch 可接收如下三种值：</p><ul><li>omit: 请求不带任何 cookie。</li><li>same-origin: 同域请求会带上 cookie。</li><li>include: 无论是否跨域都会带上 cookie。</li></ul><p>XMLHttpRequest 对应也有一个 withCredentials 标志位对应此参数，withCredentials 只有两个取值：</p><ul><li>true: 大致对应上面的 include，MDN 上描述此 flag 不止控制 cookie 还控制 authorization headers 或者 TLS client certificates。</li><li>false: 大致对应上面的 omit，MDN 上描述为 false 时还控制跨域请求的 response 不能设置 cookie。</li></ul></li><li><p>mode</p><p>设置请求方式的标志位。fetch 可以通过设置这个标志位从发起请求阶段就阻止跨域请求。</p><p><strong>而 XMLHttpRequest 并没有对应的标志位</strong>，只能先发出请求然后通过检测 response 头中是否有允许跨域的字段来判断是否要阻止接收 response。</p></li><li><p>redirect</p><p>设置请求如果遇到重定向的返回如何响应：</p><ul><li>follow: 跟随重定向</li><li>error: 如果 response 是重定向，则报错</li><li>manual: 自定义行为</li></ul><p><strong>XMLHttpRequest 没有对应的字段</strong>。</p></li></ol></li><li><p>响应</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">fetch</span>( url, option ).<span class="hljs-title function_">then</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>)&#123;<br>  response.<span class="hljs-property">headers</span>  <br>  response.<span class="hljs-property">ok</span>          <span class="hljs-comment">// 请求成功,XHLHttpRequest 没有对应的字段。</span><br>  response.<span class="hljs-property">status</span><br>  response.<span class="hljs-property">statusText</span><br>  response.<span class="hljs-property">redirected</span>  <span class="hljs-comment">// 此标志位表示请求是否被重定向了。XMLHttpRequest 没有对应的字段。</span><br>  response.<span class="hljs-property">type</span>        <span class="hljs-comment">// 表示 response 的类型，XMLHttpRequest 没有对应的字段。</span><br>  response.<span class="hljs-property">url</span><br>  response.<span class="hljs-title function_">arrayBuffer</span>()<br>  response.<span class="hljs-title function_">blob</span>()<br>  response.<span class="hljs-title function_">formData</span>()<br>  response.<span class="hljs-title function_">json</span>()<br>  response.<span class="hljs-title function_">text</span>()<br>&#125; )<br></code></pre></td></tr></table></figure></li></ul><p>总的来说，fetch API 提供了对请求更精确的控制。对 cookie，对跨域等功能都有了传统 Ajax（XMLHttpRequest）没有的功能，响应（response）还提供了一些的原来没有的标志位。</p><h1 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h1><blockquote><p>Axios 是一个基于 promise 封装的ajax请求库，可以用在浏览器和 node.js 中。</p><p>实际上，axios可以用在浏览器和 node.js 中是因为，它会自动判断当前环境是什么，如果是浏览器，就会基于XMLHttpRequests实现axios。如果是node.js环境，就会基于node内置核心模块http实现axios。</p></blockquote><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>从浏览器中创建 XMLHttpRequests</li><li>从 node.js 创建 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换 JSON 数据</li><li>客户端支持防御 XSRF</li></ul><h2 id="支持多种请求方式"><a href="#支持多种请求方式" class="headerlink" title="支持多种请求方式"></a>支持多种请求方式</h2><ul><li>axios(config)</li><li>axios.request(config)</li><li>axios.get(ur[,config])</li><li>axios.delete(ur[,config])</li><li>axios.head(url[,config])</li><li>axios.post(url[,data[,config]])</li><li>axios.put(url[,data[,config]])</li><li>axios.patch(url[,data[,config]])</li></ul><h2 id="axios基本使用"><a href="#axios基本使用" class="headerlink" title="axios基本使用"></a>axios基本使用</h2><ul><li>默认是get请求</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<br>  <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://123.207.32.32:8000/home/multidata&#x27;</span>,<br>    <span class="hljs-comment">//method:&#x27;post&#x27;</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>get携带参数写法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//法一、直接放入url用?连接参数</span><br><span class="hljs-title function_">axios</span>(&#123;<br>  <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://123.207.32.32:8000/home/data?type=sell&amp;page=3&#x27;</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;)<br><span class="hljs-comment">//法二、用params传参</span><br><span class="hljs-title function_">axios</span>(&#123;<br>  <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://123.207.32.32:8000/home/data&#x27;</span>,<br>  <span class="hljs-attr">params</span>:&#123;<br>      <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;pop&#x27;</span>,<br>      <span class="hljs-attr">page</span>:<span class="hljs-number">1</span><br>  &#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>axios发送并发请求</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//类似promise的all</span><br>axios.<span class="hljs-title function_">all</span>([<br>  <span class="hljs-title function_">axios</span>(&#123;<br>    <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://123.207.32.32:8000/home/multidata&#x27;</span><br>  &#125;),<br>  <span class="hljs-title function_">axios</span>(&#123;<br>    <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://123.207.32.32:8000/home/data&#x27;</span>,<br>    <span class="hljs-attr">params</span>:&#123;<br>      <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;sell&#x27;</span>,<br>      <span class="hljs-attr">page</span>:<span class="hljs-number">5</span><br>    &#125;<br>  &#125;)<br>]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">results</span> =&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results[<span class="hljs-number">0</span>]);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results[<span class="hljs-number">1</span>]);<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="常见全局配置"><a href="#常见全局配置" class="headerlink" title="常见全局配置"></a>常见全局配置</h2><ul><li><code>axios.defaults.+配置信息</code>可以拿到axios的配置信息</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//使用全局axios提取全局的配置</span><br>axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">baseURL</span> = <span class="hljs-string">&#x27;http://123.207.32.32:8000&#x27;</span><br><span class="hljs-comment">//发送并发请求</span><br>axios.<span class="hljs-title function_">all</span>([<br>  <span class="hljs-title function_">axios</span>(&#123;<br>    <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;/multidata&#x27;</span><br>  &#125;),<br>  <span class="hljs-title function_">axios</span>(&#123;<br>    <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;/home/data&#x27;</span>,<br>    <span class="hljs-attr">params</span>:&#123;<br>      <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;sell&#x27;</span>,<br>      <span class="hljs-attr">page</span>:<span class="hljs-number">5</span><br>    &#125;<br>  &#125;)<br>]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">results</span> =&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results[<span class="hljs-number">0</span>]);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results[<span class="hljs-number">1</span>]);<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>axios常见配置（config）</li></ul><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230616104425111.png" alt="image-20230616104425111"></p><h2 id="axios实例和模块封装"><a href="#axios实例和模块封装" class="headerlink" title="axios实例和模块封装"></a>axios实例和模块封装</h2><p>为什么要封装axios？</p><ol><li>当一个库不维护时，便于在封装的地方把不维护的库替换掉。</li><li>可以进行一些统一配置处理，例如设置请求的超时时间、设置请求头部信息、处理请求错误等。这样可以确保在整个项目中使用相同的配置，并且在需要修改配置时只需要在封装的地方进行修改，而不需要逐个地修改每个请求的代码。</li><li>可以进行拦截器的统一处理，在拦截器中添加公共的逻辑。例如在请求中添加认证信息、处理请求错误、统一处理响应等。</li><li>可以将不同的请求逻辑封装成不同的函数或模块，方便复用和维护。可以共享一些请求逻辑。提高代码的可读性和可维护性。</li></ol><ul><li>axios实例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> instance1 = axios.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">baseURL</span>:<span class="hljs-string">&#x27;http://123.207.32.32:8000&#x27;</span>,<br>  <span class="hljs-attr">timeout</span>:<span class="hljs-number">5000</span><br>&#125;)<br><br><span class="hljs-title function_">instance1</span>(&#123;<br>  <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;/home/multidata&#x27;</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li><p>封装request模块</p><ul><li>方法一</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//在network文件夹下新建request.js</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">request</span>(<span class="hljs-params">config,success,failure</span>)&#123;<br>    <span class="hljs-comment">//1.创建axios的实例</span><br>    <span class="hljs-keyword">const</span> instance = axios.<span class="hljs-title function_">create</span>(&#123;<br>        <span class="hljs-attr">baseURL</span>:<span class="hljs-string">&#x27;http://123.207.32.32:8000&#x27;</span>,<br>        <span class="hljs-attr">timeout</span>:<span class="hljs-number">5000</span><br>    &#125;)<br>    <span class="hljs-comment">//2.发送真正的网络请求</span><br>    <span class="hljs-title function_">instance</span>(config)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>        <span class="hljs-title function_">success</span>(res)<br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-params">err=&gt;</span>)&#123;<br>        <span class="hljs-title function_">failure</span>(err)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//在使用处</span><br><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../network/request.js&#x27;</span><br><br><span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;.home/multidata&#x27;</span><br>&#125;,<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>&#125;,<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err) <br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>方法二</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//在network文件夹下新建request.js</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">request</span>(<span class="hljs-params">config</span>)&#123;<br>    <span class="hljs-comment">//1.创建axios的实例</span><br>    <span class="hljs-keyword">const</span> instance = axios.<span class="hljs-title function_">create</span>(&#123;<br>        <span class="hljs-attr">baseURL</span>:<span class="hljs-string">&#x27;http://123.207.32.32:8000&#x27;</span>,<br>        <span class="hljs-attr">timeout</span>:<span class="hljs-number">5000</span><br>    &#125;)<br>    <span class="hljs-comment">//2.发送真正的网络请求</span><br>    <span class="hljs-title function_">instance</span>(config.<span class="hljs-property">baseConfig</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>        config.<span class="hljs-title function_">success</span>(res)<br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-params">err=&gt;</span>)&#123;<br>        config.<span class="hljs-title function_">failure</span>(err)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//在使用处</span><br><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../network/request.js&#x27;</span><br><br><span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">baseConfig</span>:&#123;&#125;,<br>    <span class="hljs-attr">success</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123;&#125;,<br>    <span class="hljs-attr">failure</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)&#123;&#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>&#x3D;&#x3D;方法三&#x3D;&#x3D;Promise写法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//在network文件夹下新建request.js</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">request</span>(<span class="hljs-params">config</span>)&#123;<br>        <span class="hljs-comment">//1.创建axios的实例</span><br>        <span class="hljs-keyword">const</span> instance = axios.<span class="hljs-title function_">create</span>(&#123;<br>            <span class="hljs-attr">baseURL</span>:<span class="hljs-string">&#x27;http://123.207.32.32:8000&#x27;</span>,<br>            <span class="hljs-attr">timeout</span>:<span class="hljs-number">5000</span><br>        &#125;)<br>         <span class="hljs-comment">//2.axios的拦截器(如果要拦截请求或响应做额外的操作)</span><br>        <span class="hljs-comment">//2.1请求拦截</span><br>        instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span>&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(config)<span class="hljs-comment">//可以对config作处理，比如config中的一些信息不符合服务器的要求，比如每次发送网络请求时，都希望在界面中显示一个请求的图标，比如每次发送网络请求时，都希望在界面中显示一个请求的图标。</span><br>            <span class="hljs-keyword">return</span> config<br>        &#125;,<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span>&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>        &#125;)<br>        <span class="hljs-comment">//2.2响应拦截</span><br>        instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span>&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>            <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span><br>        &#125;,<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span>&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>        &#125;<br>        <br>        <span class="hljs-comment">//3.发送真正的网络请求</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">instance</span>(config) <br>&#125;<br><br><span class="hljs-comment">//在使用处</span><br><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../network/request.js&#x27;</span><br><br><span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;/home/multidata&#x27;</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li><p>配置优先级</p><blockquote><p>配置项通过一定的规则合并，request config &gt; instance.defaults &gt; 系统默认，优先级高的覆盖优先级低的。</p></blockquote></li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Ajax，异步的JavaScript和XML，是js里的一种异步思想，具体而言就是可以局部刷新页面，无需重载整个页面。</li><li>XMLHttpRequest ，早期实现 Ajax 的方式主要是用xhr实现的。现在流行的一些网络请求三方库也是基于xhr的二次封装，比如我们常用的axios。</li><li>fetch使用了 ES6 提出的 promise 对象，是一种新的获取资源的接口方式，是一个浏览器原生就支持的api。</li><li>axios是一个基于 promise 对原生 Ajax 封装的 HTTP 库，可以用在浏览器和 node.js 中。是用于网络请求的第三方库，需要引入，浏览器原生不支持。</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网页布局方式</title>
    <link href="/2023/06/13/%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/"/>
    <url>/2023/06/13/%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、传统网页布局总结"><a href="#一、传统网页布局总结" class="headerlink" title="一、传统网页布局总结"></a>一、传统网页布局总结</h1><p>传统网络布局三种方式：标准流、浮动、定位。（重点：定位）</p><h2 id="1-标准流"><a href="#1-标准流" class="headerlink" title="1. 标准流"></a>1. 标准流</h2><ul><li>块级元素会独占一行，从上向下顺序排列。</li><li>行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行。</li></ul><h2 id="2-浮动（-x3D-x3D-脱标-x3D-x3D-）"><a href="#2-浮动（-x3D-x3D-脱标-x3D-x3D-）" class="headerlink" title="2. 浮动（&#x3D;&#x3D;脱标&#x3D;&#x3D;）"></a>2. 浮动（&#x3D;&#x3D;脱标&#x3D;&#x3D;）</h2><ul><li>可以让多个块级元素一行内排列显示。</li><li>&#x3D;&#x3D;float属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘。&#x3D;&#x3D;</li><li>为了约束浮动元素位置我们网页布局一般采取的策略是: 先用标准流的父元素排列，上下位置，之后内部子元素采取浮动排列左右位置。</li></ul><blockquote><p>网页布局第一准则: 多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动。（标准流管上下，浮动管左右）</p></blockquote><ul><li><p>为什么要清除浮动(父盒子没高度，子浮动了，影响了下面布局)</p><ul><li><p>Why：由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为0时，就会<br>影响下面的标准流盒子。</p></li><li><p>如果父盒子本身有高度，则不需要清除浮动。</p></li><li><p>清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了。</p></li><li><p>语法</p><blockquote><p>选择器{clear:属性值；}</p><p>left | right | both</p></blockquote></li></ul></li><li><p>&#x3D;&#x3D;清除浮动的方法&#x3D;&#x3D;</p><ul><li><p>额外标签法（隔墙法）</p><ul><li>在浮动元素末尾添加一个空的标签。例如<div style="clear:both"> </div></li></ul></li><li><p>父级添加overflow属性</p></li><li><p>父级添加:after伪元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>    <span class="hljs-attribute">content</span>:<span class="hljs-string">&#x27;&#x27;</span>;  //伪元素必须写的属性<br>    <span class="hljs-attribute">display</span>:block;//插入的元素必须是块级<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;//不要看见这个元素<br>    <span class="hljs-attribute">clear</span>: both; //核心代码清除浮动<br>    <span class="hljs-attribute">visibility</span>: hidden; //不要看见这个元素<br>&#125;<br><br><span class="hljs-selector-class">.clearfix</span> &#123; <span class="hljs-comment">/* IE6、7专有*/</span><br>    *zoom: <span class="hljs-number">1</span>;<br>&#125;<br><br>&lt;<span class="hljs-selector-tag">div</span> class=&quot;box clearfix&quot;&gt;<br>    &lt;<span class="hljs-selector-tag">div</span> class=&quot;damao&quot;&gt; 大毛&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>    &lt;<span class="hljs-selector-tag">div</span> class=&quot;ermao&quot;&gt; 二毛&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;<span class="hljs-selector-tag">div</span> class=&quot;<span class="hljs-selector-tag">footer</span>&quot;&gt;&lt; /<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p>父级添加双伪元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:before</span>,<span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-attribute">display</span>:table; //转化为块级元素并且一行显示<br>&#125;<br><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>    <span class="hljs-attribute">clear</span>:both;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-定位"><a href="#3-定位" class="headerlink" title="3. 定位"></a>3. 定位</h2><p><a href="https://www.bilibili.com/video/BV14J4114768?p=235&vd_source=eecaca8f9a8f0e789df0ded617e5100a">学习视频</a></p><p><strong>相对定位</strong></p><blockquote><p>选择器{position: relative; }</p><ul><li>它是相对于自己原来的位置来移动的(&#x3D;&#x3D;移动位置的时候参照点是自己原来的位置&#x3D;&#x3D;)。</li><li>原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它。(&#x3D;&#x3D;不脱标&#x3D;&#x3D;, 继续保留原来位置)</li></ul></blockquote><p><strong>绝对定位</strong></p><blockquote><p>选择器{position: absolute; }</p><ul><li>绝对定位是元素在移动位置的时候,是相对于它&#x3D;&#x3D;有定位的祖先元素&#x3D;&#x3D;来说的。</li><li>如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位( &#x3D;&#x3D;脱标&#x3D;&#x3D;、行内可以设置宽高，块元素不独占一行，由内容撑开宽高；)</li></ul></blockquote><p>与浮动区别：</p><ul><li>浮动可以让多个块级盒子一行没有缝隙排列显示，经常用于横向排列盒子。</li><li>定位则是可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子。</li><li>浮动元素不同，只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字(图片)</li><li>但是绝对定位(固定定位)会压住下面标准流所有的内容。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;head&gt;<br>    &lt;style&gt;<br>        <span class="hljs-selector-class">.box</span> &#123;<br>            <span class="hljs-comment">/* 1.浮动的元素不会压住下面标准流的文字*/</span><br>            <span class="hljs-comment">/* fLoat: Left; */</span><br>            <span class="hljs-comment">/* 2.绝对定位(固定定位) 全压住下面标准流所有的内容。</span><br><span class="hljs-comment">            position: absolute;</span><br><span class="hljs-comment">            width: 150px;</span><br><span class="hljs-comment">            height: 150px;</span><br><span class="hljs-comment">            background-color:pink;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &lt;/style&gt;</span><br><span class="hljs-comment">&lt;/head&gt;</span><br><span class="hljs-comment">&lt;body&gt;</span><br><span class="hljs-comment">    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="hljs-comment">    &lt;p&gt;阁下何不同风起，扶摇直上九万里&lt;/p&gt;</span><br><span class="hljs-comment">&lt;/bodv&gt;</span><br></code></pre></td></tr></table></figure><p><strong>固定定位</strong></p><p>固定定位是绝对定位的一种特殊形式，也是&#x3D;&#x3D;脱标&#x3D;&#x3D;的，并且只认浏览器的可视窗口，与父元素无关</p><ul><li>在使用固定定位时，如果盒子中没有内容，需要指定宽度</li></ul><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>绝对定位和固定定位与浮动相同的地方：</p><ul><li>行内元素添加绝对或者固定定位，可以直接设置高度和宽度（脱标）。</li><li>块级元素添加绝对或者固定定位，如果不给宽度或者高度,默认大小是内容的大小。</li></ul><table><thead><tr><th>定位模式</th><th>是否脱标</th><th>移动位置</th><th>是否常用</th></tr></thead><tbody><tr><td>static静态定位</td><td>否（占有位置）</td><td>不能使用边偏移</td><td>很少</td></tr><tr><td>relative相对定位</td><td>否（占有位置）</td><td>相对于自身位置移动</td><td>常用</td></tr><tr><td>absolute绝对定位</td><td>是（不占有位置）</td><td>带有定位的父级</td><td>常用</td></tr><tr><td>fixed固定定位</td><td>是（不占有位置）</td><td>浏览器可视区</td><td>常用</td></tr><tr><td>sticky粘性定位</td><td>否（占有位置）</td><td>浏览器可视区</td><td>很少</td></tr></tbody></table><p>&#x3D;&#x3D;重点：子绝父相&#x3D;&#x3D;</p><p>注意的点：</p><ol><li><p>标准流（如相对定位）可以用margin：0 auto来水平居中；但脱离标准流以后水平居中要采用，left：50%；margin-left：-自身宽度一半&#x3D;&#x3D; transform: translate(-50%,-50%);（往左往上移动自身宽度一半）</p></li><li><p>z-index用来控制叠放次序：</p><p>在使用定位布局时，可能会出现盒子重叠的情况。此时可以用<strong>z-indx</strong>来控制盒子的先后次序（z轴）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">选择器 &#123;<span class="hljs-attribute">z-index</span>:<span class="hljs-number">1</span>;&#125;<br></code></pre></td></tr></table></figure><ul><li>数值可以是正整数、负整数或0，默认是auto ，数值越大，盒子越靠上</li><li>如果属性值相同，则按照书写顺序，后来居上</li><li>数字后面不能加单位</li><li>只有定位的盒子才有z-index属性</li></ul></li></ol><ul><li>传统网页布局总结:<ul><li>标准流<br>可以让盒子上下排列或者左右排列,垂直的块级盒子显示就用标准流布局。</li><li>浮动<br>可以让多个块级元素-行显示或者左右对齐盒子 ,多个块级盒子水平显示就用浮动布局。</li><li>定位<br>定位最大的特点是有层叠的概念,就是可以让多个盒子前后叠压来显示。如果元素自由在某个盒子内移动就<br>用定位布局。</li></ul></li></ul><h1 id="二、FLEX布局"><a href="#二、FLEX布局" class="headerlink" title="二、FLEX布局"></a>二、FLEX布局</h1><p>通过给&#x3D;&#x3D;父元素添加&#x3D;&#x3D;flex属性制子元素的排列方式和位置。</p><blockquote><p>注意，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p></blockquote><h2 id="父项常见属性"><a href="#父项常见属性" class="headerlink" title="父项常见属性"></a><strong>父项常见属性</strong></h2><ul><li>flex-direction：设置主轴的方向</li><li>flex-wrap：设置子元素是否换行</li><li>flex-flow：复合属性，相当于同时设置了flex-direction和flex-wrap</li><li>justify-content：设置主轴上的子元素排列方式</li><li>align-items：设置侧轴上的子元素排列方式(单行)</li><li>align-content：设置侧轴上的子元素的排列方式(多行)</li></ul><ol><li><p>flex-direction：默认的主轴是x轴行row，y轴column列是侧轴，子元素是根据主轴来排列的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">flex-direction</span>: row | row-reverse | column | column-reverse;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>flex-wrap：设置子元素是否换行，flex布局默认不换行。如果装不开会缩小子元素的宽度。</p><ul><li>wrap：   换行， 第一行在上方。</li><li>nowrap：不换行（默认）</li><li>wrap-reverse：换行，第一行在下方。</li><li><strong>设置了换行以后才可使用align-content</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">// 设置每行显示的个数，超出自动换行解决方案<br>// 父元素<br><span class="hljs-attribute">flex-wrap</span>: wrap;<br>// 子元素设置宽度使一行放不下三个就会自动换行<br><span class="hljs-attribute">min-width</span>: <span class="hljs-number">48%</span>;<br></code></pre></td></tr></table></figure></li><li><p>flex-flow：是flex-direction和flex-wrap的复合属性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>justify-content：设置主轴上的子元素排列方式。</p><ul><li>flex-start:                从左到右</li><li>flex-end:                 从右到左</li><li>center:                    居中对齐</li><li>space-around:       平均分配（相当于每个盒子的marginleft right相等）</li><li><strong>space-between</strong>:     先两边贴边，再平分剩余空间，项目之间的间隔都相等</li></ul></li><li><p>align-items：设置侧轴上的子元素排列方式（&#x3D;&#x3D;单行&#x3D;&#x3D;）。以主轴为x，侧轴为y轴为例：</p><ul><li>flex-start:  从上到下 </li><li>flex-end:   从下到上</li><li>center:      挤在一起居中（垂直居中）</li><li>stretch:     拉伸（默认值）</li></ul><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230613135026452.png" alt="image-20230613135026452" style="zoom:80%;"></li><li><p>align-content：设置侧轴上的子元素的排列方式(&#x3D;&#x3D;多行&#x3D;&#x3D;，在单行情况下没效果)。</p><ul><li>flex-start:               从侧轴的头部开始排列</li><li>flex-end:                 从侧轴的尾部开始排列</li><li>center:                    在侧轴中间显示</li><li>space-around:       子项在侧轴平分剩余空间</li><li>space-between:     子项在侧轴先分布在两头，再平分剩余空间</li><li>stretch：                 设置子项元素高度平分父元素高度。</li></ul><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230613135224902.png" alt="image-20230613135224902" style="zoom:80%;"></li></ol><h2 id="子项常见属性"><a href="#子项常见属性" class="headerlink" title="子项常见属性"></a><strong>子项常见属性</strong></h2><ul><li>order：定义项目的排列顺序，数值越小排列越靠前，默认为0</li><li>flex-grow：属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</li><li>flex-shrink：定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li><li>flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</li><li><strong>flex</strong>：<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</li><li>align-self：<code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</li></ul><ol><li><p>order</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">order</span>: &lt;integer&gt;;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>flex-grow 定义项目的放大比例</p><blockquote><p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">flex-grow</span>: &lt;number&gt;; <span class="hljs-comment">/* default 0 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230613135819114.png" alt="image-20230613135819114"></p></li><li><p>flex-shrink</p><blockquote><p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">flex-shrink</span>: &lt;number&gt;; <span class="hljs-comment">/* default 1 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>flex-basis</p><p>在分配多余空间之前，项目占据的主轴空间。以x轴为例</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">div</span> class=&quot;box1&quot;&gt;<br>    &lt;<span class="hljs-selector-tag">div</span> class=&quot;item&quot; style=&quot;<span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<span class="hljs-attribute">background-color</span>: red;&quot;&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>    &lt;<span class="hljs-selector-tag">div</span> class=&quot;item&quot; style=&quot;<span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<span class="hljs-attribute">background-color</span>: black;<span class="hljs-attribute">flex-basis</span>: <span class="hljs-number">10px</span><span class="hljs-string">&quot;&gt;&lt;/div&gt;</span><br><span class="hljs-string">    &lt;div class=&quot;</span>item<span class="hljs-string">&quot; style=&quot;</span>flex: <span class="hljs-number">1</span>;<span class="hljs-attribute">background-color</span>: pink;&quot;&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;/<span class="hljs-selector-tag">div</span>&gt;<br><br><span class="hljs-selector-class">.box1</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>;<br>        <span class="hljs-attribute">display</span>: flex;<br>        <span class="hljs-attribute">justify-content</span>: space-between;<br>        <span class="hljs-attribute">background-color</span>: green;<br>    &#125;<br><span class="hljs-selector-class">.item</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br>// 第二个item给了<span class="hljs-number">10px</span>的宽度，则原本他就占据主轴的<span class="hljs-number">10px</span>，总宽度<span class="hljs-number">100px</span>-<span class="hljs-number">10px</span>=<span class="hljs-number">90px</span>，再根据<span class="hljs-attribute">flex</span>=<span class="hljs-number">1</span>平分剩余空间，最终三项的宽度为<span class="hljs-number">30px</span>、<span class="hljs-number">40px</span>、<span class="hljs-number">30px</span><br></code></pre></td></tr></table></figure><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230613143303345.png" alt="image-20230613143303345"></p></li><li><p><strong>flex</strong></p><p>是flex-grow，flex-shrink，flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">div</span> class=&quot;box1&quot;&gt;<br>    &lt;<span class="hljs-selector-tag">div</span> class=&quot;item&quot; style=&quot;<span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<span class="hljs-attribute">background-color</span>: red;&quot;&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>    &lt;<span class="hljs-selector-tag">div</span> class=&quot;item&quot; style=&quot;<span class="hljs-attribute">flex</span>: <span class="hljs-number">2</span>;<span class="hljs-attribute">background-color</span>: black;&quot;&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>    &lt;<span class="hljs-selector-tag">div</span> class=&quot;item&quot; style=&quot;<span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<span class="hljs-attribute">background-color</span>: pink;&quot;&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;/<span class="hljs-selector-tag">div</span>&gt;<br><br>&lt;style&gt;<br>    <span class="hljs-selector-class">.box1</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>;<br>        <span class="hljs-attribute">display</span>: flex;<br>        <span class="hljs-attribute">justify-content</span>: space-between;<br>        <span class="hljs-attribute">background-color</span>: green;<br>    &#125;<br>    <span class="hljs-selector-class">.item</span> &#123;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>    &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230613142215388.png" alt="image-20230613142215388"></p></li><li><p>align-self：控制子项自己在侧轴上的排列方式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230613141142829.png" alt="image-20230613141142829" style="zoom:80%;"><h1 id="三、居中布局"><a href="#三、居中布局" class="headerlink" title="三、居中布局"></a>三、居中布局</h1><p><strong>标准流：</strong> </p><ul><li><p>行内元素和行内块元素</p><ul><li><p>文本水平居中： 给包含文本的标签元素设置<code>text-align: center</code> </p></li><li><p>文本垂直居中： line-height&#x3D;行高 </p></li><li><p>行内块元素垂直方向上基线对齐方式：vertical-align，参考的是这一行中的文本</p><ul><li><p>vertical-align: top; 把这一行的所有元素的顶端与行中最高元素的顶端对齐</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">sqan</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box2&quot;</span>&gt;</span><br>    中文字体<br><span class="hljs-tag">&lt;/<span class="hljs-name">sqan</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.box1</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">display</span>: inline-block;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: green;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.box2</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">vertical-align</span>: top;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230613104306222.png" alt="image-20230613104306222"></p></li><li><p>vertical-align: bottom; 把这一行的所有元素的底端与行中最低元素的底端对齐</p></li><li><p>vertical-align: baseline; 图片或inline-block元素的底端（图片、inline-block元素底部和基线已经重合）对齐文本的baseline基线对齐  默认值</p></li><li><p><strong>vertical-align: middle</strong>; 这行元素的中线对齐，图片的中线就是图片垂直方向上一半的位置，文字也是，设置在图片或者inline-block元素上生效</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">sqan</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box2&quot;</span>&gt;</span><br>    中文字体<br><span class="hljs-tag">&lt;/<span class="hljs-name">sqan</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.box1</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">display</span>: inline-block;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: green;</span><br><span class="language-css">        <span class="hljs-attribute">vertical-align</span>: middle;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.box2</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230613105844576.png" alt="image-20230613105844576"></p></li><li><p>vertical-align: super;  使元素基线高于父元素基线，但是高多少规范中没有要求，由用户代理（浏览器）自己决定，不同浏览器可能不同。<br>vertical-align: sub;  使元素基线低于父元素基线，与 super 一样，低多少由用户代理决定，不同浏览器可能不同。</p></li></ul></li></ul></li><li><p>块级元素</p><ul><li>水平居中：<code> margin: 0 auto</code>（要求定宽）；设置display:table和margin:0 auto（不定宽）</li><li>垂直居中：只能通过flex布局或定位实现。</li></ul></li></ul><p>绝对定位脱标以后：(块级元素定位实现垂直居中)</p><p>水平居中：left：50%; margin-left:-自身宽度一半；&#x3D;&#x3D;  left:50%； transform:translate(-50%,0);</p><p>垂直居中：top：50%；margin-top：-自身高度一半 ；&#x3D;&#x3D; top:50%； transform:translate(0,-50%);</p><p>水平垂直居中：left:50%; top:50%; transform:translate(-50%,-50%);</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">阮一峰的网络日志</a></p>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网页布局方式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合引用类型Array</title>
    <link href="/2023/06/08/%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8BArray/"/>
    <url>/2023/06/08/%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8BArray/</url>
    
    <content type="html"><![CDATA[<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><p>跟其他语言中的数组一样，ECMAScript 数组也是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以存储任意类型的数据。</p><p>ECMAScript 数组也是动态大小的，会随着数据添加而自动增长。</p><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用 Array 构造函数</span><br><span class="hljs-keyword">let</span> colors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>();<br><br><span class="hljs-comment">// 使用数组字面量</span><br><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>]; <span class="hljs-comment">// 创建一个包含 3 个元素的数组</span><br><span class="hljs-keyword">let</span> names = []; <span class="hljs-comment">// 创建一个空数组</span><br><span class="hljs-keyword">let</span> values = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,]; <span class="hljs-comment">// 创建一个包含 2 个元素的数组</span><br></code></pre></td></tr></table></figure><blockquote><p>与对象一样，在使用数组字面量表示法创建数组不会调用 Array 构造函数。</p></blockquote><p>Array 构造函数还有两个 ES6 新增的用于创建数组的静态方法：**from()和 of()**。</p><ul><li><p>from()用于将类数组结构转换为数组实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 字符串会被拆分为单字符数组</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;Matt&quot;</span>)); <span class="hljs-comment">// [&quot;M&quot;, &quot;a&quot;, &quot;t&quot;, &quot;t&quot;]</span><br><br><span class="hljs-comment">// 可以使用 from()将集合和映射转换为一个新数组</span><br><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>().<span class="hljs-title function_">set</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <br> .<span class="hljs-title function_">set</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>); <br><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>().<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>) <br> .<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>) <br> .<span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>) <br> .<span class="hljs-title function_">add</span>(<span class="hljs-number">4</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(m)); <span class="hljs-comment">// [[1, 2], [3, 4]] </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(s)); <span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><p>Array.from()还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像调用 Array.from().map()那样先创建一个中间数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]; <br>  <span class="hljs-keyword">const</span> a2 = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(a1, <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x**<span class="hljs-number">2</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a2); <span class="hljs-comment">// [1, 4, 9, 16]</span><br></code></pre></td></tr></table></figure></li><li><p>of()用于将一组参数转换为数组实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// [1, 2, 3, 4] </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-literal">undefined</span>)); <span class="hljs-comment">// [undefined]</span><br></code></pre></td></tr></table></figure></li></ul><p>复制和填充方法</p><p>ES6 新增了两个方法：**批量复制方法 copyWithin()，以及填充数组方法 fill()**。</p><p>使用 fill()方法可以向一个已有的数组中插入全部或部分相同的值。参数包括：填充值、开始索引（可选）、结束索引（可选）。负值索引从数组末尾开始计算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> zeroes = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];<br><br><span class="hljs-comment">// 用 5 填充整个数组</span><br>zeroes.<span class="hljs-title function_">fill</span>(<span class="hljs-number">5</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(zeroes); <span class="hljs-comment">// [5, 5, 5, 5, 5]</span><br><br><span class="hljs-comment">// 用 6 填充索引大于等于 3 的元素</span><br>zeroes.<span class="hljs-title function_">fill</span>(<span class="hljs-number">6</span>, <span class="hljs-number">3</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(zeroes); <span class="hljs-comment">// [0, 0, 0, 6, 6]</span><br><br><span class="hljs-comment">// 用 7 填充索引大于等于 1 且小于 3 的元素</span><br>zeroes.<span class="hljs-title function_">fill</span>(<span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(zeroes); <span class="hljs-comment">// [0, 7, 7, 0, 0];</span><br><br><span class="hljs-comment">// 用 8 填充索引大于等于 1 且小于 4 的元素</span><br>zeroes.<span class="hljs-title function_">fill</span>(<span class="hljs-number">8</span>, -<span class="hljs-number">4</span>, -<span class="hljs-number">1</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(zeroes); <span class="hljs-comment">// [0, 8, 8, 8, 0];</span><br></code></pre></td></tr></table></figure><blockquote><p>fill()静默忽略超出数组边界、零长度及方向相反的索引范围。</p></blockquote><p>copyWithin()会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与 fill()使用同样的计算方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> ints, <br> reset = <span class="hljs-function">() =&gt;</span> ints = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]; <br><span class="hljs-title function_">reset</span>();<br><br><span class="hljs-comment">// 从 ints 中复制索引 0 开始的内容，插入到索引 5 开始的位置</span><br><span class="hljs-comment">// 在源索引或目标索引到达数组边界时停止</span><br>ints.<span class="hljs-title function_">copyWithin</span>(<span class="hljs-number">5</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ints); <span class="hljs-comment">// [0, 1, 2, 3, 4, 0, 1, 2, 3, 4] </span><br><span class="hljs-title function_">reset</span>();<br><br><span class="hljs-comment">// 从 ints 中复制索引 5 开始的内容，插入到索引 0 开始的位置</span><br>ints.<span class="hljs-title function_">copyWithin</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ints); <span class="hljs-comment">// [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]</span><br><span class="hljs-title function_">reset</span>();<br><br><span class="hljs-comment">// 从 ints 中复制索引 0 开始到索引 3 结束的内容</span><br><span class="hljs-comment">// 插入到索引 4 开始的位置</span><br>ints.<span class="hljs-title function_">copyWithin</span>(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>); <br><span class="hljs-title function_">alert</span>(ints); <span class="hljs-comment">// [0, 1, 2, 3, 0, 1, 2, 7, 8, 9] </span><br><span class="hljs-title function_">reset</span>();<br><br><span class="hljs-comment">// JavaScript 引擎在插值前会完整复制范围内的值</span><br><span class="hljs-comment">// 因此复制期间不存在重写的风险</span><br>ints.<span class="hljs-title function_">copyWithin</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>); <br><span class="hljs-title function_">alert</span>(ints); <span class="hljs-comment">// [0, 1, 0, 1, 2, 3, 4, 5, 8, 9] </span><br><span class="hljs-title function_">reset</span>();<br></code></pre></td></tr></table></figure><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>所谓解构，就是将一个复杂数据类型分解为一个普通数据类型数据，ECMAScript 6 新添加功能 。可以对数组和对象进行解构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 不使用解构赋值</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">let</span> a = arr[<span class="hljs-number">0</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a) <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// 使用解构赋值</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">let</span> [a, b, c] = arr<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><ul><li>变量的数量大于单元值数量时，多余的变量将被赋值为 undefined</li><li>变量的数量小于单元值数量时，可以通过 … 获取剩余单元值，但只能置于最末位</li><li>允许初始化变量的默认值，且只有单元值为 undefined 时默认值才会生效</li></ul><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>JavaScript ES6 引入了新的扩展运算符 ( <code>...</code>) 以使代码更简单、更美观。</p><p>扩展运算符的主要作用是将一个数组转为用逗号分隔的参数序列。</p><p>以下是一些使用扩展运算符常见的应用场景</p><h3 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 不使用扩展运算符</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> arrCopy = arr; <br>arrCopy.<span class="hljs-title function_">push</span>(<span class="hljs-number">6</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1,2,3,4,5,6]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arrCopy); <span class="hljs-comment">// [1,2,3,4,5,6]</span><br><br><span class="hljs-comment">// 使用扩展运算符</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> arrCopy = [ ...arr];<br>arrCopy.<span class="hljs-title function_">push</span>(<span class="hljs-number">6</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1,2,3,4,5]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arrCopy); <span class="hljs-comment">// [1,2,3,4,5,6]</span><br></code></pre></td></tr></table></figure><h3 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> arr2 = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br><span class="hljs-keyword">const</span> arr3 = [<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br><span class="hljs-keyword">const</span> mergedArr = [...arr1, ...arr2, ...arr3];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mergedArr);<br><span class="hljs-comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></code></pre></td></tr></table></figure><h3 id="Math-min-和-Math-max"><a href="#Math-min-和-Math-max" class="headerlink" title="Math.min 和 Math.max"></a>Math.min 和 Math.max</h3><p>Math.min()都Math.max()不能接受 Array 参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> min = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">3</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(min); <span class="hljs-comment">// -3</span><br><br><span class="hljs-keyword">const</span> list = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">3</span>]; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(list)); <span class="hljs-comment">// NaN</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(list)); <span class="hljs-comment">// NaN</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(...list)); <span class="hljs-comment">// -3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...list)); <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><h3 id="字符串转换为字符列表"><a href="#字符串转换为字符列表" class="headerlink" title="字符串转换为字符列表"></a>字符串转换为字符列表</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> word = <span class="hljs-string">&quot;Coding&quot;</span>;<br><span class="hljs-keyword">const</span> arrOfChar = [...word];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arrOfChar); <span class="hljs-comment">// [&quot;C&quot;, &quot;o&quot;, &quot;d&quot;, &quot;i&quot;, &quot;n&quot;, &quot;g&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="删除重复项"><a href="#删除重复项" class="headerlink" title="删除重复项"></a>删除重复项</h3><p>结合本<code>Set</code>机对象，扩展运算符可用于删除数组中存在的任何重复项。初始化一个新数组，该新数组将<code>...new Set(arr)</code>具有唯一值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,<span class="hljs-string">&quot;books&quot;</span>,<span class="hljs-string">&quot;books&quot;</span>,<span class="hljs-string">&quot;books&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>];<br><span class="hljs-keyword">const</span> unique = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(unique);<br><span class="hljs-comment">// [1, 2, 3, 5, 8, true, &quot;books&quot;, null]</span><br></code></pre></td></tr></table></figure><h2 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h2><p>所有对象都有 toLocaleString()、toString()和 valueOf()方法。</p><ul><li>valueOf()   返回数组本身</li><li>toString()   返回每个值的等效字符串拼接而成的一个逗号分隔的字符串</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>]; <span class="hljs-comment">// 创建一个包含 3 个字符串的数组</span><br><span class="hljs-title function_">alert</span>(colors.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// red,blue,green </span><br><span class="hljs-title function_">alert</span>(colors.<span class="hljs-title function_">valueOf</span>()); <span class="hljs-comment">// red,blue,green</span><br></code></pre></td></tr></table></figure><blockquote><p>因为 alert()期待字符串，所以会在后台调用数组的 toString()方法，从而得到一样的结果。</p></blockquote><ul><li>toLocaleString()  返回得到一个逗号分隔的数组值的字符串</li></ul><p>这似乎和<code>toString() </code>没什么区别。不同的是为了得到最终的字符串，<code>toLocaleString()</code>会调用数组每个值的 <code>toLocaleString()</code>方法，而不是<code>toString()</code>。</p><p><code>toLocaleString()</code>以及<code>toString()</code>都返回数组值的逗号分隔的字符串。如果想使用不同的分隔符，则可以使用 <strong>join()方法</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>]; <br><span class="hljs-title function_">alert</span>(colors.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;,&quot;</span>)); <span class="hljs-comment">// red,green,blue </span><br><span class="hljs-title function_">alert</span>(colors.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;||&quot;</span>)); <span class="hljs-comment">// red||green||blue</span><br></code></pre></td></tr></table></figure><h2 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h2><p><code>ECMAScript</code> 数组提供了 <strong>push()和 pop()方法</strong>，以实现类似栈的行为。</p><ul><li>push()   接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。</li><li>pop()     则用于删除数组的最后一项，同时减少数组的 length 值，返回被删除的项。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>]; <br>colors.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;brown&quot;</span>); <span class="hljs-comment">// 再添加一项</span><br>colors[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;black&quot;</span>; <span class="hljs-comment">// 添加一项</span><br><span class="hljs-title function_">alert</span>(colors.<span class="hljs-property">length</span>); <span class="hljs-comment">// 4 </span><br><span class="hljs-keyword">let</span> item = colors.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 取得最后一项</span><br><span class="hljs-title function_">alert</span>(item); <span class="hljs-comment">// black</span><br></code></pre></td></tr></table></figure><h2 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h2><p>因为有了在数据末尾添加数据的 push()方法，所以要模拟队列就差一个从数组开头取得数据的方法和在数组开头添加值的方法。</p><ul><li>shift()        删除数组的第一项并返回它，然后数组长度减 1。</li><li>unshift()   在数组开头添加任意多个值，然后返回新的数组长度。</li></ul><p>使用 shift()和 push()，可以把数组当成队列来使用。</p><p>通过使用 unshift()和 pop()，可以在相反方向上模拟队列，即在数组开头添加新数据，在数组末尾取得数据。</p><h2 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h2><p>数组有两个方法可以用来对元素重新排序：reverse()和 sort()。</p><ul><li><p>reverse()  将数组元素反向排列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> values = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <br>values.<span class="hljs-title function_">reverse</span>(); <br><span class="hljs-title function_">alert</span>(values); <span class="hljs-comment">// 5,4,3,2,1</span><br></code></pre></td></tr></table></figure></li><li><p>sort()  按照升序重新排列数组元素，即最小的值在前面，最大的值在后面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> values = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>]; <br>values.<span class="hljs-title function_">sort</span>(); <br><span class="hljs-title function_">alert</span>(values); <span class="hljs-comment">// 0,1,10,15,5</span><br></code></pre></td></tr></table></figure><p>sort()会在每一项上调用 String()转型函数，然后比较字符串来决定顺序。但字符串形式排序数字时可能会违背数字本来的意思。</p><p>为此，sort()方法可以接收一个比较函数，用于判断哪个值应该排在前面。把返回值交换一下即可产生降序效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compare</span>(<span class="hljs-params">value1, value2</span>) &#123; <br> <span class="hljs-keyword">if</span> (value1 &lt; value2) &#123; <br> <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <br> &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value1 &gt; value2) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br> &#125; <span class="hljs-keyword">else</span> &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br> &#125; <br>&#125;<br><span class="hljs-comment">// 简写版本</span><br><span class="hljs-comment">// values.sort((a, b) =&gt; a &lt; b ? -1 : a &gt; b ? 1 : 0); </span><br><br><span class="hljs-keyword">let</span> values = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>]; <br>values.<span class="hljs-title function_">sort</span>(compare); <br><span class="hljs-title function_">alert</span>(values); <span class="hljs-comment">// 0,1,5,10,15</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><ul><li><p>concat()   复制原来数组在此基础之上添加元素，不改变原来数组，可以接受任意参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>]; <br><span class="hljs-keyword">let</span> colors2 = colors.<span class="hljs-title function_">concat</span>(<span class="hljs-string">&quot;yellow&quot;</span>, [<span class="hljs-string">&quot;black&quot;</span>, <span class="hljs-string">&quot;brown&quot;</span>]); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(colors); <span class="hljs-comment">// [&quot;red&quot;, &quot;green&quot;,&quot;blue&quot;] </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(colors2); <span class="hljs-comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;]</span><br></code></pre></td></tr></table></figure></li><li><p>slice()      创建一个包含原有数组中一个或多个元素的新数组，接收一个或两个参数：返回元素的开始索引和结束索引。返回数组中不</p></li><li><p>包含结束索引对应元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br><span class="hljs-comment">// 如果只有一个参数，则 slice()会返回该索引到数组末尾的所有元素</span><br>arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)<span class="hljs-comment">//[1,2,3,4,5,6,7,8,9]</span><br>arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,<span class="hljs-number">4</span>)<span class="hljs-comment">//[0,1,2,3]</span><br>arr.<span class="hljs-title function_">slice</span>(-<span class="hljs-number">5</span>,-<span class="hljs-number">2</span>)<span class="hljs-comment">//[5,6,7]</span><br></code></pre></td></tr></table></figure></li><li><p>splice()     较为全面的操作方法，此方法改变原数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>]; <br></code></pre></td></tr></table></figure><p>splice()方法始终返回这样一个数组，它包含从数组中被删除的元素（如果没有删除元素，则返回空数组）。</p><ul><li><p>删除，参数说明：参数1索引起始位置，参数2要删除的元素数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> removed = colors.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>); <span class="hljs-comment">// 删除第一项</span><br><span class="hljs-title function_">alert</span>(colors); <span class="hljs-comment">// green,blue </span><br><span class="hljs-title function_">alert</span>(removed); <span class="hljs-comment">// red，只有一个元素的数组</span><br></code></pre></td></tr></table></figure></li><li><p>插入 ，参数说明：参数1索引位置，参数2删除元素个数，参数3 要查入的元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// colors = [&quot;green&quot;, &quot;blue&quot;];  </span><br>removed = colors.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;yellow&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>); <span class="hljs-comment">// 在位置 1 插入两个元素</span><br><span class="hljs-title function_">alert</span>(colors); <span class="hljs-comment">// green,yellow,orange,blue </span><br><span class="hljs-title function_">alert</span>(removed); <span class="hljs-comment">// 空数组</span><br></code></pre></td></tr></table></figure></li><li><p>替换，参数说明：参数1索引位置，参数2删除元素个数，参数3+ 要查入的元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">removed = colors.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;purple&quot;</span>); <span class="hljs-comment">// 插入两个值，删除一个元素</span><br><span class="hljs-title function_">alert</span>(colors); <span class="hljs-comment">// green,red,purple,orange,blue </span><br><span class="hljs-title function_">alert</span>(removed); <span class="hljs-comment">// yellow，只有一个元素的数组</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="搜索和位置方法"><a href="#搜索和位置方法" class="headerlink" title="搜索和位置方法"></a>搜索和位置方法</h2><p><code>ECMAScript</code> 提供两类搜索数组的方法：按严格相等搜索和按断言函数搜索。</p><ul><li><p>严格相等</p><ul><li><p>indexOf()   从前搜索元素，查询到返回元素索引，没查询到返回-1，可以接受一个或两个参数，参数1要查询的元素，参数2查询开始的索引</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr=[<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>]<br>arr.<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">3</span>)<span class="hljs-comment">//-1</span><br>arr.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;E&#x27;</span>)<span class="hljs-comment">//4</span><br>arr.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-number">1</span>)<span class="hljs-comment">//2从索引1开始查询元素&#x27;C&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>lastIndexOf()  同indexOf用法相同，不同是从数组末尾开始查询</p></li><li><p>includes()        同indexOf用法相同返回结果为true和false</p></li></ul></li><li><p>断言函数</p><ul><li><p>find((element, index, array)&#x3D;&gt;{})     element：当前元素 index：当前元素的索引 array：数组 查询后就不在搜索</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arrObj=[&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;lly&quot;</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&quot;man&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-string">&quot;18&quot;</span>&#125;,&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;ly&quot;</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&quot;woman&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-string">&quot;18&quot;</span>&#125;]<br>arr.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">element, index, array</span>)=&gt;</span>&#123;<br>  element<span class="hljs-comment">//当前元素</span><br>  index<span class="hljs-comment">//当前元素的索引</span><br>  array<span class="hljs-comment">//数组</span><br>  &#125;)<span class="hljs-comment">//返回查询到元素</span><br></code></pre></td></tr></table></figure></li><li><p>findIndex()      同find用法相同返回查询到的元素的索引</p></li></ul></li></ul><h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><p>数组的 5 个迭代方法如下。</p><ul><li>every()：对数组每一项都运行传入的函数，如果对每一项函数都返回 true，则这个方法返回 true。</li><li>filter()：对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回。</li><li>forEach()：对数组每一项都运行传入的函数，没有返回值。</li><li>map()：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。</li><li>some()：对数组每一项都运行传入的函数，如果有一项函数返回 true，则这个方法返回 true。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 传给每个方法的函数接收 3个参数：数组元素、元素索引和数组本身。</span><br><span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]; <br><br><span class="hljs-keyword">let</span> everyResult = numbers.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">item, index, array</span>) =&gt;</span> item &gt; <span class="hljs-number">2</span>); <br><span class="hljs-title function_">alert</span>(everyResult); <span class="hljs-comment">// false </span><br><br><span class="hljs-keyword">let</span> filterResult = numbers.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item, index, array</span>) =&gt;</span> item &gt; <span class="hljs-number">2</span>); <br><span class="hljs-title function_">alert</span>(filterResult); <span class="hljs-comment">// 3,4,5,4,3</span><br><br>numbers.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index, array</span>) =&gt;</span> &#123; <br> <span class="hljs-comment">// 执行某些操作 </span><br>&#125;);<br><br><span class="hljs-keyword">let</span> mapResult = numbers.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item, index, array</span>) =&gt;</span> item * <span class="hljs-number">2</span>); <br><span class="hljs-title function_">alert</span>(mapResult); <span class="hljs-comment">// 2,4,6,8,10,8,6,4,2</span><br><br><span class="hljs-keyword">let</span> someResult = numbers.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">item, index, array</span>) =&gt;</span> item &gt; <span class="hljs-number">2</span>); <br><span class="hljs-title function_">alert</span>(someResult); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h2><p>ECMAScript 为数组提供了两个归并方法：reduce()和 reduceRight()。这两个方法都会迭代数组的所有项，并在此基础上构建一个最终返回值。</p><p>reduce()方法从数组第一项开始遍历到最后一项。而 reduceRight()从最后一项开始遍历至第一项。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> values = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <br><span class="hljs-comment">// prev是上一个值，cur是当前项，index是当前索引</span><br><span class="hljs-keyword">let</span> sum = values.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev, cur, index, array</span>) =&gt;</span> prev + cur); <br><span class="hljs-title function_">alert</span>(sum); <span class="hljs-comment">// 15</span><br></code></pre></td></tr></table></figure><p>第一次执行归并函数时，prev 是 1，cur 是 2。第二次执行时，prev 是 3（1 + 2），cur 是 3（数组第三项）。如此递进，直到把所有项都遍历一次，最后返回归</p><p>并结果。reduceRight()方法与之类似，只是方向相反。</p>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异步编程（二）async/await</title>
    <link href="/2023/05/22/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89async%E5%92%8Cawait/"/>
    <url>/2023/05/22/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89async%E5%92%8Cawait/</url>
    
    <content type="html"><![CDATA[<h1 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h1><p>ES8 的 async&#x2F;await 旨在解决利用异步结构组织代码的问题。</p><p>因为以前任何需要访问期约所产生值的代码，都需要以处理程序的形式来接收这个值。也就是说，代码始终需要放到处理程序里。</p><p>异步函数是将期约应用于 JavaScript 函数的结果。异步函数可以暂停执行，而不阻塞主线程。无论是编写基于期约的代码，还是组织串行或平行执行的异步代码，使用异步函数都非常得心应手。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handler</span>(<span class="hljs-params">x</span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); &#125; <br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>, <span class="hljs-number">3</span>)); <br>p.<span class="hljs-title function_">then</span>(handler); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h2 id="async关键字"><a href="#async关键字" class="headerlink" title="async关键字"></a>async关键字</h2><blockquote><p>async可以单独使用，await不能，await只能在async声明的函数内部使用，嵌套都不行，必须是直系</p></blockquote><p>这个关键字可以用在函数声明、函数表达式、箭头函数和方法上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;&#125; <br><span class="hljs-keyword">let</span> bar = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;; <br><span class="hljs-keyword">let</span> <span class="hljs-title function_">baz</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;&#125;; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Qux</span> &#123; <br><span class="hljs-keyword">async</span> <span class="hljs-title function_">qux</span>(<span class="hljs-params"></span>) &#123;&#125; <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>用async修饰了的函数或者方法就叫做异步函数，支持在内部使用await关键字</li><li>async异步函数期待是返回一个实现了thenable 的对象 (即Promise），如果实际返回值不是Promise，或者不支持.then会调用Promise.resolve()包装这个返回值</li><li>如果没有返回值，也没有await关键字，和正常情况一样全部同步执行</li></ul><h2 id="await关键字"><a href="#await关键字" class="headerlink" title="await关键字"></a>await关键字</h2><ul><li><p>可以暂停先异步函数又回来执行</p><blockquote><p>暂停包括await关键字后面的表达式和async函数在await后面的所有代码，async函数外面的代码可以先走，只有等到状态改变时才去异步队列取任务，然后取消时停，恢复进来</p></blockquote></li><li><p>await 关键字是尝试“解包”对象的值，然后将这个值传给表达式。（譬如将Promise.resolve(‘foo’)解包成‘foo’）</p></li><li><p>await 关键字期待一个实现 thenable 接口的对象，但常规的值也可以。如果是实现 thenable 接口的对象，则这个对象可以由 await 来“解包”。如果不是，则这个值就被当作已经解决的期约。</p></li><li><p>如果await 后面是一个已拒绝的promise或者await后面抛出异常，会直接返回一个已拒绝的promise，相当于异步捕获&#x2F;抛出了错误，await后面的语句就不会再执行了</p></li></ul><p>具体而言：</p><p>async包裹的函数体，执行到这个关键字await时，会暂停执行，把await修饰的对象放到一个异步执行队列。让出js的执行线程，去执行异步函数后面的同步任务，同步任务执行完之后，去异步队列按顺序取异步任务出来执行，当await修饰的异步任务达到完成状态时，时停结束往后走。执行异步函数后面的代码。</p><blockquote><p>await修饰的对象不是直接被添加到异步执行队列，是需要Promise状态落定后才会被添加到异步执行队列</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">5</span>))<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> <span class="hljs-number">7</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">8</span>)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br><span class="hljs-title function_">test1</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br><span class="hljs-title function_">test2</span>()<br><br><span class="hljs-comment">// 打印结果：1 2 3 4 5 6 7 8</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;第一次进来这里&#x27;</span>)<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;第二次进来&#x27;</span>)<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-number">5</span>)<br>        &#125;,<span class="hljs-number">4000</span>)<br>    &#125;))  <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> <span class="hljs-number">7</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">8</span>)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br><span class="hljs-title function_">test1</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br><span class="hljs-title function_">test2</span>()<br><br><span class="hljs-comment">// 打印结果：1 2 3 4 5 6 7 8</span><br></code></pre></td></tr></table></figure><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>睡觉函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-params">time</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-title function_">resolve</span>()<br>        &#125;,time)<br>    &#125;)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-number">5000</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;5秒之后执行&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大屏自适应</title>
    <link href="/2023/05/20/%E5%A4%A7%E5%B1%8F%E8%87%AA%E9%80%82%E5%BA%94%E6%96%B9%E6%A1%88/"/>
    <url>/2023/05/20/%E5%A4%A7%E5%B1%8F%E8%87%AA%E9%80%82%E5%BA%94%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="vw-vh"><a href="#vw-vh" class="headerlink" title="vw vh"></a>vw vh</h1><h2 id="思想和优缺点"><a href="#思想和优缺点" class="headerlink" title="思想和优缺点"></a>思想和优缺点</h2><p><strong>相对于视窗的宽、高</strong>，将设计稿尺寸，<strong>将px按照比例计算转为vw、vh</strong>。</p><ul><li><p>优点：不会出现留白的情况，能始终占满设备的屏幕</p></li><li><p>缺点：宽高比例会不一致，而且echarts的字体只支持px不能用vh、vw这种类似百分比的方法，所以要为eachars图表里的字体大小、间距等单独封装一个自适应函数。</p></li></ul><h2 id="预处理器实现"><a href="#预处理器实现" class="headerlink" title="预处理器实现"></a>预处理器实现</h2><p>sass-loader和less-loader在vue.config.js中配置</p><h3 id="sass"><a href="#sass" class="headerlink" title="sass"></a>sass</h3><p>1.新建util.scss 配置函数</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 使用 scss 的 math 函数，https://sass-lang.com/documentation/breaking-changes/slash-div</span><br><span class="hljs-keyword">@use</span> <span class="hljs-string">&quot;sass:math&quot;</span>;<br><br><span class="hljs-comment">// 默认设计稿的宽度</span><br><span class="hljs-variable">$designWidth</span>: <span class="hljs-number">1920</span>;<br><span class="hljs-comment">// 默认设计稿的高度</span><br><span class="hljs-variable">$designHeight</span>: <span class="hljs-number">1080</span>;+<br><br><span class="hljs-comment">// px 转为 vw 的函数</span><br><span class="hljs-keyword">@function</span> vw(<span class="hljs-variable">$px</span>) &#123;<br>  <span class="hljs-keyword">@return</span> math.div(<span class="hljs-variable">$px</span>, <span class="hljs-variable">$designWidth</span>) * <span class="hljs-number">100vw</span>;<br>&#125;<br><br><span class="hljs-comment">// px 转为 vh 的函数</span><br><span class="hljs-keyword">@function</span> vh(<span class="hljs-variable">$px</span>) &#123;<br>  <span class="hljs-keyword">@return</span> math.div(<span class="hljs-variable">$px</span>, <span class="hljs-variable">$designHeight</span>) * <span class="hljs-number">100vh</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.在<code>vue.config.js</code>里配置一下<code>utils.scss</code>的路径，就可以全局使用了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">css</span>: &#123;<br>    <span class="hljs-comment">// 全局配置 utils.scs，详细配置参考 vue-cli 官网</span><br>    <span class="hljs-attr">loaderOptions</span>: &#123;<br>      <span class="hljs-attr">sass</span>: &#123;<br>        <span class="hljs-attr">prependData</span>: <span class="hljs-string">`@import &quot;@/styles/utils.scss&quot;;`</span>,<br>      &#125;,<br>    &#125;,<br>  &#125;<br></code></pre></td></tr></table></figure><p>3.使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;style lang=<span class="hljs-string">&quot;scss&quot;</span> scoped=<span class="hljs-string">&quot;scoped&quot;</span>&gt;<br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> 直接使用 vw 和 vh 函数，将像素值传进去，得到的就是具体的 vw vh 单位 </span><br><span class="hljs-comment"> */</span><br>.<span class="hljs-property">box</span>&#123;<br>    <span class="hljs-attr">width</span>: <span class="hljs-title function_">vw</span>(<span class="hljs-number">300</span>);<br>    <span class="hljs-attr">height</span>: <span class="hljs-title function_">vh</span>(<span class="hljs-number">100</span>);<br>    font-<span class="hljs-attr">size</span>: <span class="hljs-title function_">vh</span>(<span class="hljs-number">16</span>);<br>    background-<span class="hljs-attr">color</span>: black;<br>    margin-<span class="hljs-attr">left</span>: <span class="hljs-title function_">vw</span>(<span class="hljs-number">10</span>);<br>    margin-<span class="hljs-attr">top</span>: <span class="hljs-title function_">vh</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-attr">border</span>: <span class="hljs-title function_">vh</span>(<span class="hljs-number">2</span>) solid red;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>1.新建util.less配置函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">@charset <span class="hljs-string">&quot;utf-8&quot;</span>;<br><br><span class="hljs-comment">// 默认设计稿的宽度</span><br>@<span class="hljs-attr">designWidth</span>: <span class="hljs-number">1920</span>;<br><br><span class="hljs-comment">// 默认设计稿的高度</span><br>@<span class="hljs-attr">designHeight</span>: <span class="hljs-number">1080</span>;<br><br>.<span class="hljs-title function_">px2vw</span>(<span class="hljs-params">@name, @px</span>) &#123;<br>  @&#123;name&#125;: (@px / @designWidth) * 100vw;<br>&#125;<br><br>.<span class="hljs-title function_">px2vh</span>(<span class="hljs-params">@name, @px</span>) &#123;<br>  @&#123;name&#125;: (@px / @designHeight) * 100vh;<br>&#125;<br><br>.<span class="hljs-title function_">px2font</span>(<span class="hljs-params">@px</span>) &#123;<br>  font-<span class="hljs-attr">size</span>: (@px / @designWidth) * 100vw;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.在<code>vue.config.js</code>里配置一下<code>utils.less</code>的路径，就可以全局使用了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">css</span>: &#123;<br>    <span class="hljs-comment">// 全局配置utils.scss</span><br>    <span class="hljs-attr">loaderOptions</span>: &#123;<br>      <span class="hljs-attr">less</span>: &#123;<br>        <span class="hljs-attr">additionalData</span>: <span class="hljs-string">`@import &quot;@/styles/utils.less&quot;;`</span>,<br>      &#125;,<br>    &#125;,<br>  &#125;。<br></code></pre></td></tr></table></figure><p>3.使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;style lang=<span class="hljs-string">&quot;less&quot;</span> scoped=<span class="hljs-string">&quot;scoped&quot;</span>&gt;<br>.<span class="hljs-property">box</span>&#123;<br>    .<span class="hljs-title function_">px2vw</span>(width, <span class="hljs-number">300</span>);<br>    .<span class="hljs-title function_">px2vh</span>(height, <span class="hljs-number">100</span>);<br>    .<span class="hljs-title function_">px2font</span>(<span class="hljs-number">16</span>);<br>    .<span class="hljs-title function_">px2vw</span>(margin-left, <span class="hljs-number">300</span>);<br>    .<span class="hljs-title function_">px2vh</span>(margin-top, <span class="hljs-number">100</span>);<br>    background-<span class="hljs-attr">color</span>: black;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h1 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h1><h2 id="思想和优缺点-1"><a href="#思想和优缺点-1" class="headerlink" title="思想和优缺点"></a>思想和优缺点</h2><p>rem是相对于<strong>根元素的大小</strong>来计算。根据视口大小动态的改变根元素的字体大小。</p><ul><li>优点：可以保持元素相对于根元素字体的大小比例</li><li>缺点：会有留白</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>1、利用 <code>postcss-pxtorem</code> 插件，在webpack打包的时候，将css中的px自动转成rem</p><p>2、动态修改html标签fontSize的大小</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> htmlDOM = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;html&#x27;</span>)[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">var</span> designWidth = <span class="hljs-number">1920</span> <span class="hljs-comment">// 设计稿的宽度  --- 已知</span><br><span class="hljs-keyword">var</span> designHtmlFontSize = <span class="hljs-number">100</span>; <span class="hljs-comment">// 设计稿上面的html font-size的大小  --- 已知</span><br><span class="hljs-keyword">var</span> actualHtmlFontSize; <span class="hljs-comment">// 实际html font-size的大小 --- 未知</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">setRootFontSize</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> viewportWidth = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientWidth</span>; <span class="hljs-comment">// 实际浏览器视口的宽度 ---- 已知</span><br>  actualHtmlFontSize = viewportWidth * designHtmlFontSize / designWidth; <span class="hljs-comment">// 3个已知条件，1个未知条件</span><br>  htmlDOM.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = actualHtmlFontSize + <span class="hljs-string">&#x27;px&#x27;</span>;<br>&#125;<br><br><span class="hljs-title function_">setRootFontSize</span>()<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;resize&quot;</span>, setRootFontSize)<br></code></pre></td></tr></table></figure><h1 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h1><h2 id="思想和优缺点-2"><a href="#思想和优缺点-2" class="headerlink" title="思想和优缺点"></a>思想和优缺点</h2><p>css的scale属性可以对图表进行整体的<strong>等比缩放</strong>。</p><ul><li>优点：能保持设计稿的比例</li><li>缺点：会有留白，但是留白也是因为他是等比缩放导致的；缩放比例过大时，字体会有一点点糊</li></ul><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>css的scale属性可以对图表进行整体的<strong>等比缩放</strong>。</p><ul><li>当<code>屏幕宽高比 &lt; 设计稿宽高比</code>，我们需要缩放的比例是<code>屏幕宽度 / 设计稿宽度</code></li><li>当<code>屏幕宽高比 &gt; 设计稿宽高比</code>，我们需要缩放的比例是<code>屏幕高度 / 设计稿高度</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> scale = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span> / <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span> &lt; designDraftWidth / designDraftHeight ?<br>            (<span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span> / designDraftWidth) :<br>            (<span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span> / designDraftHeight);<br><br></code></pre></td></tr></table></figure><p>当屏幕宽高比小于设计稿尺寸的，左右会留白；当屏幕宽高比大于设计稿尺寸的时候，上下会留白。</p><p>计算出缩放比例就可以</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">&quot;scale(&quot;</span>比例<span class="hljs-string">&quot;) translate(-50%)&quot;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自适应</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript函数（五）立即调用的函数表达式</title>
    <link href="/2023/05/17/JavaScript%E5%87%BD%E6%95%B0%EF%BC%88%E4%BA%94%EF%BC%89%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2023/05/17/JavaScript%E5%87%BD%E6%95%B0%EF%BC%88%E4%BA%94%EF%BC%89%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h1><ul><li>函数声明和函数表达式</li></ul><p>前面我们在<a href="https://airfe.gitee.io/blog/2023/05/11/JavaScript%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89/">JavaScript函数（一）函数定义</a>时提到过<strong>函数声明</strong>和<strong>函数表达式</strong>都是定义函数的一种方式。由于V8在编译阶段会把所有的变量装进作用域中（包括函数声明），所以函数声明有<strong>变量提升</strong>的特性，由于这个特性，所以函数声明可以出现在调用它的代码之后。</p><ul><li>圆括号运算符</li></ul><p>js有一个圆括号运算符，规定圆括号里面可以放一个表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">(a=<span class="hljs-number">3</span>) <span class="hljs-comment">// 这整个语句就是一个表达式</span><br></code></pre></td></tr></table></figure><p>举一反三，如果在括号里面放上一段函数的声明，函数声明也会被看做一个表达式！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//statements&#125;)</span><br></code></pre></td></tr></table></figure><p>因为小括号里面必须是表达式，如果小括号里面定义一个函数，那么V8就会把这个函数看成是函数表达式，执行时返回一个函数对象. 如果我们直接在表达式后面加上调用的括号，就称为<strong>立即调用函数表达式</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> sum = <span class="hljs-keyword">function</span>(<span class="hljs-params">num1, num2</span>) &#123; <br>    <span class="hljs-keyword">return</span> num1 + num2; <br>&#125;;<br><span class="hljs-title function_">sum</span>(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>);<br><span class="hljs-comment">//等价于：</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params">num1, num2</span>) &#123; <br>    <span class="hljs-keyword">return</span> num1 + num2; <br>&#125;)(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>个人对立即调用函数表达式（IIFE）的理解：</p><ul><li>与正常写法的函数表达式一样，不会有变量提升，这样函数和函数内部的变量都不会被其他部分的代码访问到，函数内部相当于模拟了一个块级作用域，不会污染变量环境。</li><li>形式上比起正常的调用函数表达式有一些简写。</li><li>即用即销。（函数执行一次，执行完其作用域链就可以销毁）</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异步编程（一）Promise</title>
    <link href="/2023/05/17/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89Promise/"/>
    <url>/2023/05/17/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89Promise/</url>
    
    <content type="html"><![CDATA[<h1 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h1><p>同步：对应内存中<strong>顺序执行</strong>的处理器指令。</p><p>异步：类似于系统中断，即当前进程 外部的实体可以触发代码执行。（异步代码内部还没执行，下面的同步代码已经执行了）</p><p>异步操作经常是必要的，因为强制进程等待一个长时间的操作通常是不可行的。</p><h1 id="以往的异步编程"><a href="#以往的异步编程" class="headerlink" title="以往的异步编程"></a>以往的异步编程</h1><p>异步代码的返回值，只能在异步代码执行结束之后调用回调函数传递。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">YiBu</span>(<span class="hljs-params">callback</span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>+<span class="hljs-number">1</span><br>        <span class="hljs-title function_">callback</span>(x)<br>    &#125;,<span class="hljs-number">1000</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">someFunc</span>(<span class="hljs-params">x</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)<br>&#125;<br><span class="hljs-title class_">YiBu</span>(someFunc)<br></code></pre></td></tr></table></figure><p>异步代码的异常处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">YiBu</span>(<span class="hljs-params">callback</span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>             <span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>+<span class="hljs-number">1</span><br>             <span class="hljs-title function_">callback</span>(x)<br>        &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>            <span class="hljs-comment">// 异常处理</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;出现问题啦&#x27;</span>)<br>        &#125;<br>    &#125;,<span class="hljs-number">1000</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">someFunc</span>(<span class="hljs-params">x</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)<br>&#125;<br><span class="hljs-title class_">YiBu</span>(someFunc)<br></code></pre></td></tr></table></figure><p>异步代码的嵌套（包括各级的异常处理）</p><p>嵌套层级的不断增加&#x3D;&#x3D;&#x3D;&gt;<strong>回调地域</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">YiBu</span>(<span class="hljs-params">callback</span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>             <span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>+<span class="hljs-number">1</span><br>             <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                 <span class="hljs-keyword">try</span>&#123;<br>                     <span class="hljs-title function_">callback</span>(x)<br>                 &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>                     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;出现问题2&#x27;</span>)<br>                 &#125;<br>             &#125;,<span class="hljs-number">2000</span>)<br>        &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>            <span class="hljs-comment">// 异常处理</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;出现问题1&#x27;</span>)<br>        &#125;<br>    &#125;,<span class="hljs-number">1000</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">someFunc</span>(<span class="hljs-params">x</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)<br>&#125;<br><span class="hljs-title class_">YiBu</span>(someFunc)<br></code></pre></td></tr></table></figure><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="什么是promise"><a href="#什么是promise" class="headerlink" title="什么是promise"></a>什么是promise</h2><p>是现在Javascript的一种常用优秀的异步解决方案，以前我们需要拿到异步代码的返回值，只能在异步代码里面调回调函数，如果回调函数里面又有异步代码就又有回调函数，不断的嵌套，就会形成俗称的回调地域。promise就可以很好地解决这个问题。</p><p>其他常用的异步方案还有async&#x2F;await。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 入参是一个执行器，返回一个默认为pending状态的promise实例</span><br><span class="hljs-comment">// 入参不填会报错 let a = new Promise()报错</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(  <span class="hljs-function">()=&gt;</span>&#123;&#125;  )<br></code></pre></td></tr></table></figure><p>期约的主要两大用途：知道异步代码的执行情况（状态）、实际生成某个值。</p><h2 id="promise状态"><a href="#promise状态" class="headerlink" title="promise状态"></a>promise状态</h2><p>每一个  Promise的实例都有一个状态，一共有三种状态。</p><ul><li>resolved（解决）</li><li>rejected（拒绝）</li><li>pending（待定）</li></ul><p>在待定状态下，期约可以落定为代表成功或者失败的状态，无论落定为哪种状态都是<strong>不可逆</strong>的。</p><p>在执行器函数内部调用内置的resolve()和reject()函数可以改变Promise的状态，同时也可以传递参数，这个参数就叫做<strong>解决值&#x2F;拒绝值</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;data&#x27;</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1) <span class="hljs-comment">// Promise &#123; &#x27;data&#x27; &#125;   此时已经是&lt;resolved&gt;状态</span><br></code></pre></td></tr></table></figure><blockquote><p>外部的同步代码无法读取或修改期约的状态，异步代码只能通过期约的方法（异步结构）与之交互。</p></blockquote><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>执行器的作用如下</p><ul><li><p>初始化Promise的行为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;初始化行为&#x27;</span>)<br>    <span class="hljs-comment">// 这里要做啥</span><br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>控制Promise的状态转换（通过调用两个函数参数实现）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;初始化行为&#x27;</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>+<span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-comment">//做完以后，让promise状态变为已解决</span><br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;这条代码已解决，我是解决值&#x27;</span>)<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a) <span class="hljs-comment">// 初始化行为  2  Promise&#123;&#x27;这条代码已解决&#x27;&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-comment">// 随便写个定时器</span><br>        <span class="hljs-comment">// 诶定时完了我让他变状态也可以</span><br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;我是解决值&#x27;</span>)<br>&#125;,<span class="hljs-number">200000</span>);<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 调接口拿值</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>    xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-function">() =&gt;</span>&#123;<br>        <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">readyState</span>!=<span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">readyState</span>==<span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> ==<span class="hljs-number">200</span>) &#123;<br>            <span class="hljs-comment">// 请求成功时改变Promise状态</span><br>            <span class="hljs-title function_">resolve</span>(xhr.<span class="hljs-property">responsetext</span>)  <span class="hljs-comment">//解决值</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 请求失败时改变Promise状态</span><br>            <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;服务器错误&#x27;</span>) <span class="hljs-comment">//拒绝值（拒绝原因）</span><br>        &#125;<br>    &#125;<br>    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>,url);<br>    xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br></code></pre></td></tr></table></figure></li><li><p>注意</p><p>执行器函数是其实是同步的，也就是说执行器函数的代码是会比new…后面的代码先执行的</p><p>但是执行器函数里面允许异步代码，比如resolve()、reject()、setTimeout()</p><blockquote><p>直接抛出异常可以理解为执行失败&#x3D;拒绝&#x3D;reject()，故执行器里面直接抛出错误外面的同步代码是捕获不到的，只能通过异步结构拿到。</p><p>可以理解为异步代码是由一个函数包裹住的，里面的参数外面的代码都拿不到，只有函数内（异步代码）才可以取得。</p></blockquote><p>来看下面的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// 只是一个执行器</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是来证明执行器是同步执行&#x27;</span>)<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise执行器里有一个异步代码&#x27;</span>)<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;哈哈&#x27;</span>)<br>&#125;,<span class="hljs-number">1000</span>);<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是同步代码&#x27;</span>)<br><br><span class="hljs-comment">// 打印结果：</span><br><span class="hljs-comment">// 我是来证明执行器是同步执行</span><br><span class="hljs-comment">// 我是同步代码</span><br><span class="hljs-comment">// promise执行器里有一个异步代码</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="解决值和拒绝值"><a href="#解决值和拒绝值" class="headerlink" title="解决值和拒绝值"></a>解决值和拒绝值</h2><p>每个期约只要状态切换为兑现，就会有一个私有的内部值（value）。状态切换为拒绝，就会有一个私有的内部理由（reason）。无论是值还是理由，都是包含原始值或对象的不可修改的引用。二者都是可选的，而且默认值为 undefined。</p><blockquote><p>比如，假设期约向服务器发送一个 HTTP 请求并预定会返回一个 JSON。如果请求返回范围在 200<del>299 的状态码，则足以让期约的状态变为兑现。此时期约内部就可以收到一个 JSON 字符串。类似地，如果请求返回的状态码不在 200</del>299 这个范围内，那么就会把期约状态切换为拒绝。此时拒绝的理由可能是一个 Error对象，包含着 HTTP 状态码及相关错误消息。</p></blockquote><p>到了落定状态后，期约会提供其解决值（如果兑现）或其拒绝理由（如果拒绝）给相关状态的处理程序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)); <br>p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)); <span class="hljs-comment">// foo </span><br><br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;bar&#x27;</span>)); <br>p2.<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason)); <span class="hljs-comment">// bar</span><br></code></pre></td></tr></table></figure><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><p><strong>创建</strong>一个已经解决的<strong>Promise</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p)  <span class="hljs-comment">// Promise &#123; 3 &#125;</span><br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p)<br></code></pre></td></tr></table></figure><p>入参是任意类型，返回值是一个Promise</p><p>转换规则：</p><ul><li><p>入参是基础数据类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1)  <span class="hljs-comment">// Promise &#123; 1 &#125;</span><br></code></pre></td></tr></table></figure><p>返回值：一个<strong>解决值</strong>为这个<strong>基础值</strong>的<strong>已解决</strong>的<strong>Promise</strong></p></li><li><p>入参就是一个Promise</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;)<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1)  <span class="hljs-comment">// Promise &#123;&lt;pengding&gt;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2)  <span class="hljs-comment">// Promise &#123;&lt;pengding&gt;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1===p2)  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>返回值：直接返回入参的<strong>Promise</strong></p></li><li><p>入参是一个异常</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;&#x27;</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p3)  <br><span class="hljs-comment">// Promise &#123;                                                                                     </span><br><span class="hljs-comment">//    Error                                                                                       </span><br><span class="hljs-comment">//        at Object.&lt;anonymous&gt; (D:\WebStorm\project\study\JS\期约与异步函数\src\异步函数.js:1:26)</span><br><span class="hljs-comment">//        at Module._compile (node:internal/modules/cjs/loader:1105:14)                           </span><br><span class="hljs-comment">//        at Object.Module._extensions..js (node:internal/modules/cjs/loader:1159:10)             </span><br><span class="hljs-comment">//        at Module.load (node:internal/modules/cjs/loader:981:32)                                </span><br><span class="hljs-comment">//        at Function.Module._load (node:internal/modules/cjs/loader:822:12)</span><br><span class="hljs-comment">//        at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:77:12)</span><br><span class="hljs-comment">//        at node:internal/main/run_main_module:17:47</span><br><span class="hljs-comment">//  &#125;</span><br></code></pre></td></tr></table></figure><p>返回值：一个<strong>解决值</strong>为<strong>这个异常</strong>的<strong>已解决</strong>的<strong>Promise</strong></p></li><li><p>多个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p4 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;),<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p4)  <span class="hljs-comment">// Promise &#123; 1 &#125;</span><br></code></pre></td></tr></table></figure><p>返回值：把第一个参数按照上述规则包装返回</p></li></ul><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><p>入参是任意类型，返回值是一个Promise</p><ul><li><p>入参是基础数据类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-number">1</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1)  <span class="hljs-comment">// Promise &#123; &lt;rejected&gt; 1 &#125;</span><br></code></pre></td></tr></table></figure><p>返回值：一个<strong>拒绝值</strong>为这个<strong>基础值</strong>的<strong>已拒绝</strong>的<strong>Promise</strong></p></li><li><p>入参就是一个Promise</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;)<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(p1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1)  <span class="hljs-comment">// Promise &#123;&lt;pengding&gt;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2)  <span class="hljs-comment">// Promise &#123; &lt;rejected&gt; Promise &#123; &lt;pending&gt; &#125; &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1===p2)  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>返回值：一个<strong>拒绝值</strong>为这个<strong>入参</strong>的<strong>已拒绝</strong>的<strong>Promise</strong></p></li><li><p>入参是一个异常</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;&#x27;</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p3)  <br><span class="hljs-comment">// Promise &#123;                                                                                     </span><br><span class="hljs-comment">//    &lt;rejected&gt;  Error                                                                                       </span><br><span class="hljs-comment">//        at Object.&lt;anonymous&gt; (D:\WebStorm\project\study\JS\期约与异步函数\src\异步函数.js:1:26)</span><br><span class="hljs-comment">//        at Module._compile (node:internal/modules/cjs/loader:1105:14)                           </span><br><span class="hljs-comment">//        at Object.Module._extensions..js (node:internal/modules/cjs/loader:1159:10)             </span><br><span class="hljs-comment">//        at Module.load (node:internal/modules/cjs/loader:981:32)                                </span><br><span class="hljs-comment">//        at Function.Module._load (node:internal/modules/cjs/loader:822:12)</span><br><span class="hljs-comment">//        at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:77:12)</span><br><span class="hljs-comment">//        at node:internal/main/run_main_module:17:47</span><br><span class="hljs-comment">//  &#125;</span><br></code></pre></td></tr></table></figure><p>返回值：一个<strong>拒绝值</strong>为这个<strong>入参</strong>的<strong>已拒绝</strong>的<strong>Promise</strong></p></li><li><p>多个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p4 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;),<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p4)  <span class="hljs-comment">// Promise &#123; 1 &#125;</span><br></code></pre></td></tr></table></figure><p>返回值：把第一个参数按照上述规则包装返回</p></li></ul><h3 id="Promise-race-、Promise-all"><a href="#Promise-race-、Promise-all" class="headerlink" title="Promise.race()、Promise.all()"></a>Promise.race()、Promise.all()</h3><p>Promise 类提供两个将多个期约实例组合成一个期约的静态方法：Promise.all()和 Promise.race()。而合成后期约的行为取决于内部期约的行为。</p><ul><li><p>入参：包含promise的可迭代对象（一般就是promise数组）</p></li><li><p>返回值：一个promise</p></li><li><p>状态改变：</p><ul><li>promise.race([xxx,xxx])什么时候改变状态，取决于入参哪个先改变状态。</li><li>promise.all([xxx,xxx])需要入参的所有promise<strong>都resolved</strong>解决之后才改变，有一个不是的话状态直接转变为rejected、pending</li></ul></li><li><p>应用：</p><p>接口超时拒绝</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;假装我是调一个接口&#x27;</span>)<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-comment">// 可能会花费一些时间</span><br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br>    &#125;,<span class="hljs-number">10000</span>)<br>&#125;)<br><br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-number">1</span>)<br>    &#125;,<span class="hljs-number">2000</span>)<br>&#125;)<br><br><span class="hljs-keyword">let</span> request = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([a,b])<br>request.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;接口没超时&#x27;</span>)<br>&#125;，res=&gt;&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;接口超时&#x27;</span>)       <br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p>期约实例的方法是连接外部同步代码与内部异步代码之间的桥梁。这些方法可以</p><ul><li>访问异步操作返回的数据</li><li>处理期约成功和失败的结果</li><li>连续对期约求值</li><li>添加只有期约进入终止状态时才会执行的代码</li></ul><h3 id="then"><a href="#then" class="headerlink" title=".then()"></a>.then()</h3><p>接收参数：两个，分别是<strong>onResolved</strong>和<strong>onRejected</strong>，分别代表这个Promise状态被解决的时候执行和被拒绝的时候被执行</p><p>返回值：一个Promise</p><p>入参规则：两个参数都可选。</p><ul><li>超过两个参数，自动忽略多余参数</li><li>入参类型不是函数也会被自动忽略</li><li>可以直传递第一个onResolved参数，不填第二个参数，处理成功的情况</li><li>但是如果想只传递一个onRejected处理程序，第一个<strong>不能不写</strong>，需要写个占位的空函数或其他无意义的非函数入参。</li></ul><blockquote><p>因为Promise只能转换为最终状态一次，故这两个参数对应的函数操作一定是互斥的。只会执行其中一个</p></blockquote><p>返回规则：</p><ul><li>入参两个都没填，就直接返回上一个promise</li><li>只传入了解决处理函数，返回一个已解决且解决值为处理函数的返回值的promise，如果处理函数返回值是一个promise，也直接返回这个promise</li><li>只传入了<strong>拒绝处理函数</strong>，返回一个已解决且解决值为处理函数的返回值的promise，如果处理函数返回值是一个promise，也直接返回这个promise</li></ul><blockquote><p>没有返回值（就是undefined）和返回显式的基础数据类型一样（包括异常），都是直接包装成一个已解决的并且解决值为这些基础数据类型的promise</p><p>onRejected的返回值包装成Promise的规则和onResolved包装规则是一样的</p></blockquote><h3 id="catch"><a href="#catch" class="headerlink" title=".catch"></a>.catch</h3><p>是onRejected的另一种写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;111&#x27;</span>)<br>&#125;)<br>a.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;啊啊啊，我被拒绝了&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 等同于</span><br>a.<span class="hljs-title function_">catch</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;啊啊啊，我被拒绝了&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="finally"><a href="#finally" class="headerlink" title=".finally"></a>.finally</h3><p>在promise转换为已拒绝或者已解决时都会执行，一般用于兜底、添加清理代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;111&#x27;</span>)<br>&#125;)<br><br>a.<span class="hljs-title function_">finally</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我走进来了，但是不知道是拒绝还是成功后走进来的&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>.finally的返回规则有些不一样，在大多数情况下（无返回值、已解决期约）它表现为父期约的传递，如果返回的是一个待定的期约，或者 onFinally 处理程序抛出了错误（显式抛出或返回了一个拒绝期约），则会返回相应的期约（待定或拒绝），如下所示：</p></blockquote><h3 id="非重入promise方法"><a href="#非重入promise方法" class="headerlink" title="非重入promise方法"></a>非重入promise方法</h3><p>是一个概念，当promise状态改变时对应的处理程序，比如onResolve、onRejected、.catch等不是立马被执行的，而是放到一个异步时事件队列中（先进先出），一般要这个队列的事件是在同步代码之后执行。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;第一个promise&#x27;</span>)<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br>&#125;)<br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;第二个promise&#x27;</span>)<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>)<br>&#125;)<br><span class="hljs-comment">// 先执行</span><br>a.<span class="hljs-title function_">then</span>((<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;第一个进来的&#x27;</span>)<br>&#125;))<br><span class="hljs-comment">// 后执行</span><br>b.<span class="hljs-title function_">then</span>((<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;第二个进来的&#x27;</span>)<br>&#125;))<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hhhh&#x27;</span>)<br><br><span class="hljs-comment">// 第一个promise</span><br><span class="hljs-comment">// 第二个promise                                   </span><br><span class="hljs-comment">// hhhh                                            </span><br><span class="hljs-comment">// 第一个进来的                                    </span><br><span class="hljs-comment">// 第二个进来的</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript函数（四）闭包</title>
    <link href="/2023/05/13/JavaScript%E5%87%BD%E6%95%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E9%97%AD%E5%8C%85/"/>
    <url>/2023/05/13/JavaScript%E5%87%BD%E6%95%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h1><p>闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。</p><blockquote><p>阮一峰理解的闭包：闭包就是能够读取其他函数内部变量的函数，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p></blockquote><p>闭包的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createComparisonFunction</span>(<span class="hljs-params">propertyName</span>) &#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">object1, object2</span>) &#123; <br>        <span class="hljs-keyword">let</span> value1 = object1[propertyName]; <br>        <span class="hljs-keyword">let</span> value2 = object2[propertyName]; <br>        <span class="hljs-keyword">if</span> (value1 &lt; value2) &#123; <br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value1 &gt; value2) &#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>        &#125; <br>    &#125;; <br>&#125;<br></code></pre></td></tr></table></figure><p>这里加粗的代码位于内部函数（匿名函数）中，其中引用了外部函数的变量 propertyName。</p><p>理解作用域链创建和使用的细节对理解闭包非常重要。</p><h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><p>无嵌套函数的作用域链</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compare</span>(<span class="hljs-params">value1, value2</span>) &#123; <br>    <span class="hljs-keyword">if</span> (value1 &lt; value2) &#123; <br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value1 &gt; value2) &#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>    &#125; <span class="hljs-keyword">else</span> &#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>    &#125; <br>&#125; <br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">compare</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230513145628355.png" alt="image-20230513145628355"></p><p>全局上下文中的叫变量对象，它会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，只在函数执行期间存在。</p><p>在定义一个函数时，就会为它创建作用域链，预装载<strong>全局变量对象</strong>，并保存在内部的[[Scope]]中。调用这个函数时，会创建相应的执行上下文，然后通过复制函数的[[Scope]]来创建其作用域链。接着会创建函数的<strong>活动对象</strong>（用作变量对象）并将其推入作用域链的前端。</p><p>compare()函数执行上下文的作用域链中有两个变量对象：局部活动对象（arguments、this和其他命名参数）和全局变量对象。</p><p>有嵌套函数的作用域链</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createComparisonFunction</span>(<span class="hljs-params">propertyName</span>) &#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">object1, object2</span>) &#123; <br>        <span class="hljs-keyword">let</span> value1 = object1[propertyName]; <br>        <span class="hljs-keyword">let</span> value2 = object2[propertyName]; <br>        <span class="hljs-keyword">if</span> (value1 &lt; value2) &#123; <br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value1 &gt; value2) &#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>        &#125; <br>    &#125;; <br>&#125;<br><br><span class="hljs-keyword">let</span> compare = <span class="hljs-title function_">createComparisonFunction</span>(<span class="hljs-string">&#x27;name&#x27;</span>); <br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">compare</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Nicholas&#x27;</span> &#125;, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Matt&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230513150123522.png" alt="image-20230513150123522"><p>内部函数的作用域链除了<strong>自身的活动对象</strong>和<strong>全局变量对象</strong>，还包括了<strong>外部函数的活动对象</strong>。</p><h1 id="闭包的副作用"><a href="#闭包的副作用" class="headerlink" title="闭包的副作用"></a>闭包的副作用</h1><p>仍然以上面的createComparisonFunction为例说明闭包的副作用。</p><p>闭包一个有意思的副作用就是，createComparisonFunction()的活动对象并不能在它执行完毕后销毁，因为匿名函数的作用域链中仍然有对它的引用。在 create-</p><p>ComparisonFunction()执行完毕后，其执行上下文的作用域链会销毁，但它的活动对象仍然会保留在内存中，直到匿名函数被销毁后才会被销毁。</p><p>手动销毁方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建比较函数</span><br><span class="hljs-keyword">let</span> compareNames = <span class="hljs-title function_">createComparisonFunction</span>(<span class="hljs-string">&#x27;name&#x27;</span>); <br><span class="hljs-comment">// 调用函数</span><br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">compareNames</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Nicholas&#x27;</span> &#125;, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Matt&#x27;</span> &#125;); <br><span class="hljs-comment">// 解除对函数的引用，这样就可以释放内存了</span><br>compareNames = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><blockquote><p>因为闭包会保留它们包含函数的作用域，所以比其他函数更占用内存。过度使用闭包可能导致内存过度占用，因此建议仅在十分必要时使用。V8 等优化的 JavaScript 引擎会努力回收被闭包困住的内存，不过我们还是建议在使用闭包时要谨慎。</p></blockquote><h1 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h1><p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> n=<span class="hljs-number">999</span>;<br>    nAdd=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;n+=<span class="hljs-number">1</span>&#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"></span>)&#123; 　<br>        <span class="hljs-title function_">alert</span>(n); 　　　<br>    &#125;<br>    <span class="hljs-keyword">return</span> f2;<br>&#125;<br><span class="hljs-keyword">var</span> result=<span class="hljs-title function_">f1</span>();<br><span class="hljs-title function_">result</span>(); <span class="hljs-comment">// 999</span><br><span class="hljs-title function_">nAdd</span>();<br><span class="hljs-title function_">result</span>(); <span class="hljs-comment">// 1000</span><br></code></pre></td></tr></table></figure><p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</p><p>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p><p>这段代码中另一个值得注意的地方，就是“nAdd&#x3D;function(){n+&#x3D;1}”这一行，首先在nAdd前面没有使用var关键字，因此 nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p><h1 id="闭包中的this"><a href="#闭包中的this" class="headerlink" title="闭包中的this"></a>闭包中的this</h1><p>我们曾经讨论在<a href="https://airfe.gitee.io/blog/2023/05/11/JavaScript%E5%87%BD%E6%95%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8/#%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7">函数内部</a>中讨论过如何判断 this 的绑定对象，但在闭包中使用this时可能会让人迷惑。</p><p>来看一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">identity</span> = <span class="hljs-string">&#x27;The Window&#x27;</span>; <br><span class="hljs-keyword">let</span> object = &#123; <br>    <span class="hljs-attr">identity</span>: <span class="hljs-string">&#x27;My Object&#x27;</span>, <br>    <span class="hljs-title function_">getIdentityFunc</span>(<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">identity</span>; <br>        &#125;; <br>    &#125; <br>&#125;; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(object.<span class="hljs-title function_">getIdentityFunc</span>()()); <span class="hljs-comment">// &#x27;The Window&#x27;</span><br></code></pre></td></tr></table></figure><p>为什么匿名函数没有使用其包含作用域（getIdentityFunc()）的 this 对象呢？的确，使用object调用getIdentityFunc时，getIdentityFunc内部的this应该为object。来看下面这个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">identity</span> = <span class="hljs-string">&#x27;The Window&#x27;</span>; <br><span class="hljs-keyword">let</span> object = &#123; <br>    <span class="hljs-attr">identity</span>: <span class="hljs-string">&#x27;My Object&#x27;</span>, <br>    <span class="hljs-comment">// this 等于object</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">identity</span>) <span class="hljs-comment">// My Object</span><br>    <span class="hljs-title function_">getIdentityFunc</span>(<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">identity</span>; <br>        &#125;; <br>    &#125; <br>&#125;; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(object.<span class="hljs-title function_">getIdentityFunc</span>()()); <span class="hljs-comment">// &#x27;The Window&#x27;</span><br></code></pre></td></tr></table></figure><p>前面提到过每个函数被调用时都会创建自己的局部活动对象（arguments、this其他命名参数），内部函数自身有的变量就不会去访问外部函数的变量。</p><p>内部函数的this一般默认规则：在严格模式下绑定到 undefined，否则绑定到全局对象。</p><p>如果我们仍然需要在内部函数中调用外部函数的tihs，可以通过下面这种巧妙的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">identity</span> = <span class="hljs-string">&#x27;The Window&#x27;</span>; <br><span class="hljs-keyword">let</span> object = &#123; <br>    <span class="hljs-attr">identity</span>: <span class="hljs-string">&#x27;My Object&#x27;</span>, <br>    <span class="hljs-title function_">getIdentityFunc</span>(<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-keyword">let</span> that = <span class="hljs-variable language_">this</span>; <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>            <span class="hljs-keyword">return</span> that.<span class="hljs-property">identity</span>; <br>        &#125;; <br>    &#125; <br>&#125;; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(object.<span class="hljs-title function_">getIdentityFunc</span>()()); <span class="hljs-comment">// &#x27;My Object&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>this 和 arguments 都是不能直接在内部函数中访问的。</p><p>如果想访问包含作用域中的 arguments 对象，则同样需要将其引用先保存到闭包能访问的另一个变量中。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript函数（三）尾调用优化</title>
    <link href="/2023/05/12/JavaScript%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96/"/>
    <url>/2023/05/12/JavaScript%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h2><p>尾调用是指函数作为另一个函数的最后一条语句被调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outerFunction</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">innerFunction</span>(); <span class="hljs-comment">// 尾调用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>ES5中在执行 innerFunction函数的时候会新增一个栈帧，outerFunction对应的栈帧会被保留在内存中，当存在循环调用时就容易出现程序问题，比如栈溢出等不可预期的错误。</p><h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><h3 id="优化原理"><a href="#优化原理" class="headerlink" title="优化原理"></a>优化原理</h3><ul><li><p>在 ES6 优化之前，开始的尾调用例子会在内存中发生如下操作。</p><p><strong>(1)</strong> 执行到 outerFunction 函数体，第一个栈帧被推到栈上。</p><p>(2) 执行 outerFunction 函数体，到 return 语句。计算返回值必须先计算 innerFunction。</p><p>**(3)**执行到 innerFunction 函数体，第二个栈帧被推到栈上。</p><p>(4) 执行 innerFunction 函数体，计算其返回值。</p><p>(5) 将返回值传回 outerFunction，然后 outerFunction 再返回值。</p><p>(6) 将栈帧弹出栈外。</p></li><li><p>在 ES6 优化之后，执行这个例子会在内存中发生如下操作。</p><p>(1) 执行到 outerFunction 函数体，第一个栈帧被推到栈上。</p><p>(2) 执行 outerFunction 函数体，到达 return 语句。为求值返回语句，必须先求值 innerFunction。</p><p><strong>(3)</strong> 引擎发现把第一个栈帧弹出栈外也没问题，因为 innerFunction 的返回值也是 outerFunction</p><p>的返回值。</p><p>(4) 弹出 outerFunction 的栈帧。</p><p>(5) 执行到 innerFunction 函数体，栈帧被推到栈上。</p><p>(6) 执行 innerFunction 函数体，计算其返回值。</p><p>(7) 将 innerFunction 的栈帧弹出栈外。</p></li></ul><p>很明显，第一种情况下每多调用一次嵌套函数，就会多增加一个栈帧。而第二种情况下无论调用多少次嵌套函数，都只有一个栈帧。</p><p>这就是 ES6 尾调用优化的关键：如果函数的逻辑允许基于尾调用将其销毁，则引擎就会那么做。</p><h3 id="优化条件"><a href="#优化条件" class="headerlink" title="优化条件"></a>优化条件</h3><p>尾调用优化的条件就是确定外部栈帧真的没有必要存在了。涉及的条件如下</p><ul><li>严格模式下</li><li>尾调用不访问当前栈帧的变量（也就是说函数不是一个闭包）</li><li>在函数内部，尾调用是最后一条语句</li><li>尾调用的结果作为函数值返回</li></ul><p>无优化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><br><span class="hljs-comment">// 无法优化，必须在返回值后添加其他操作</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+<span class="hljs-title function_">doSomethingElse</span>();<br>&#125;<br><br><span class="hljs-comment">// 无法优化，调用不在尾部</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> result = <span class="hljs-title function_">doSomethingElse</span>();<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 无法优化，func为闭包</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> num=<span class="hljs-number">1</span>, func = <span class="hljs-function">() =&gt;</span> num;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">func</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>有优化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&quot;use strict&quot;</span>; <br><span class="hljs-comment">// 有优化：栈帧销毁前执行参数计算</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">outerFunction</span>(<span class="hljs-params">a, b</span>) &#123; <br>     <span class="hljs-keyword">return</span> <span class="hljs-title function_">innerFunction</span>(a + b); <br>&#125; <br><span class="hljs-comment">// 有优化：初始返回值不涉及栈帧</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">outerFunction</span>(<span class="hljs-params">a, b</span>) &#123; <br>     <span class="hljs-keyword">if</span> (a &lt; b) &#123; <br>     <span class="hljs-keyword">return</span> a; <br>     &#125; <br>     <span class="hljs-keyword">return</span> <span class="hljs-title function_">innerFunction</span>(a + b); <br>&#125; <br><span class="hljs-comment">// 有优化：两个内部函数都在尾部</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">outerFunction</span>(<span class="hljs-params">condition</span>) &#123; <br>     <span class="hljs-keyword">return</span> condition ? <span class="hljs-title function_">innerFunctionA</span>() : <span class="hljs-title function_">innerFunctionB</span>(); <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化场景"><a href="#优化场景" class="headerlink" title="优化场景"></a>优化场景</h3><p>这个优化在递归场景下的效果是最明显的，因为递归代码最容易在栈内存中迅速产生大量栈帧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 不符合尾调用优化的条件 会给浏览器带来麻烦</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">n</span>) &#123; <br>     <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123; <br>         <span class="hljs-keyword">return</span> n; <br>     &#125; <br>     <span class="hljs-keyword">return</span> <span class="hljs-title function_">fib</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-title function_">fib</span>(n - <span class="hljs-number">2</span>); <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 符合尾调用优化的条件 不会对浏览器造成威胁</span><br><span class="hljs-meta">&quot;use strict&quot;</span>; <br><span class="hljs-comment">// 基础框架 </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">n</span>) &#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fibImpl</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, n); <br>&#125; <br><span class="hljs-comment">// 执行递归</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fibImpl</span>(<span class="hljs-params">a, b, n</span>) &#123; <br>    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) &#123; <br>        <span class="hljs-keyword">return</span> a; <br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fibImpl</span>(b, a + b, n - <span class="hljs-number">1</span>); <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript函数（一）函数定义</title>
    <link href="/2023/05/11/JavaScript%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89/"/>
    <url>/2023/05/11/JavaScript%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><ul><li>以函数声明的方式定义</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span> (num1, num2) &#123; <br>    <span class="hljs-keyword">return</span> num1 + num2; <br>&#125;  <span class="hljs-comment">// 注意最后没有分号。函数名就是指向函数对象的指针</span><br></code></pre></td></tr></table></figure><ul><li>函数表达式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> sum = <span class="hljs-keyword">function</span>(<span class="hljs-params">num1, num2</span>) &#123; <br>    <span class="hljs-keyword">return</span> num1 + num2; <br>&#125;; <span class="hljs-comment">// 注意最后有分号。function 关键字后面没有名称，因为不需要，这个函数可以通过变量 sum 来引用。</span><br></code></pre></td></tr></table></figure><ul><li>箭头函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">num1, num2</span>) =&gt; &#123; <br>    <span class="hljs-keyword">return</span> num1 + num2; <br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>使用Function构造函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">&quot;num1&quot;</span>, <span class="hljs-string">&quot;num2&quot;</span>, <span class="hljs-string">&quot;return num1 + num2&quot;</span>); <span class="hljs-comment">// 不推荐</span><br><span class="hljs-comment">// 代码会被解释两次：第一次是将它当作常规ECMAScript 代码，第二次是解释传给构造函数的字符串。这显然会影响性能。</span><br></code></pre></td></tr></table></figure><h2 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h2><p>JavaScript 引擎在加载数据时对这两种方式是区别对待的。</p><ul><li><p>函数声明的关键特点是函数声明提升，即函数声明会在代码执行之前获得定义。</p><p>这意味着函数声明可以出现在调用它的代码之后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">sayHi</span>(); <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hi!&quot;</span>); <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 会出错</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)); <br><span class="hljs-keyword">let</span> sum = <span class="hljs-keyword">function</span>(<span class="hljs-params">num1, num2</span>) &#123; <br>    <span class="hljs-keyword">return</span> num1 + num2; <br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><p>除了函数什么时候真正有定义这个区别之外，这两种语法是等价的。</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>很大程度上，箭头函数实例化的函数对象与正式的函数表达式创建的函数对象行为是相同的。任何可以使用函数表达式的地方，都可以使用箭头函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">arrowSum</span> = (<span class="hljs-params">a, b</span>) =&gt; &#123; <br>    <span class="hljs-keyword">return</span> a + b; <br>&#125;; <br><span class="hljs-keyword">let</span> functionExpressionSum = <span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) &#123; <br> <span class="hljs-keyword">return</span> a + b; <br>&#125;; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">arrowSum</span>(<span class="hljs-number">5</span>, <span class="hljs-number">8</span>)); <span class="hljs-comment">// 13 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">functionExpressionSum</span>(<span class="hljs-number">5</span>, <span class="hljs-number">8</span>)); <span class="hljs-comment">// 13</span><br></code></pre></td></tr></table></figure><p>参数：如果只有一个参数，那也可以不用括号；但没有参数，或者多个参数的情况下，必须使用括号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 以下两种写法都有效</span><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">double</span> = (<span class="hljs-params">x</span>) =&gt; &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * x; &#125;; <br><span class="hljs-keyword">let</span> <span class="hljs-title function_">triple</span> = x =&gt; &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> * x; &#125;; <br><span class="hljs-comment">// 没有参数需要括号</span><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">getRandom</span> = (<span class="hljs-params"></span>) =&gt; &#123; <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>(); &#125;; <br><span class="hljs-comment">// 多个参数需要括号</span><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">a, b</span>) =&gt; &#123; <span class="hljs-keyword">return</span> a + b; &#125;; <br><span class="hljs-comment">// 无效的写法：</span><br><span class="hljs-keyword">let</span> multiply = a, <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> &#123; <span class="hljs-keyword">return</span> a * b; &#125;;<br></code></pre></td></tr></table></figure><p>函数体：箭头函数体如果只有<strong>一行</strong>代码，可以<strong>不用大括号</strong>包裹。而且，省略大括号会隐式返回这行代码的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 以下两种写法都有效，而且返回相应的值</span><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">double</span> = (<span class="hljs-params">x</span>) =&gt; &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * x; &#125;; <br><span class="hljs-keyword">let</span> <span class="hljs-title function_">triple</span> = (<span class="hljs-params">x</span>) =&gt; <span class="hljs-number">3</span> * x;<br><span class="hljs-comment">// 无效的写法：</span><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">multiply</span> = (<span class="hljs-params">a, b</span>) =&gt; <span class="hljs-keyword">return</span> a * b;<br></code></pre></td></tr></table></figure><p>箭头函数虽然语法简洁，但也有很多场合不适用。</p><p>箭头函数不能使用 arguments、super 和 new.target，也不能用作构造函数。此外，箭头函数也没有 prototype 属性。</p>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript函数（二）函数内部</title>
    <link href="/2023/05/11/JavaScript%E5%87%BD%E6%95%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8/"/>
    <url>/2023/05/11/JavaScript%E5%87%BD%E6%95%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h1><p>函数内部存在特殊的对象：arguments 、this、caller、new.target （ES6新增）属性。</p><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p>是一个类数组对象，包含调用函数时<strong>传入的所有参数</strong>。arguments对象的值始终会与对应的命名参数<strong>同步</strong>。</p><blockquote><p>可以使用中括号语法访问其中的元素（第一个参数是 arguments[0]，第二个参数是 arguments[1]，….）。</p><p>这个对象只有以function 关键字定义函数（即非箭头语法创建函数）时才会有。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doAdd</span>(<span class="hljs-params">num1, num2</span>) &#123; <br>    <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">10</span>; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] + num2);  <span class="hljs-comment">// num2的值被修改为10</span><br>&#125;<br></code></pre></td></tr></table></figure><p>属性：</p><ul><li><p>length： arguments.length是传入的参数个数</p></li><li><p>callee ：arguments.calllee指向arguments对象所在函数，可以让<strong>函数逻辑和函数名解耦</strong>.</p><p>典型例子（递归函数）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 未解耦前</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">num</span>) &#123; <br>    <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) &#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>    &#125; <span class="hljs-keyword">else</span> &#123; <br>        <span class="hljs-keyword">return</span> num * <span class="hljs-title function_">factorial</span>(num - <span class="hljs-number">1</span>); <br>    &#125; <br>&#125;<br><span class="hljs-keyword">let</span> anotherFactorial = factorial; <br>factorial = <span class="hljs-literal">null</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">anotherFactorial</span>(<span class="hljs-number">4</span>)); <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 解耦后</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">num</span>) &#123; <br>    <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) &#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>    &#125; <span class="hljs-keyword">else</span> &#123; <br>        <span class="hljs-keyword">return</span> num * <span class="hljs-variable language_">arguments</span>.<span class="hljs-title function_">callee</span>(num - <span class="hljs-number">1</span>); <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><blockquote><p>this在标准函数和箭头函数中有不同的行为。</p></blockquote><ul><li><p>在标准函数中，this 引用的是把函数当成方法调用的上下文对象。如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的<strong>直接调用位置</strong>。找到之后就可以顺序应用下面这四条规则来判断 this 的绑定对象。</p><ul><li>由 new 调用？绑定到新创建的对象。</li><li>由 call 或者 apply（或者 bind）调用？绑定到指定的对象。</li><li>由上下文对象调用？绑定到那个上下文对象。</li><li>默认：在严格模式下绑定到 undefined，否则绑定到全局对象。</li></ul></li><li><p>ES6 中的箭头函数根据当前的词法作用域来决定this。</p><p>ES6 中的箭头函数并不会使用四条标准的绑定规则，具体来说，箭头函数会<strong>继承外层函数调用的 this 绑定</strong>（无论 this 绑定到什么）。</p></li></ul><h2 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h2><p>这个属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则为 null。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-title function_">inner</span>(); <br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(inner.<span class="hljs-property">caller</span>); <br>&#125; <br><span class="hljs-title function_">outer</span>();<br><span class="hljs-comment">// 以上代码会显示 outer()函数的源代码。这是因为 ourter()调用了 inner()，inner.caller指向 outer()。</span><br></code></pre></td></tr></table></figure><h2 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h2><p>ECMAScript 中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。</p><p>ECMAScript 6 新增了检测函数是否使用 new 关键字调用的 new.target 属性。如果函数是正常调用的，则 new.target 的值是 undefined；如果是使用 new 关键字调用的，则 new.target 将引用被调用的构造函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">King</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>) &#123; <br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;King must be instantiated using &quot;new&quot;&#x27;</span> <br>    &#125; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;King instantiated using &quot;new&quot;&#x27;</span>); <br>&#125; <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">King</span>(); <span class="hljs-comment">// King instantiated using &quot;new&quot; </span><br><span class="hljs-title class_">King</span>(); <span class="hljs-comment">// Error: King must be instantiated using &quot;new&quot;</span><br></code></pre></td></tr></table></figure><h1 id="函数方法"><a href="#函数方法" class="headerlink" title="函数方法"></a>函数方法</h1><p>ECMAScript 中的函数是对象，因此有属性和方法。每个函数都有两个属性：length和 prototype。其中，length 属性保存函数定义的命名参数的个数，prototype 保存引用类型所有实例方法的地方，这意味着 toString()、valueOf()等方法实际上都保存在 prototype 上，进而由所有实例共享。</p><p>函数还有两个方法：apply()和 call()。</p><h2 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h2><p>接收两个参数：函数内 this 的值和一个参数数组。第二个参数可以是 <strong>Array 实例</strong>，但也可以是 <strong>arguments 对象</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1, num2</span>) &#123; <br>    <span class="hljs-keyword">return</span> num1 + num2; <br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">callSum1</span>(<span class="hljs-params">num1, num2</span>) &#123; <br>    <span class="hljs-keyword">return</span> sum.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>); <span class="hljs-comment">// 传入arguments对象</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">callSum1</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)); <span class="hljs-comment">// 20，本例中this等于window</span><br></code></pre></td></tr></table></figure><h2 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h2><p> 第一个参数跟 apply()一样，也是 this值，而剩下的要传给被调用函数的参数则是逐个传递的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1, num2</span>) &#123; <br>    <span class="hljs-keyword">return</span> num1 + num2; <br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">callSum</span>(<span class="hljs-params">num1, num2</span>) &#123; <br> <span class="hljs-keyword">return</span> sum.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, num1, num2); <br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">callSum</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)); <span class="hljs-comment">// 20</span><br></code></pre></td></tr></table></figure><blockquote><p>换句话说，通过 call()向函数传参时，必须将参数一个一个地列出来</p></blockquote><p>对函数而言，继承的方法 toLocaleString()和 toString()始终返回函数的代码、 valueOf()返回函数本身。</p>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟滚动</title>
    <link href="/2023/05/10/%E8%99%9A%E6%8B%9F%E6%BB%9A%E5%8A%A8/"/>
    <url>/2023/05/10/%E8%99%9A%E6%8B%9F%E6%BB%9A%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><p>通过<strong>局部渲染列表</strong>，每次只渲染可视区域的DOM节点，来大大提升页面响应速度。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>监听用户的滚动操作，在回调里面去更新渲染列表项。更新的关键就是去计算出可视区域列表的起始索引和结束索引，就可以指定要渲染的列表项了。</p><ul><li>起始索引，可以直接通过滚动条的当前偏移量（scrollTop）除以列表项的高度得到。表项的高度是已知的，向下取整数（Math.floor）得到。</li><li>结束索引，起始索引加上容器可以展示的条数得到。容器可以展示的条数通过可视高度（offsetHeight）除以列表项高度取整可以拿到。但是计算结束索引的时候要判断一下有没有超出，超出的话就说明最后一页了，索引直接就是列表长度-1就可以。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> scrollTop = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 初始滚动距离</span><br><span class="hljs-comment">// 滚动事件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleScroll</span> = (<span class="hljs-params">e: Event</span>) =&gt; &#123;<br>  <span class="hljs-comment">// 获取滚动距离</span><br>  scrollTop.<span class="hljs-property">value</span> = (e.<span class="hljs-property">target</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLElement</span>).<span class="hljs-property">scrollTop</span>;<br>  <span class="hljs-comment">// 初始索引 = 滚动距离 / 每一项的高度</span><br>  <span class="hljs-keyword">const</span> startIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(scrollTop.<span class="hljs-property">value</span> / itemHeight.<span class="hljs-property">value</span>);<br>  <span class="hljs-comment">// 结束索引 = 初始索引 + 容器高度 / 每一项的高度</span><br>  <span class="hljs-keyword">const</span> endIndex = startIndex + viewHeight.<span class="hljs-property">value</span> / itemHeight.<span class="hljs-property">value</span>;<br>  <span class="hljs-comment">// 根据初始索引和结束索引，截取数据</span><br>  showData.<span class="hljs-property">value</span> = data.<span class="hljs-title function_">slice</span>(startIndex, endIndex);<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(showData.<span class="hljs-property">value</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>为了避免页面显示和实际滚动有区别，需要将展示数据的容器永远向下偏移滚动条的高度,(或者使用paddingTop)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div<br>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;item-container&quot;</span><br>  :style=<span class="hljs-string">&quot;&#123;</span><br><span class="hljs-string">          transform: &#x27;translateY(&#x27; + scrollTop + &#x27;px)&#x27;,</span><br><span class="hljs-string">        &#125;&quot;</span><br>&gt;<br></code></pre></td></tr></table></figure><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>避免滚动触发频率过高</p><h3 id="列表缓存"><a href="#列表缓存" class="headerlink" title="列表缓存"></a>列表缓存</h3><p>在可视元素列表前后预先<strong>多渲染几个列表元素</strong>。这样我们在少量滚动时可以偏移这些已渲染的元素而不是重新渲染，当滚动量超过缓存元素时，再进行重新渲染。</p><ol><li>为可视元素列表前后加入缓冲元素。</li><li>在滚动量比较小时，直接修改可视元素列表的偏移量。</li><li>在滚动量比较大时（比如拖动滚动条），会重新渲染整个列表。</li></ol>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>长列表性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>垃圾回收机制</title>
    <link href="/2023/05/07/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/05/07/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收机制（GC）"><a href="#垃圾回收机制（GC）" class="headerlink" title="垃圾回收机制（GC）"></a>垃圾回收机制（GC）</h1><p>JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><strong>内存的生命周期</strong></p><ul><li>内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存</li><li>内存使用：即读写内存，也就是使用变量、函数等</li><li>内存回收：使用完毕，由垃圾回收器自动回收不再使用的内存</li></ul><p><strong>说明：</strong></p><ul><li>全局变量一般不会回收（关闭页面回收）</li><li>一般情况下局部变量的值，不用了会被自动回收掉</li></ul><p><strong>内存泄露</strong>：程序中分配的内存由于某种原因程序未释放或无法释放叫做内存泄漏</p><p><strong>堆栈空间分配区别:</strong></p><ul><li>栈(操作系统) : 由操作系统自动分配释放函数的参数值、局部变量等，基本数据类型放到栈里面。</li><li>堆(操作系统) :一般由程序员分配释放,若程序员不释放，由<strong>垃圾回收机制</strong>回收。复杂数据类型放到堆里面。</li></ul><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>IE采用的引用计数算法，定义“内存不再使用”，就是看一个对象是否有指向它的引用，没有引用了就回收对象。</p><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><ul><li>跟踪记录被引用的次数</li><li>如果被引用了一次，那么就记录次数1,多次引用会累加++</li><li>如果减少一个引用就减1</li><li>垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr=[<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>，<span class="hljs-number">4</span>] <span class="hljs-comment">// arr指向一个地址（存放在栈），地址引用数组（存放在堆）。此时数组引用次数是1</span><br>arr = <span class="hljs-literal">null</span> <span class="hljs-comment">// 数组引用次数变成0，被自动回收</span><br></code></pre></td></tr></table></figure> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">age</span>:<span class="hljs-number">18</span>,<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;佩奇&#x27;</span>   <span class="hljs-comment">// 此时对象的引用次数为1</span><br>&#125;  <br><span class="hljs-keyword">let</span> p = person   <span class="hljs-comment">// p指向地址——&gt;对象，对象的引用次数为2</span><br>person = <span class="hljs-number">1</span>       <span class="hljs-comment">// person的地址改变为值，相当于没有地址了，对象引用次数为减1</span><br>p = <span class="hljs-literal">null</span>         <span class="hljs-comment">// p也无地址指向对象，对象的引用次数又减1，变为0被回收</span><br></code></pre></td></tr></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>但它存在一个致命的问题：<strong>嵌套引用</strong>（循环引用）</p><p>即如果两个对象<strong>相互引用</strong>，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> o1= &#123;&#125;<br>    <span class="hljs-keyword">let</span> o2= &#123;&#125;<br>    o1.<span class="hljs-property">a</span> = o2<br>    o2.<span class="hljs-property">a</span> = o1<br>    <span class="hljs-keyword">return</span> ‘引用计数无法回收<span class="hljs-string">&#x27;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">fn()</span><br></code></pre></td></tr></table></figure><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230507145658078.png" alt="image-20230507145658078" style="zoom:80%;"><p>另外一个缺点是，它需要一个计数器，而此计数器需要占很大的位置，因为我们也不知道被引用数量的上限。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>引用计数算法的优点我们对比标记清除来看就会清晰很多，首先引用计数在引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾，而标记清除算法需要每隔一段时间进行一次，那在应用程序（JS脚本）运行过程中线程就必须要暂停去执行一段时间的 <code>GC</code>。</p><p>标记清除算法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数就可以了。</p><h2 id="标记清理法"><a href="#标记清理法" class="headerlink" title="标记清理法"></a>标记清理法</h2><h3 id="核心-1"><a href="#核心-1" class="headerlink" title="核心"></a>核心</h3><ul><li>标记清除算法将“不再使用的对象”定义为”无法达到的对象”。</li><li>就是从根部(在JS中就是全局对象)出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。</li><li>那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。</li></ul><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230508095946941.png" alt="image-20230508095946941"></p><blockquote><p>从根部扫描对象，能查找到的就是使用的，查找不到的就要回收</p></blockquote><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 <code>内存碎片</code>，并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题</p><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230508143704041.png" alt="image-20230508143704041"></p><p>若新建对象分配内存时需要大小为 <code>size</code>，由于空闲内存是间断的、不连续的，则需要对空闲内存列表进行一次单向遍历找出大于等于 <code>size</code> 的块才能为其分配</p><p>一般有三种分配策略</p><ul><li><code>First-fit</code>，找到大于等于 <code>size</code> 的块立即返回</li><li><code>Best-fit</code>，遍历整个空闲列表，返回大于等于 <code>size</code> 的最小分块</li><li><code>Worst-fit</code>，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 <code>size</code> 大小，并将该部分返回</li></ul><p>这三种策略里面 <code>Worst-fit</code> 的空间利用率看起来是最合理，但实际上切分之后会造成更多的小块，形成内存碎片，所以不推荐使用，对于 <code>First-fit</code> 和 <code>Best-fit</code> 来说，考虑到分配的速度和效率 <code>First-fit</code> 是更为明智的选择。</p><p>综上所述，标记清理法</p><ul><li><strong>内存碎片化</strong>，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块</li><li><strong>分配速度慢</strong>，因为即便是使用 <code>First-fit</code> 策略，其操作仍是一个 <code>O(n)</code> 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢。</li></ul><p><strong>PS：标记清除算法的缺点补充</strong></p><p>归根结底，标记清除算法的缺点在于清除之后剩余的对象位置不变而导致的空闲内存不连续， <strong>标记整理（Mark-Compact）算法</strong> 就可以有效地解决这个问题，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>标记清除算法的优点只有一个，那就是实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0和1）就可以为其标记，非常简单。</p><h2 id="V8对GC的优化"><a href="#V8对GC的优化" class="headerlink" title="V8对GC的优化"></a>V8对GC的优化</h2><h3 id="分代式垃圾回收"><a href="#分代式垃圾回收" class="headerlink" title="分代式垃圾回收"></a>分代式垃圾回收</h3><p>我们上面所说的垃圾清理算法在每次垃圾回收时都要检查内存中所有的对象，这样的话对于一些大、老、存活时间长的对象来说同新、小、存活时间短的对象一个频率的检查很不好，因为前者需要时间长并且不需要频繁进行清理，后者恰好相反，怎么优化这点呢？？？分代式就来了</p><p>V8 中将堆内存分为<strong>新生代和老生代</strong>两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收</p><ul><li>新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 <code>1～8M</code> 的容量</li><li>老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大</li></ul><p>对于新老两块内存区域的垃圾回收，V8 采用的是不同的回收机制及频率，提高了垃圾回收机制的效率。</p><h3 id="并行回收-Parallel"><a href="#并行回收-Parallel" class="headerlink" title="并行回收(Parallel)"></a>并行回收(Parallel)</h3><p>我们都知道 <code>JavaScript</code> 是一门单线程的语言，它是运行在主线程上的，那在进行垃圾回收时就会阻塞 <code>JavaScript</code> 脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，我们把这种行为叫做 <code>全停顿</code>。比如一次 <code>GC</code> 需要 <code>60ms</code> ，那我们的应用逻辑就得暂停 <code>60ms</code> ，假如一次 <code>GC</code> 的时间过长，对用户来说就可能造成页面卡顿等问题。</p><p>所谓并行，也就是同时的意思，它指的是垃圾回收器在主线程上执行的过程中，开启多个辅助线程，同时执行同样的回收工作。</p><p>新生代对象空间就采用并行策略，在执行垃圾回收的过程中，会启动了多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域，这个过程中由于数据地址会发生改变，所以还需要同步更新引用这些对象的指针，此即并行回收。</p><h3 id="增量标记与懒性清理"><a href="#增量标记与懒性清理" class="headerlink" title="增量标记与懒性清理"></a>增量标记与懒性清理</h3><p>我们上面所说的并行策略虽然可以增加垃圾回收的效率，对于新生代垃圾回收器能够有很好的优化，但是其实它还是一种全停顿式的垃圾回收方式，对于老生代来说，它的内部存放的都是一些比较大的对象，对于这些大的对象 <code>GC</code> 时哪怕我们使用并行策略依然可能会消耗大量时间。</p><p>所以为了减少全停顿的时间，在 2011 年，V8 对老生代的标记进行了优化，从全停顿标记切换到<strong>增量标记</strong>。</p><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230510134729424.png" alt="image-20230510134729424"></p><p>增量标记其实只是对活动对象和非活动对象进行标记，对于真正的清理释放内存 V8 采用的是<strong>惰性清理(Lazy Sweeping)</strong></p><p>增量标记完成后，惰性清理就开始了。当增量标记完成后，假如当前的可用内存足以让我们快速的执行代码，其实我们是没必要立即清理内存的，可以将清理过程稍微延迟一下，让 <code>JavaScript</code> 脚本代码先执行，也无需一次性清理完所有非活动对象内存，可以按需逐一进行清理直到所有的非活动对象内存都清理完毕，后面再接着执行增量标记</p><p>优缺点</p><p>优：使得主线程的停顿时间大大减少，让用户与浏览器交互的过程变得更加流畅。</p><p>缺：但是由于每个小的增量标记之间执行了 <code>JavaScript</code> 代码，堆中的对象指针可能发生了变化，需要使用写屏障技术来记录这些引用关系的变化，所以增量标记缺点也很明显：首先是并没有减少主线程的总暂停的时间，甚至会略微增加，其次由于写屏障机制的成本，增量标记可能会降低应用程序的吞吐量。</p><h3 id="并发回收-Concurrent"><a href="#并发回收-Concurrent" class="headerlink" title="并发回收(Concurrent)"></a>并发回收(Concurrent)</h3><p>并发回收了，它指的是主线程在执行 <code>JavaScript</code> 的过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起。</p><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230510135159023.png" alt="image-20230510135159023"></p><p>辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起，这是并发的优点，但同样也是并发回收实现的难点，因为它需要考虑主线程在执行 <code>JavaScript </code> 时，堆中的对象引用关系随时都有可能发生变化，这时辅助线程之前做的一些标记或者正在进行的标记就会要有所改变，所以它需要额外实现一些读写锁机制来控制。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>V8 的垃圾回收策略主要基于分代式垃圾回收机制，这我们说过，关于新生代垃圾回收器，我们说使用<strong>并行回收</strong>可以很好的增加垃圾回收的效率。在老生代垃圾回收器中则融合使用几种策略。老生代主要使用并发标记，主线程在开始执行 <code>JavaScript</code> 时，辅助线程也同时执行标记操作（标记操作全都由辅助线程完成）标记完成之后，再执行并行清理操作（主线程在执行清理操作时，多个辅助线程也同时执行清理操作）同时，清理的任务会采用增量的方式分批在各个 <code>JavaScript</code> 任务之间执行。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><p>《Javascript 高级程序设计(第 4 版)》（JS 红宝书）</p></li><li><p><a href="https://juejin.cn/post/6981588276356317214#heading-13">你真的了解垃圾回收机制吗</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类</title>
    <link href="/2023/05/05/%E7%B1%BB/"/>
    <url>/2023/05/05/%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><p>与函数类型相似，定义类也有两种主要方式：类声明和类表达式。这两种方式都使用 class 关键字加大括号：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 类声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125; <br><span class="hljs-comment">// 类表达式</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Animal</span> = <span class="hljs-keyword">class</span> &#123;&#125;;<br></code></pre></td></tr></table></figure><p>与函数定义不同的是</p><ul><li><p>函数声明可提升，类声明不能提升</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">FunctionDeclaration</span>); <span class="hljs-comment">// FunctionDeclaration() &#123;&#125; </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">FunctionDeclaration</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">ClassDeclaration</span>); <span class="hljs-comment">// ReferenceError: ClassDeclaration is not defined </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassDeclaration</span> &#123;&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">ClassDeclaration</span>); <span class="hljs-comment">// class ClassDeclaration &#123;&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>函数受函数作用域限制，而类受块作用域限制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123; <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">FunctionDeclaration</span>(<span class="hljs-params"></span>) &#123;&#125; <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassDeclaration</span> &#123;&#125; <br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">FunctionDeclaration</span>); <span class="hljs-comment">// FunctionDeclaration() &#123;&#125; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">ClassDeclaration</span>); <span class="hljs-comment">// ReferenceError: ClassDeclaration is not defined</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="类的构成"><a href="#类的构成" class="headerlink" title="类的构成"></a>类的构成</h2><p>类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。空的类定义照样有效。</p><blockquote><p>与函数构造函数一样，多数编程风格都建议类名的首字母要大写，以区别于通过它创建的实例</p><p>比如，通过 class Foo {}创建实例 foo</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 有构造函数的类，有效</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> &#123; <br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;&#125; <br>&#125; <br><span class="hljs-comment">// 有获取函数的类，有效</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Baz</span> &#123; <br> <span class="hljs-keyword">get</span> <span class="hljs-title function_">myBaz</span>() &#123;&#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类构造函数"><a href="#类构造函数" class="headerlink" title="类构造函数"></a>类构造函数</h3><p>方法名 constructor 会告诉解释器在使用 new 操作符创建类的新实例时，应该调用这个函数。</p><p>构造函数的定义不是必需的，不定义构造函数相当于将构造函数定义为空函数。</p><h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><p>使用 new 操作符实例化 Person 的操作等于使用 new 调用其构造函数。</p><p>使用 new 调用类的构造函数会执行如下操作：</p><ul><li>在内存中创建一个新对象。</li><li>这个新对象内部的[[Prototype]]指针被赋值为构造函数的 prototype 属性。</li><li>构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。</li><li>执行构造函数内部的代码（给新对象添加属性）。</li><li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;&#125; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123; <br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person ctor&#x27;</span>); <br>    &#125; <br>&#125; <br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(); <br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(); <span class="hljs-comment">// person ctor </span><br></code></pre></td></tr></table></figure><p>类构造函数与构造函数的主要区别是：调用类构造函数必须使用 new 操作符。</p><p>普通构造函数如果不使用 new 调用，那么就会以全局的 this（通常是 window）作为内部对象。</p><p>调用类构造函数时如果忘了使用 new 则会抛出错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;&#125; <br><span class="hljs-comment">// 把 window 作为 this 来构建实例</span><br><span class="hljs-keyword">let</span> p = <span class="hljs-title class_">Person</span>(); <br><span class="hljs-keyword">let</span> a = <span class="hljs-title class_">Animal</span>(); <span class="hljs-comment">// TypeError: class constructor Animal cannot be invoked without &#x27;new&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="实例、原型和类成员"><a href="#实例、原型和类成员" class="headerlink" title="实例、原型和类成员"></a>实例、原型和类成员</h3><p>类的语法可以非常方便地定义应该存在于实例上的成员、应该存在于原型上的成员，以及应该存在于类本身的成员。</p><ul><li><p>实例成员</p><p>每次通过new调用类标识符时，都会执行<strong>类构造函数constructor（）</strong>，为实例添加属性（方法、原始值、对象）。</p><p>每个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123; <br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-comment">// 这个例子先使用对象包装类型定义一个字符串</span><br>        <span class="hljs-comment">// 为的是在下面测试两个对象的相等性</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;Jack&#x27;</span>); <br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); <br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">nicknames</span> = [<span class="hljs-string">&#x27;Jake&#x27;</span>, <span class="hljs-string">&#x27;J-Dog&#x27;</span>] <br>    &#125; <br>&#125; <br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(); <br>    p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(); <br>p1.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// Jack </span><br>p2.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// Jack </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">name</span> === p2.<span class="hljs-property">name</span>); <span class="hljs-comment">// false </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">sayName</span> === p2.<span class="hljs-property">sayName</span>); <span class="hljs-comment">// false </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">nicknames</span> === p2.<span class="hljs-property">nicknames</span>); <span class="hljs-comment">// false </span><br>p1.<span class="hljs-property">name</span> = p1.<span class="hljs-property">nicknames</span>[<span class="hljs-number">0</span>]; <br>p2.<span class="hljs-property">name</span> = p2.<span class="hljs-property">nicknames</span>[<span class="hljs-number">1</span>]; <br>p1.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// Jake </span><br>p2.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// J-Dog</span><br></code></pre></td></tr></table></figure></li><li><p>原型方法（共享）</p><p>类定义语法把在<strong>类块中</strong>定义的方法添加到prototype原型属性上。在类块中只能定义原型的方法，不能添加原始值、对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123; <br>      <span class="hljs-title function_">stringKey</span>(<span class="hljs-params"></span>) &#123; <br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;invoked stringKey&#x27;</span>); <br>      &#125; <br>  &#125; <br>  <span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(); <br>  p.<span class="hljs-title function_">stringKey</span>(); <span class="hljs-comment">// invoked stringKey </span><br>  <br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123; <br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jake&#x27;</span>  <br>  &#125; <br>  <span class="hljs-comment">// Uncaught SyntaxError: Unexpected token</span><br></code></pre></td></tr></table></figure><p>原型的原始值和对象可以通过在类外部手动添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Jake&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>类方法（）</p><p>可以在类上定义静态方法（只存在类本身，实例不继承）。</p><p>使用<strong>static关键字</strong>作为前缀，某种程度上与原型方法一样随着类的加载而执行，并且只会执行一次，不会因为创建不同的实例就调用一次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123; <br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-comment">// 添加到 this 的所有内容都会存在于不同的实例上</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">locate</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;instance&#x27;</span>, <span class="hljs-variable language_">this</span>); <br>    &#125; <br>    <span class="hljs-comment">// 定义在类的原型对象上</span><br>    <span class="hljs-title function_">locate</span>(<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;prototype&#x27;</span>, <span class="hljs-variable language_">this</span>); <br>    &#125; <br>    <span class="hljs-comment">// 定义在类本身上</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">locate</span>(<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-variable language_">this</span>); <br>    &#125; <br>&#125; <br><span class="hljs-title class_">Person</span>.<span class="hljs-title function_">locate</span>(); <span class="hljs-comment">// class, class Person &#123;&#125;</span><br></code></pre></td></tr></table></figure><p>同样，类定义中不支持添加类成员数据。但我们可以在类定义外部手动添加（实例上仍然无）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在类上定义数据成员</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property">greeting</span> = <span class="hljs-string">&#x27;My name is&#x27;</span>;<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>注意：类中是不能直接定义原型成员数据和类成员属性的，所以如果见到直接在类中定义属性，那这个属性最终一定是等同于在constructor中写的，也就是会存在于不同的实例上。</p></blockquote><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>ECMAScript 6 新增特性中最出色的一个就是原生支持了类继承机制。虽然类继承使用的是新语法，但背后依旧使用的是原型链。</p><h3 id="继承基础"><a href="#继承基础" class="headerlink" title="继承基础"></a>继承基础</h3><p>使用 extends 关键字，就可以继承任何拥有[[Construct]]和原型的对象。</p><p>派生类都会通过原型链访问到类和原型上定义的方法。this 的值会反映调用相应方法的实例或者类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123; <br>    <span class="hljs-title function_">identifyPrototype</span>(<span class="hljs-params">id</span>) &#123; <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(id, <span class="hljs-variable language_">this</span>); <br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">identifyClass</span>(<span class="hljs-params">id</span>) &#123; <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(id, <span class="hljs-variable language_">this</span>); <br>    &#125; <br>&#125; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123;&#125; <br><span class="hljs-keyword">let</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle</span>(); <br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus</span>(); <br>b.<span class="hljs-title function_">identifyPrototype</span>(<span class="hljs-string">&#x27;bus&#x27;</span>); <span class="hljs-comment">// bus, Bus &#123;&#125; </span><br>v.<span class="hljs-title function_">identifyPrototype</span>(<span class="hljs-string">&#x27;vehicle&#x27;</span>); <span class="hljs-comment">// vehicle, Vehicle &#123;&#125; </span><br><span class="hljs-comment">// 实例不会继承类的static方法，但类继承会有父类的static</span><br><span class="hljs-title class_">Bus</span>.<span class="hljs-title function_">identifyClass</span>(<span class="hljs-string">&#x27;bus&#x27;</span>); <span class="hljs-comment">// bus, class Bus &#123;&#125; </span><br><span class="hljs-title class_">Vehicle</span>.<span class="hljs-title function_">identifyClass</span>(<span class="hljs-string">&#x27;vehicle&#x27;</span>); <span class="hljs-comment">// vehicle, class Vehicle &#123;&#125;</span><br></code></pre></td></tr></table></figure><h3 id="super"><a href="#super" class="headerlink" title="super()"></a>super()</h3><p><strong>super</strong>关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。</p><p>在类构造函数中使用 super 可以调用父类构造函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123; <br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">hasEngine</span> = <span class="hljs-literal">true</span>; <br>    &#125; <br>&#125; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123; <br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-comment">// 不要在调用 super()之前引用 this，否则会抛出 ReferenceError </span><br>        <span class="hljs-variable language_">super</span>(); <span class="hljs-comment">// 相当于 super.constructor() 调用父类的构造函数，此时的this是子类Bus，执行完以后的this是执行完父类构造函数添加了属性之后的Bus</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Vehicle</span>); <span class="hljs-comment">// true </span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// Bus &#123; hasEngine: true &#125; </span><br>    &#125; <br>&#125; <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus</span>();<br></code></pre></td></tr></table></figure><p>在静态方法中可以通过 super 调用继承的类上定义的静态方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123; <br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">identify</span>(<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;vehicle&#x27;</span>); <br>    &#125; <br>&#125; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123; <br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">identify</span>(<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">identify</span>(); <br>    &#125; <br>&#125; <br><span class="hljs-title class_">Bus</span>.<span class="hljs-title function_">identify</span>(); <span class="hljs-comment">// vehicle</span><br></code></pre></td></tr></table></figure><blockquote><p>ES6 给类构造函数和静态方法添加了内部特性[[HomeObject]]。这个特性是一个指针，指向定义该方法的对象。super 始终会定义为[[HomeObject]]的原型。</p></blockquote><p>在使用 super 时要注意几个问题</p><ul><li>super 只能在派生类构造函数和静态方法中使用</li><li>不能单独引用 super 关键字，要么用它调用构造函数，要么用它引用静态方法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;&#125; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123; <br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">super</span>); <br>        <span class="hljs-comment">// SyntaxError: &#x27;super&#x27; keyword unexpected here </span><br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>调用 super()会调用父类构造函数，并将返回的实例赋值给 this。</li><li>super()的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入。</li><li>如果没有定义类构造函数，在实例化派生类时会调用 super()，而且会传入所有传给派生类的参数。</li><li>在类构造函数中，不能在调用 super()之前引用 this。</li><li>如果在派生类中显式定义了构造函数，则要么必须在其中调用 super()，要么必须在其中返回一个对象。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;&#125; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123;&#125; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123; <br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-variable language_">super</span>(); <br>    &#125; <br>&#125; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Van</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123; <br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-keyword">return</span> &#123;&#125;; <br>    &#125; <br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>()); <span class="hljs-comment">// Car &#123;&#125; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus</span>()); <span class="hljs-comment">// Bus &#123;&#125; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Van</span>()); <span class="hljs-comment">// &#123;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《Javascript 高级程序设计(第 4 版)》（JS 红宝书）</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript对象（三）创建对象</title>
    <link href="/2023/05/05/JavaScript%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/05/05/JavaScript%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="使用Object构造函数或对面字面量"><a href="#使用Object构造函数或对面字面量" class="headerlink" title="使用Object构造函数或对面字面量"></a>使用Object构造函数或对面字面量</h2><ul><li>不足：创建具有同样接口的多个对象需要重复编写许多代码。</li></ul><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, job</span>) &#123; </span><br><span class="line">    <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line">    o.<span class="property">name</span> = name; </span><br><span class="line">    o.<span class="property">age</span> = age; </span><br><span class="line">    o.<span class="property">job</span> = job; </span><br><span class="line">    o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="keyword">return</span> o; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="title function_">createPerson</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="title function_">createPerson</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>可以解决创建多个类似对象的问题</li><li>不足：无法解决对象标识问题（即新创建的对象是什么类型）</li></ul><h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">job</span> = job; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">    &#125;; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>); </span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// Nicholas </span></span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">// Greg</span></span><br></pre></td></tr></table></figure><blockquote><p>构造函数名称的首字母要大写</p></blockquote><p>函数内部代码与工厂模式相比：</p><ul><li>没有显式地创建对象</li><li>属性和方法直接赋值给了 this</li><li>没有 return</li></ul><blockquote><p>在原型模式没有时，使用new调用构造函数会执行： </p><p>1.在内存中创建一个新对象</p><p>2.构造函数内部的this被赋值为这个新对象（即this指向新对象）</p><p>3.执行构造函数内部的代码（给新对象添加属性）</p><p>4.如果构造函数返回非空对象，则返回该对象；否则返回刚创建的新对象</p></blockquote><ul><li>可以解决对象标识问题(返回的对象要么是创建的新对象，要么是构造函数返回的非空对象)</li><li>不足：成员、函数无法重用，无法在多个对象实例间共享。</li></ul><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式解决了成员共享的问题 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 规定只要创建一个函数，就会为这个函数创建一个prototype属性（指向原型对象）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="comment">// 在原型对象上面定义的属性和方法可以被实例对象共享</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 每次创建新实例，该实例内部的[[Prototype]]指针就被赋值为构造函数的原型对象</span></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">sayName</span> == person2.<span class="property">sayName</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>构造函数的prototype指向原型对象，新实例的[[Prototype]]值为prototype也指向原型对象。Chrome中可以通过_proto__属性拿到[[Prototype]]</p><blockquote><p>在原型模式中，使用new调用构造函数会执行： </p><p>1.在内存中创建一个新对象</p><p>2.这个新对象内部的[[Prototype]]特性被赋值为构造函数的prototype属性（构造函数的prototype属性指向原型对象）</p><p>3.构造函数内部的this被赋值为这个新对象（即this指向新对象）</p><p>4.执行构造函数内部的代码（给新对象添加属性）</p><p>5.如果构造函数返回非空对象，则返回该对象；否则返回刚创建的新对象</p></blockquote><h3 id="图示理解"><a href="#图示理解" class="headerlink" title="图示理解"></a>图示理解</h3><p>构造函数、原型对象、实例的关系理解如下：</p><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230504214259902.png" alt="image-20230504214259902"></p><h3 id="原型对象相关API"><a href="#原型对象相关API" class="headerlink" title="原型对象相关API"></a>原型对象相关API</h3><ul><li><p>isPrototypeOf()   传入的新实例参数的[[Prototype]]属性是否指向调用该方法的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person1的[[Prototype]]指向的原型对象是否是Person.prototype</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(person1)); <span class="comment">// true </span></span><br></pre></td></tr></table></figure></li><li><p>Object.getPrototypeOf()    返回参数的内部特性[[Prototype]]的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person1) == <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person1).<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>Object.setPrototypeOf()   向实例的私有特性[[Prototype]]写入一个新值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> biped = &#123; </span><br><span class="line">    <span class="attr">numLegs</span>: <span class="number">2</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(person, biped); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// Matt </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">numLegs</span>); <span class="comment">// 2 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person) === biped); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>Object.setPrototypeOf()可能会严重影响代码性能。因为他会重写一个对象的原型继承关系，修改继承关系，这些影响是微妙且深远的。会涉及所有访问了那些修改过[[Prototype]]的对象的代码。”</p></blockquote></li><li><p>Object.create()  来创建一个新对象，同时为其指定原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> biped = &#123; </span><br><span class="line">    <span class="attr">numLegs</span>: <span class="number">2</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person = <span class="title class_">Object</span>.<span class="title function_">create</span>(biped); </span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;Matt&#x27;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// Matt </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">numLegs</span>); <span class="comment">// 2 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person) === biped); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>hasOwnProperty()  确定某个属性是在实例上还是在原型对象上，属性存在于调用它的对象实例上时返回 true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// true,来自实例本身</span></span><br></pre></td></tr></table></figure></li><li><p>in操作符   可以通过对象访问到指定属性时就返回true，无论属性是在实例上还是原型上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// &quot;Greg&quot;，来自实例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="原型层级"><a href="#原型层级" class="headerlink" title="原型层级"></a>原型层级</h3><p>先找实例属性，再找原型对象属性。</p><h3 id="原型的问题"><a href="#原型的问题" class="headerlink" title="原型的问题"></a>原型的问题</h3><p>原型模式也不是没有问题。首先，它弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值。虽然这会带来不便，但还不是原型的最大问题。原型的最主要问题源自它的共享特性。</p><p>原型上的所有属性是在实例间共享的，这对函数来说比较合适。但是对于包含原始值的属性、包含引用值的属性，在实例间共享就不太合适了。</p><p>一般来说，不同的实例应该有属于自己的属性副本，故实际开发中通常不单独使用原型模式（只有原型对象）。</p><p>这时候我们就可以使用<strong>构造函数模式与原型模式结合</strong>的方式，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。</p><h2 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h2><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>通过构造函数定义实例独有属性，通过原型定义共享属性和方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,age,job</span>)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123; </span><br><span class="line">    <span class="attr">constructor</span>:<span class="title class_">Person</span>,</span><br><span class="line">    <span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Nike&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;teacher&#x27;</span>);</span><br></pre></td></tr></table></figure><p>实例属性都是在构造函数中定义的，而所有实例共享的属性constructor和方法sayName()则是在原型中定义。</p><p>这种模式是ECMAScript中使用最广泛，认可度最高的一种创建自定义类型的方法，可以说这是用来定义引用类型的一种默认模式。</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>组合使用构造函数模式和原型模式会出现的问题其实是对原型模式的问题的放大。</p><p>前面提到原型的最主要问题源自它的共享特性，结合构造函数定义实例可以实现独有属性表面上解决了原型的无脑共享问题。</p><p>但是在实现继承时，就会发现这个烦人的不由分说的共享问题又回来了。ECMAScript主要是通过原型链实现的继承。</p><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><p>重温一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？</p><p>那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">property</span> = <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSuperValue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">property</span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">subproperty</span> = <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 继承 SuperType,相当于重写原型</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>(); </span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSubValue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">subproperty</span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">SubType</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="title function_">getSuperValue</span>()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230505163724528.png" alt="image-20230505163724528"></p><p>在使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变成为了原型属性（实例共享！！）。</p><h4 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">subType, superType</span>) &#123; </span><br><span class="line">    <span class="keyword">let</span> prototype = <span class="title function_">object</span>(superType.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 创建对象</span></span><br><span class="line">    prototype.<span class="property">constructor</span> = subType; <span class="comment">// 增强对象 </span></span><br><span class="line">    subType.<span class="property"><span class="keyword">prototype</span></span> = prototype; <span class="comment">// 赋值对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>) &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>) &#123; </span><br><span class="line"> <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">SubType</span>, <span class="title class_">SuperType</span>); </span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里只调用了一次 SuperType 构造函数，避免了 SubType.prototype 上不必要也用不到的属性，因此可以说这个例子的效率更高。</p><p>而且原型链仍然保持不变，因此 instanceof 操作符和isPrototypeOf()方法正常有效。</p><p>寄生式组合继承可以算是引用类型继承的最佳模式。</p><h2 id="类（ES6）"><a href="#类（ES6）" class="headerlink" title="类（ES6）"></a>类（ES6）</h2><ul><li><strong>组合构造函数模式和原型模式的语法糖</strong>。</li></ul><p>关于类更详细的介绍会单独开篇介绍。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《Javascript 高级程序设计(第 4 版)》（JS 红宝书）</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript对象（二）增强的对象语法</title>
    <link href="/2023/05/04/JavaScript%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89%E5%A2%9E%E5%BC%BA%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/05/04/JavaScript%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89%E5%A2%9E%E5%BC%BA%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="属性值简写"><a href="#属性值简写" class="headerlink" title="属性值简写"></a>属性值简写</h2><p>简写属性名只要使用变量名（不用再写冒号）就会自动被解释为同名的属性键。如果没有找到同名变量，则会抛出 ReferenceError。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;Matt&#x27;</span>; <br><span class="hljs-keyword">let</span> person = &#123; <br>    <span class="hljs-attr">name</span>: name <br>&#125;;<br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;Matt&#x27;</span>; <br><span class="hljs-keyword">let</span> person = &#123; <br>    name <br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="可计算属性"><a href="#可计算属性" class="headerlink" title="可计算属性"></a>可计算属性</h2><p>在引入可计算属性之前，不能在对象字面量中直接动态命名属性。</p><p>如果想使用变量的值作为属性，那么必须先声明对象，然后使用中括号语法来添加属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> nameKey = <span class="hljs-string">&#x27;name&#x27;</span>;<br><span class="hljs-keyword">let</span> person = &#123;&#125;; <br>person[nameKey] = <span class="hljs-string">&#x27;Matt&#x27;</span>;<br></code></pre></td></tr></table></figure><p>有了可计算属性，就可以在对象字面量中完成动态属性赋值。</p><p>中括号包围的对象属性键告诉运行时将其作为 <strong>JavaScript 表达式</strong>而不是字符串来求值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> nameKey = <span class="hljs-string">&#x27;name&#x27;</span>;<br><span class="hljs-keyword">let</span> person = &#123; <br>    [nameKey]: <span class="hljs-string">&#x27;Matt&#x27;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>可计算属性本身可以是更复杂的表达式，在实例化时再求值。</p><h2 id="简写方法名"><a href="#简写方法名" class="headerlink" title="简写方法名"></a>简写方法名</h2><p>在给对象定义方法时，通常都要写一个方法名、冒号，然后再引用一个匿名函数表达式，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123; <br>    <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) &#123; <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`My name is <span class="hljs-subst">$&#123;name&#125;</span>`</span>); <br>    &#125; <br>&#125;; <br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123; <br>    <span class="hljs-title function_">sayName</span>(<span class="hljs-params">name</span>) &#123; <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`My name is <span class="hljs-subst">$&#123;name&#125;</span>`</span>); <br>    &#125; <br>&#125;;<br></code></pre></td></tr></table></figure><p>简写方法名与可计算属性键相互兼容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> methodKey = <span class="hljs-string">&#x27;sayName&#x27;</span>; <br><span class="hljs-keyword">let</span> person = &#123; <br>    [methodKey](name) &#123; <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`My name is <span class="hljs-subst">$&#123;name&#125;</span>`</span>); <br>    &#125; <br>&#125; <br></code></pre></td></tr></table></figure><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>单地说，对象解构就是使用与对象匹配的结构来实现对象属性<strong>赋值</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 不使用对象解构</span><br><span class="hljs-keyword">let</span> person = &#123; <br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Matt&#x27;</span>,<br>&#125;;<br><span class="hljs-keyword">let</span> personName = person.<span class="hljs-property">name</span>,<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(personName); <span class="hljs-comment">// Matt</span><br><br><span class="hljs-comment">// 使用对象解构</span><br><span class="hljs-keyword">let</span> person = &#123; <br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Matt&#x27;</span><br>&#125;; <br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">name</span>: personName &#125; = person; <br><span class="hljs-comment">// 如果想让变量直接使用属性的名称，那么可以使用简写语法：</span><br><span class="hljs-comment">// let &#123; name &#125; = person; </span><br><span class="hljs-comment">// console.log(name); // Matt</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(personName); <span class="hljs-comment">// Matt</span><br></code></pre></td></tr></table></figure><p>解构赋值不一定与对象的属性匹配。如果引用的属性不存在，则该变量的值就是 undefined。</p><p>以下是对象解构赋值的几个引用场景</p><h3 id="过滤对象属性"><a href="#过滤对象属性" class="headerlink" title="过滤对象属性"></a>过滤对象属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 我们想过滤掉对象中的 inner 和 outer 属性</span><br><span class="hljs-keyword">const</span> &#123; inner, outer, ...restProps &#125; = &#123;<br>  <span class="hljs-attr">inner</span>: <span class="hljs-string">&#x27;This is inner&#x27;</span>,<br>  <span class="hljs-attr">outer</span>: <span class="hljs-string">&#x27;This is outer&#x27;</span>,<br>  <span class="hljs-attr">v1</span>: <span class="hljs-string">&#x27;1&#x27;</span>,<br>  <span class="hljs-attr">v2</span>: <span class="hljs-string">&#x27;2&#x27;</span>,<br>  <span class="hljs-attr">v4</span>: <span class="hljs-string">&#x27;3&#x27;</span><br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(restProps); <span class="hljs-comment">// &#123;v1: &quot;1&quot;, v2: &quot;2&quot;, v4: &quot;3&quot;&#125;12345678910</span><br></code></pre></td></tr></table></figure><h3 id="获取嵌套对象的属性"><a href="#获取嵌套对象的属性" class="headerlink" title="获取嵌套对象的属性"></a>获取嵌套对象的属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 通过解构赋值获取嵌套对象的值</span><br><span class="hljs-keyword">const</span> car = &#123;<br>    <span class="hljs-attr">model</span>: <span class="hljs-string">&#x27;bmw 2018&#x27;</span>,<br>    <span class="hljs-attr">engine</span>: &#123;<br>        <span class="hljs-attr">v6</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">turbo</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">vin</span>: <span class="hljs-number">12345</span><br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 这里使用 ES6 中的简单写法，使用 &#123; vin &#125; 替代 &#123; vin: vin &#125;</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">modalAndVIN</span> = (<span class="hljs-params">&#123; model, engine: &#123; vin &#125;&#125;</span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`model: <span class="hljs-subst">$&#123;model&#125;</span>, vin: <span class="hljs-subst">$&#123;vin&#125;</span>`</span>);<br>&#125;<br><span class="hljs-title function_">modalAndVIN</span>(car);  <span class="hljs-comment">// &quot;model: bmw 2018, vin: 12345&quot; 12345678910111213141516</span><br><br></code></pre></td></tr></table></figure><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>扩展运算符是三个点（…）。用于取出参数对象的所有可遍历属性，然后拷贝到当前对象之中。以下是几个巧妙的应用场景</p><h3 id="复制对象"><a href="#复制对象" class="headerlink" title="复制对象"></a>复制对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 以往的复制对象，复制是对象的引用，修改会反应到所有引用了这个地址的对象上</span><br><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>:<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-attr">b</span>:<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-attr">c</span>:<span class="hljs-string">&#x27;C&#x27;</span> &#125;;<br><span class="hljs-keyword">const</span> objCopy = obj;<br>objCopy.<span class="hljs-property">c</span> = <span class="hljs-string">&#x27;X&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj); <span class="hljs-comment">// &#123; a:&#x27;A&#x27;, b:&#x27;B&#x27;, c:&#x27;X&#x27; &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arrCopy); <span class="hljs-comment">// &#123; a:&#x27;A&#x27;, b:&#x27;B&#x27;, c:&#x27;X&#x27; &#125;</span><br><br><span class="hljs-comment">// 使用扩展运算符</span><br><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>:<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-attr">b</span>:<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-attr">c</span>:<span class="hljs-string">&#x27;C&#x27;</span> &#125;;<br><span class="hljs-keyword">const</span> objCopy = &#123; ...obj &#125;;<br>objCopy.<span class="hljs-property">c</span> = <span class="hljs-string">&#x27;X&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj); <span class="hljs-comment">// &#123; a:&#x27;A&#x27;, b:&#x27;B&#x27;, c:&#x27;C&#x27; &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arrCopy); <span class="hljs-comment">// &#123; a:&#x27;A&#x27;, b:&#x27;B&#x27;, c:&#x27;X&#x27; &#125;</span><br></code></pre></td></tr></table></figure><h3 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">3</span>,<span class="hljs-attr">y</span>:<span class="hljs-number">4</span>&#125;<br><span class="hljs-keyword">let</span> b = &#123;<span class="hljs-attr">x1</span>:<span class="hljs-number">5</span>,<span class="hljs-attr">y1</span>:<span class="hljs-number">6</span>&#125;<br><span class="hljs-keyword">let</span> c = &#123;...a,...b&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c) <span class="hljs-comment">// &#123;x:3,y:4,x1:5,y1:6&#125;</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《Javascript 高级程序设计(第 4 版)》（JS 红宝书）</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript对象（一）对象属性描述符</title>
    <link href="/2023/05/04/JavaScript%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/"/>
    <url>/2023/05/04/JavaScript%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="对象属性描述符"><a href="#对象属性描述符" class="headerlink" title="对象属性描述符"></a>对象属性描述符</h1><p>属性描述符(Property Descriptor) 本质上是一个 JavaScript 普通对象，用于描述一个属性的相关信息，共有下面这几种属性。</p><ul><li>value：属性值</li><li>configurable：该属性是否能被删除，属性是否可以修改</li><li>enumerable：该属性是否可以被枚举</li><li>writable：该属性是否可以被重新赋值</li><li>存取器属性：属性描述符中如果配置了 get 和 set 中的任何一个，则该属性不再是一个普通属性（<strong>数据属性</strong>），而变成了<strong>存取器属性</strong>。<ul><li>get()读值函数：如果一个属性是存取器属性，则读取该属性时，会运行 get 方法，并将 get 方法得到的返回值作为属性值</li><li>set(newVal)存值函数：如果给该属性赋值，则会运行 set 方法，newVal 参数为赋值的值。</li></ul></li></ul><p>存取器属性最大的意义，在于可以控制属性的读取和赋值，在函数里可以进行各种操作。</p><p>Vue2 数据响应式就是使用了这一点，在 getter 和 setter 函数中进行了数据绑定与派发更新。</p><p><strong>注意点</strong>：value 和 writable 属性不能与 get 和 set 属性二者不可共存，二者只能选其一。</p><p><strong>查看</strong>某个对象的属性描述符，使用以下这两种方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(对象, 属性名); <span class="hljs-comment">//得到一个对象的某个属性的属性描述符</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(对象); <span class="hljs-comment">//得到某个对象的所有属性描述符</span><br></code></pre></td></tr></table></figure><p>为某个对象属性<strong>添加</strong>特性时 或 <strong>修改</strong>属性特性时，配置其属性描述符，使用以下这两种方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(对象, 属性名, 描述符); <span class="hljs-comment">//设置一个对象的某个属性</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(对象, 多个属性的描述符); <span class="hljs-comment">//设置一个对象的多个属性</span><br><br><span class="hljs-keyword">let</span> person = &#123;&#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(person, <span class="hljs-string">&quot;name&quot;</span>, &#123; <br>    <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>, <br>    <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;Nicholas&quot;</span> <br>&#125;); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;Nicholas&quot; </span><br><br><span class="hljs-comment">// writable: false不可被重新赋值</span><br>person.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Greg&quot;</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;Nicholas&quot;</span><br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《Javascript 高级程序设计(第 4 版)》（JS 红宝书）</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理与反射（二）</title>
    <link href="/2023/05/03/%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2023/05/03/%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><h2 id="属性验证"><a href="#属性验证" class="headerlink" title="属性验证"></a>属性验证</h2><p>因为所有赋值操作都会触发 set()捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = &#123; <br>    <span class="hljs-attr">onlyNumbersGoHere</span>: <span class="hljs-number">0</span> <br>&#125;; <br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, &#123; <br>     <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value</span>) &#123; <br>         <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">&#x27;number&#x27;</span>) &#123; <br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>     &#125; <span class="hljs-keyword">else</span> &#123; <br>     <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(...<span class="hljs-variable language_">arguments</span>); <br>     &#125; <br>     &#125; <br>&#125;); <br>proxy.<span class="hljs-property">onlyNumbersGoHere</span> = <span class="hljs-number">1</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">onlyNumbersGoHere</span>); <span class="hljs-comment">// 1 </span><br>proxy.<span class="hljs-property">onlyNumbersGoHere</span> = <span class="hljs-string">&#x27;2&#x27;</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">onlyNumbersGoHere</span>); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h2 id="函数与构造函数参数验证"><a href="#函数与构造函数参数验证" class="headerlink" title="函数与构造函数参数验证"></a>函数与构造函数参数验证</h2><p>跟保护和验证对象属性类似，也可对函数和构造函数参数进行审查。比如，可以让函数只接收某种类型的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">median</span>(<span class="hljs-params">...nums</span>) &#123; <br>    <span class="hljs-keyword">return</span> nums.<span class="hljs-title function_">sort</span>()[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(nums.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>)]; <br>&#125; <br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(median, &#123; <br>     <span class="hljs-title function_">apply</span>(<span class="hljs-params">target, thisArg, argumentsList</span>) &#123; <br>         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arg <span class="hljs-keyword">of</span> argumentsList) &#123; <br>             <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> arg !== <span class="hljs-string">&#x27;number&#x27;</span>) &#123; <br>             <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;Non-number argument provided&#x27;</span>; <br>             &#125; <br>         &#125;<br>              <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(...<span class="hljs-variable language_">arguments</span>); <br>     &#125; <br>&#125;); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">proxy</span>(<span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>)); <span class="hljs-comment">// 4 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">proxy</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-number">1</span>)); <br><span class="hljs-comment">// Error: Non-number argument provided</span><br></code></pre></td></tr></table></figure><p>类似地，可以要求实例化时必须给构造函数传参：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123; <br>     <span class="hljs-title function_">constructor</span>(<span class="hljs-params">id</span>) &#123; <br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">id_</span> = id; <br>     &#125; <br>&#125; <br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(<span class="hljs-title class_">User</span>, &#123; <br>     <span class="hljs-title function_">construct</span>(<span class="hljs-params">target, argumentsList, newTarget</span>) &#123; <br>         <span class="hljs-keyword">if</span> (argumentsList[<span class="hljs-number">0</span>] === <span class="hljs-literal">undefined</span>) &#123; <br>         <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;User cannot be instantiated without id&#x27;</span>; <br>         &#125; <span class="hljs-keyword">else</span> &#123; <br>         <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(...<span class="hljs-variable language_">arguments</span>); <br>         &#125; <br>     &#125; <br>&#125;); <br><span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-number">1</span>); <br><span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>(); <br><span class="hljs-comment">// Error: User cannot be instantiated without id</span><br></code></pre></td></tr></table></figure><h2 id="数据绑定与可观察对象"><a href="#数据绑定与可观察对象" class="headerlink" title="数据绑定与可观察对象"></a>数据绑定与可观察对象</h2><p>通过代理可以把运行时中原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的代码互操作。</p><p>比如，可以将被代理的类绑定到一个全局实例集合，让所有创建的实例都被添加到这个集合中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> userList = []; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123; <br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123; <br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name_</span> = name; <br>    &#125; <br>&#125; <br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(<span class="hljs-title class_">User</span>, &#123; <br>     <span class="hljs-title function_">construct</span>(<span class="hljs-params"></span>) &#123; <br>         <span class="hljs-keyword">const</span> newUser = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(...<span class="hljs-variable language_">arguments</span>); <br>         userList.<span class="hljs-title function_">push</span>(newUser); <br>         <span class="hljs-keyword">return</span> newUser; <br>     &#125; <br>&#125;); <br><span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-string">&#x27;John&#x27;</span>); <br><span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-string">&#x27;Jacob&#x27;</span>); <br><span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-string">&#x27;Jingleheimerschmidt&#x27;</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userList); <span class="hljs-comment">// [User &#123;&#125;, User &#123;&#125;, User&#123;&#125;]</span><br></code></pre></td></tr></table></figure><p>另外，还可以把集合绑定到一个事件分派程序，每次插入新实例时都会发送消息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> userList = []; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">emit</span>(<span class="hljs-params">newValue</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newValue); <br>&#125; <br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(userList, &#123; <br>     <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value, receiver</span>) &#123; <br>         <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(...<span class="hljs-variable language_">arguments</span>); <br>         <span class="hljs-keyword">if</span> (result) &#123; <br>         <span class="hljs-title function_">emit</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, property, receiver)); <br>      &#125; <br>     <span class="hljs-keyword">return</span> result; <br>     &#125; <br>&#125;); <br>proxy.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;John&#x27;</span>); <br><span class="hljs-comment">// John </span><br>proxy.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;Jacob&#x27;</span>); <br><span class="hljs-comment">// Jacob</span><br></code></pre></td></tr></table></figure><p>其他简单的应用还有跟踪<strong>属性访问</strong>、<strong>隐藏属性</strong>等。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《Javascript 高级程序设计(第 4 版)》（JS 红宝书）</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理与反射(一)</title>
    <link href="/2023/05/02/%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/05/02/%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>ECMAScript 6 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。</p><p>讲解 Proxy 和 Reflect 前，我们需要先了解<a href="https://airfe.gitee.io/blog/2023/05/04/%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/">属性描述符</a>的作用。</p><h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><p>而且<code>Vue2 =&gt; Vue3</code> 时，数据响应式方法从<code>Object.defineProperty()</code>方法变成了<code>Proxy()</code>。</p><p>代理(Proxy)能使我们开发者拥有一种间接修改底层方法的能力，从而控制用户的操作。</p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230502151112584.png" alt="image-20230502151112584" style="zoom:80%;"><h2 id="创建空代理"><a href="#创建空代理" class="headerlink" title="创建空代理"></a>创建空代理</h2><p>最简单的代理是空代理，即除了作为一个抽象的目标对象，什么也不做。 默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。</p><p>代理是使用 Proxy 构造函数创建的，这个构造函数接收两个参数：目标对象和处理程序对象。缺少其中任何一个参数都会抛出 TypeError。返回一个代理对象 </p><p>如：<code>new Proxy(target, handler);</code></p><p>要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = &#123;<br> <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;target&#x27;</span><br>&#125;; <span class="hljs-comment">//target：目标对象</span><br><span class="hljs-keyword">const</span> handler = &#123;&#125;; <span class="hljs-comment">//handler：是一个普通对象，其中可以重写底层实现</span><br><span class="hljs-comment">//创建空对象</span><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-comment">// id 属性会访问同一个值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">id</span>); <span class="hljs-comment">// target</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">id</span>); <span class="hljs-comment">// target</span><br><br><span class="hljs-comment">// 给目标属性赋值会反映在两个对象上 因为两个对象访问的是同一个值</span><br>target.<span class="hljs-property">id</span> = <span class="hljs-string">&#x27;foo&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">id</span>); <span class="hljs-comment">// foo</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">id</span>); <span class="hljs-comment">// foo</span><br><br><span class="hljs-comment">// 给代理属性赋值会反映在两个对象上 因为这个赋值会转移到目标对象</span><br>proxy.<span class="hljs-property">id</span> = <span class="hljs-string">&#x27;bar&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">id</span>); <span class="hljs-comment">// bar</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">id</span>); <span class="hljs-comment">// bar</span><br><span class="hljs-comment">// hasOwnProperty()方法在两个地方  也都会应用到目标对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;id&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;id&#x27;</span>)); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// Proxy.prototype 是 undefined   因此不能使用 instanceof 操作符</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Proxy</span>); <span class="hljs-comment">// TypeError: Function has non-object prototype</span><br><span class="hljs-string">&#x27;undefined&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">instanceof</span> check<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Proxy</span>); <span class="hljs-comment">// TypeError: Function has non-object prototype</span><br><span class="hljs-string">&#x27;undefined&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">instanceof</span> check<br><br><span class="hljs-comment">// 严格相等可以用来区分代理和目标</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target === proxy); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="定义捕获器"><a href="#定义捕获器" class="headerlink" title="定义捕获器"></a>定义捕获器</h2><p>使用代理的主要目的是可以定义零个或多个捕获器（trap）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。</p><p>每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。</p><p>比如，get()捕获器会接收到<strong>目标对象</strong>、<strong>要查询的属性</strong>和<strong>代理对象</strong>三个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = &#123;<br>  <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;bar&quot;</span>,<br>&#125;;<br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-comment">// 捕获器在处理程序对象中以方法名为键</span><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">trapTarget, property, receiver</span>) &#123;<br>    <span class="hljs-comment">//trapTarget - 目标对象</span><br>    <span class="hljs-comment">//property   - 要查询的属性</span><br>    <span class="hljs-comment">//receiver   - 代理对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;handler override&quot;</span>;<br>  &#125;,<br>&#125;;<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">foo</span>); <span class="hljs-comment">// bar</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>); <span class="hljs-comment">// handler override</span><br></code></pre></td></tr></table></figure><h2 id="捕获器不变式"><a href="#捕获器不变式" class="headerlink" title="捕获器不变式"></a>捕获器不变式</h2><p>捕获器不变式因方法不同而异，但通常都会防止捕获器定义出现过于反常的行为。</p><p>比如，如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出 TypeError：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*通过set铺货器设置writable为false的不可写属性时 */</span><br><span class="hljs-keyword">const</span> target = &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, <span class="hljs-string">&quot;foo&quot;</span>, &#123;<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;bar&quot;</span>,<br>&#125;);<br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;qux&quot;</span>;<br>  &#125;,<br>&#125;;<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>); <span class="hljs-comment">// TypeError</span><br></code></pre></td></tr></table></figure><h2 id="可撤销代理"><a href="#可撤销代理" class="headerlink" title="可撤销代理"></a>可撤销代理</h2><p>有时候可能需要中断代理对象与目标对象之间的联系。</p><p>Proxy 也暴露了 <strong>revocable()方法</strong>，这个方法支持撤销代理对象与目标对象的关联。</p><p>后续可直接调用<strong>撤销函数 revoke()</strong> 来撤销代理。</p><p>撤销代理之后再调用代理会抛出 TypeError，撤销函数和代理对象是在实例化时同时生成的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = &#123;<br>  <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;bar&quot;</span>,<br>&#125;;<br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;intercepted&quot;</span>;<br>  &#125;,<br>&#125;;<br><span class="hljs-keyword">const</span> &#123; proxy, revoke &#125; = <span class="hljs-title class_">Proxy</span>.<span class="hljs-title function_">revocable</span>(target, handler);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>); <span class="hljs-comment">// intercepted</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">foo</span>); <span class="hljs-comment">// bar</span><br><span class="hljs-title function_">revoke</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>); <span class="hljs-comment">// TypeError</span><br></code></pre></td></tr></table></figure><h2 id="可嵌套代理"><a href="#可嵌套代理" class="headerlink" title="可嵌套代理"></a>可嵌套代理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = &#123; <br>    <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span> <br>&#125;; <br><span class="hljs-keyword">const</span> firstProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, &#123; <br>      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123; <br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;first proxy&#x27;</span>); <br>         <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>); <br> &#125; <br>&#125;); <br><span class="hljs-keyword">const</span> secondProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(firstProxy, &#123; <br>     <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123; <br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;second proxy&#x27;</span>); <br>         <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>); <br>     &#125; <br>&#125;); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(secondProxy.<span class="hljs-property">foo</span>); <br><span class="hljs-comment">// second proxy </span><br><span class="hljs-comment">// first proxy </span><br><span class="hljs-comment">// bar</span><br></code></pre></td></tr></table></figure><h2 id="代理的问题与不足"><a href="#代理的问题与不足" class="headerlink" title="代理的问题与不足"></a>代理的问题与不足</h2><h3 id="代理中的this"><a href="#代理中的this" class="headerlink" title="代理中的this"></a>代理中的this</h3><p>我们知道，方法中的 this 通常指向调用这个方法的对象。可是，如果目标对象依赖于对象标识，那就可能碰到意料之外的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> wm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>(); <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123; <br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">userId</span>) &#123; <br>        wm.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>, userId); <br>    &#125; <br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">id</span>(<span class="hljs-params">userId</span>) &#123; <br>        wm.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>, userId); <br>    &#125; <br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">id</span>() &#123; <br>        <span class="hljs-keyword">return</span> wm.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>); <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>由于这个实现依赖 User 实例的对象标识，在这个实例被代理的情况下就会出问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">123</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">id</span>); <span class="hljs-comment">// 123 </span><br><span class="hljs-keyword">const</span> userInstanceProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(user, &#123;&#125;); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userInstanceProxy.<span class="hljs-property">id</span>); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>这是因为 User 实例一开始使用目标对象作为 WeakMap 的键，代理对象却尝试从自身取得这个实例。</p><p>解决方法：把代理 User 实例改为代理 User 类本身。之后再创建代理的实例就会以代理实例作为 WeakMap 的键了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserClassProxy</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(<span class="hljs-title class_">User</span>, &#123;&#125;); <br><span class="hljs-keyword">const</span> proxyUser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserClassProxy</span>(<span class="hljs-number">456</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxyUser.<span class="hljs-property">id</span>);<br></code></pre></td></tr></table></figure><h3 id="代理与内部槽位"><a href="#代理与内部槽位" class="headerlink" title="代理与内部槽位"></a>代理与内部槽位</h3><p>代理与内置引用类型（比如 Array）的实例通常可以很好地协同，但有些 ECMAScript 内置类型可能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。</p><p>一个典型的例子就是 Date 类型。根据 ECMAScript 规范，Date 类型方法的执行依赖 this 值上的内部槽位[[NumberDate]]。</p><p>代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通的 get()和 set()操作访问到。</p><p>于是代理拦截后本应转发给目标对象的方法会抛出 TypeError：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(); <br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, &#123;&#125;); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>); <span class="hljs-comment">// true </span><br>proxy.<span class="hljs-title function_">getDate</span>(); <span class="hljs-comment">// TypeError: &#x27;this&#x27; is not a Date object</span><br></code></pre></td></tr></table></figure><h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><blockquote><p>Reflect（反射） 可以使代理器模拟目标对象的某些原始行为</p></blockquote><p>如果不用Reflect，通过代理设置源对象的值的方法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target,property,value,receiver</span>) &#123;<br>        <span class="hljs-keyword">return</span> target[property] = value<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>用了Reflect之后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target,property,value,receiver</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(...<span class="hljs-variable language_">arguments</span>)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ol><li><p>Reflect 是什么？</p><ul><li>Reflect 是一个内置的 JS 对象，它提供了一系列方法，可以让开发者通过调用这些方法，访问一些 JS 底层功能。由于它类似于其他语言的<strong>反射</strong>，因此取名为 Reflect。</li></ul></li><li><p>它可以做什么？</p><ul><li>使用 Reflect 可以实现诸如：属性的赋值与取值、调用普通函数、调用构造函数、判断属性是否存在与对象中等等功能。</li></ul></li><li><p>这些功能不是已经存在了吗？为什么还需要用 Reflect 实现一次？</p><ul><li><p>有一个重要的理念，在 ES5 就被提出：减少魔法、让代码更加纯粹（语言的方法使用 API 实现，而不使用特殊语法实现），这种理念很大程度上是受到函数式编程的影响。</p></li><li><p>ES6 进一步贯彻了这种理念，它认为，对属性内存的控制、原型链的修改、函数的调用等等，这些都属于底层实现，属于一种魔法，因此，需要将它们提取出来，形成一个正常的 API，并高度聚合到某个对象中，于是就造就了 Reflect 对象。</p></li><li><p>因此，你可以看到 Reflect 对象中有很多的 API 都可以使用过去的某种语法或其他 API 实现。</p></li></ul></li><li><p>Reflect 里面提供了哪些 API 呢？</p></li></ol><table><thead><tr><th>Reflect API</th><th>用处</th><th>等同于</th></tr></thead><tbody><tr><td>Reflect.get(target, propertyKey)</td><td>读取对象 target 的属性 propertyKey</td><td>对象的属性值读取操作</td></tr><tr><td>Reflect.set(target, propertyKey, value)</td><td>设置对象 target 的属性 propertyKey 的值为 value</td><td>对象的属性赋值操作</td></tr><tr><td>Reflect.has(target, propertyKey)</td><td>判断一个对象是否拥有一个属性</td><td>in 操作符</td></tr><tr><td>Reflect.defineProperty(target, propertyKey, attributes)</td><td>类似于 Object.defineProperty，不同的是如果配置出现问题，返回 false 而不是报错</td><td>Object.defineProperty</td></tr><tr><td>Reflect.deleteProperty(target, propertyKey)</td><td>删除一个对象的属性</td><td>delete 操作符</td></tr><tr><td>Reflect.apply(target, thisArgument, argumentsList)</td><td>调用一个指定的函数，并绑定 this 和参数列表</td><td>函数调用操作</td></tr><tr><td>Reflect.construct(target, argumentsList)</td><td>用构造函数的方式创建一个对象</td><td>new 操作符</td></tr></tbody></table><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">其他更多的 Reflect API</a></p><h1 id="代理捕获器与反射方法"><a href="#代理捕获器与反射方法" class="headerlink" title="代理捕获器与反射方法"></a>代理捕获器与反射方法</h1><p>下面是 Proxy 支持的拦截操作一览，一共 13 种。</p><ul><li>get(target, propKey, receiver)：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</li><li>set(target, propKey, value, receiver)：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</li><li>has(target, propKey)：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</li><li>deleteProperty(target, propKey)：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</li><li>ownKeys(target)：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</li><li>getOwnPropertyDescriptor(target, propKey)：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li><li>defineProperty(target, propKey, propDesc)：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li><li>preventExtensions(target)：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li><li>getPrototypeOf(target)：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li><li>isExtensible(target)：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li><li>setPrototypeOf(target, proto)：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li><li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li><li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</li></ul><p>简单介绍几个拦截方法的使用方法：</p><h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, property, receiver</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;get()&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>);<br>  &#125;,<br>&#125;);<br>proxy.<span class="hljs-property">foo</span>; <span class="hljs-comment">// 触发get()捕获器</span><br></code></pre></td></tr></table></figure><p>返回值</p><ul><li>返回值无限制。</li></ul><p>拦截的操作</p><ul><li>proxy.property</li><li>proxy[property]</li><li>Object.create(proxy)[property]</li><li>Reflect.get(proxy, property, receiver)</li></ul><p>捕获器处理程序参数</p><ul><li>target：目标对象。</li><li>property：引用的目标对象上的字符串键属性。</li><li>receiver：代理对象或继承代理对象的对象。</li></ul><p>捕获器不变式</p><ul><li>如果 target.property 不可写且不可配置，则处理程序返回的值必须与 target.property 匹配。</li><li>如果 target.property 不可配置且[[Get]]特性为 undefined，处理程序的返回值也必须是 undefined。</li></ul><h2 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h2><p>set()捕获器会在设置属性值的操作中被调用。对应的反射 API 方法为 Reflect.set()。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value, receiver</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;set()&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(...<span class="hljs-variable language_">arguments</span>);<br>  &#125;,<br>&#125;);<br>proxy.<span class="hljs-property">foo</span> = <span class="hljs-string">&quot;bar&quot;</span>; <span class="hljs-comment">// 触发set()捕获器</span><br>复制代码<br></code></pre></td></tr></table></figure><ol><li>返回值<ul><li>返回 true 表示成功；返回 false 表示失败，严格模式下会抛出 TypeError。</li></ul></li><li>拦截的操作<ul><li>proxy.property &#x3D; value</li><li>proxy[property] &#x3D; value</li><li>Object.create(proxy)[property] &#x3D; value</li><li>Reflect.set(proxy, property, value, receiver)</li></ul></li><li>捕获器处理程序参数<ul><li>target：目标对象。</li><li>property：引用的目标对象上的字符串键属性。</li><li>value：要赋给属性的值。</li><li>receiver：接收最初赋值的对象。</li></ul></li><li>捕获器不变式<ul><li>如果 target.property 不可写且不可配置，则不能修改目标属性的值。</li><li>如果 target.property 不可配置且[[Set]]特性为 undefined，则不能修改目标属性的值。 在严格模式下，处理程序中返回 false 会抛出 TypeError。</li></ul></li></ol><h2 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h2><p>has()捕获器会在 in 操作符中被调用。对应的反射 API 方法为 Reflect.has()。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br>  <span class="hljs-title function_">has</span>(<span class="hljs-params">target, property</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;has()&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(...<span class="hljs-variable language_">arguments</span>);<br>  &#125;,<br>&#125;);<br><span class="hljs-string">&quot;foo&quot;</span> <span class="hljs-keyword">in</span> proxy; <span class="hljs-comment">//触发 has()捕获器</span><br>复制代码<br></code></pre></td></tr></table></figure><ol><li>返回值<ul><li>has()必须返回布尔值，表示属性是否存在。返回非布尔值会被转型为布尔值。</li></ul></li><li>拦截的操作<ul><li>property in proxy</li><li>property in Object.create(proxy)</li><li>with(proxy) {(property);}</li><li>Reflect.has(proxy, property)</li></ul></li><li>捕获器处理程序参数<ul><li>target：目标对象。</li><li>property：引用的目标对象上的字符串键属性。</li></ul></li><li>捕获器不变式<ul><li>如果 target.property 存在且不可配置，则处理程序必须返回 true。</li><li>如果 target.property 存在且目标对象不可扩展，则处理程序必须返回 true。</li></ul></li></ol><h2 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h2><p>apply()捕获器会在调用函数时中被调用。对应的反射 API 方法为 Reflect.apply()。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">myTarget</span> = (<span class="hljs-params"></span>) =&gt; &#123;&#125;;<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">target, thisArg, ...argumentsList</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;apply()&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(...<span class="hljs-variable language_">arguments</span>);<br>  &#125;,<br>&#125;);<br><span class="hljs-title function_">proxy</span>(); <span class="hljs-comment">// 触发apply()捕获器</span><br>复制代码<br></code></pre></td></tr></table></figure><ol><li>返回值<ul><li>返回值无限制。</li></ul></li><li>拦截的操作<ul><li>proxy(…argumentsList)</li><li>Function.prototype.apply(thisArg, argumentsList)</li><li>Function.prototype.call(thisArg, …argumentsList)</li><li>Reflect.apply(target, thisArgument, argumentsList)</li></ul></li><li>捕获器处理程序参数<ul><li>target：目标对象。</li><li>thisArg：调用函数时的 this 参数。</li><li>argumentsList：调用函数时的参数列表</li></ul></li><li>捕获器不变式<ul><li>target 必须是一个函数对象。</li></ul></li></ol><h2 id="construct"><a href="#construct" class="headerlink" title="construct()"></a>construct()</h2><p>construct()捕获器会在 new 操作符中被调用。对应的反射 API 方法为 Reflect.construct()。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;;<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br>  <span class="hljs-title function_">construct</span>(<span class="hljs-params">target, argumentsList, newTarget</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;construct()&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(...<span class="hljs-variable language_">arguments</span>);<br>  &#125;,<br>&#125;);<br><span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>(); <span class="hljs-comment">// 触发construct()捕获器</span><br>复制代码<br></code></pre></td></tr></table></figure><ol><li>返回值<ul><li>construct()必须返回一个对象。</li></ul></li><li>拦截的操作<ul><li>new proxy(…argumentsList)</li><li>Reflect.construct(target, argumentsList, newTarget)</li></ul></li><li>捕获器处理程序参数<ul><li>target：目标构造函数</li><li>argumentsList：传给目标构造函数的参数列表。</li><li>newTarget：最初被调用的构造函数。</li></ul></li><li>捕获器不变式<ul><li>target 必须可以用作构造函数。</li></ul></li></ol><h1 id="代理反射-VS-Object-defineProperty"><a href="#代理反射-VS-Object-defineProperty" class="headerlink" title="代理反射 VS Object.defineProperty"></a>代理反射 VS Object.defineProperty</h1><p>在上面使用Object.defineProperty的时候，我们遇到的问题有：</p><ol><li><p>一次只能对一个属性进行监听，需要遍历来对所有属性监听。这个我们在上面已经解决了。</p></li><li><p>在遇到一个对象的属性还是一个对象的情况下，需要递归监听。</p></li><li><p>对于对象的新增属性，需要手动监听</p></li><li><p>对于数组通过push、unshift方法增加的元素，也无法监听</p></li></ol><p>这些问题在Proxy中都轻松得到了解决。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《Javascript 高级程序设计(第 4 版)》（JS 红宝书）</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy">MDN - Proxy</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">MDN - Reflect</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迭代器与生成器</title>
    <link href="/2023/04/27/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <url>/2023/04/27/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>迭代：对一组固定的数据结构，按照一定顺序，多次执行某段代码块。</p><p>在ES6之前，执行迭代操作需要借助循环或者其他辅助结构才能做到。不同的数据结构执行迭代需要开发者写不同的循环和控制逻辑。</p><blockquote><p>比如对象需要使用Object.keys()然后对key数组进行遍历循环；需要手动控制迭代的结束（数组通过的.length长度进行控制什么时候结束）。</p></blockquote><p>不同的数据结构的迭代是该数据结构的固有逻辑，这类特定的数据结构（实现了可迭代协议的数据结构）都统一实现了一套逻辑或规范。</p><p>这套规范可以让开发者只关心迭代逻辑，不需要去控制循环和结束。迭代器调用*.next()*时需要帮我们做的事情有循环逻辑、终止逻辑、固有属性。</p><p><strong>由于可能存在一个变量，执行多次迭代逻辑，并且每次迭代互不影响</strong>。所以每个支持可迭代协议的数据类型都保存了一个迭代器构造函数数，每次执行迭代时生成</p><p>一个新的迭代器。每个可迭代数据类型都有一个<code>[Symbol.iterator]</code>属性，通过调用属性引用的迭代器构造函数生成一个新的迭代器。</p><blockquote><p>这个构造函数为了避免冲突和重名，使用了一个避免重名的数据类型Symbol类型。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> 可迭代数据结构()<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> a)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);   <span class="hljs-comment">// 执行完之后迭代器返回&#123;done:true&#125;</span><br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> a)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);  <span class="hljs-comment">// 如果使用的迭代器是同一个那么迭代器已经处于执行结束的状态了</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="可迭代协议"><a href="#可迭代协议" class="headerlink" title="可迭代协议"></a>可迭代协议</h2><p>JavaScript中实现了这套规范(协议)的有以下数据类型：</p><ul><li>字符串</li><li>数组</li><li>映射</li><li>arguments对象</li><li>NodeList等DOM集合类型</li></ul><p><strong>没有对象！</strong></p><p>支持迭代器模式的原生语言特性：</p><ul><li>for-of循环</li><li>数组解构</li><li>扩展操作符</li><li>Array.from()</li><li>创建集合</li><li>创建映射</li><li>Promise.all()接收由期约组成的可迭代对象</li><li>Promise.race()接收由期约组成的可迭代对象</li><li>yield* 操作符，在生成器中使用</li></ul><h2 id="自定义可迭代对象"><a href="#自定义可迭代对象" class="headerlink" title="自定义可迭代对象"></a>自定义可迭代对象</h2><p>给对象加上简单的自定义迭代器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">limit</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">limit</span> = limit;<br>    &#125;<br>    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]()&#123;<br>        <span class="hljs-keyword">let</span> count = <span class="hljs-number">1</span>;<br>        limit = <span class="hljs-variable language_">this</span>.<span class="hljs-property">limit</span>;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-keyword">if</span>(count &lt;= limit) &#123;<br>                    <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">done</span>:<span class="hljs-literal">false</span>,<span class="hljs-attr">value</span>:count++&#125;;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>&#125;;<span class="hljs-comment">// value没值了默认就是value</span><br>                &#125;<br>            &#125;,<br>            <span class="hljs-keyword">return</span>() &#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span> (<span class="hljs-string">&#x27;Exiting early&#x27;</span>);<br>                <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>&#125;;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> counter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> counter)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)&#125;  <span class="hljs-comment">// 1 2 3</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> counter)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)&#125;  <span class="hljs-comment">// 1 2 3</span><br></code></pre></td></tr></table></figure><p>有两种情况均会调用迭代器的return函数，return函数返回值也是个有标识迭代结束done变量为true的对象</p><blockquote><p>return函数相当干是一个声明周期钩子，在提前退出时会调用</p></blockquote><ul><li>for-of中的终止语句（break、continue、return、throw）</li><li>.next方法中的提前退出逻辑</li></ul><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>函数名称前面带一个星号表示它是一个生成器。（除了箭头函数）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> *<span class="hljs-title class_">Fun</span>()<br></code></pre></td></tr></table></figure><p>生成器函数的返回值是一个生成器对象，该对象实现了迭代器协议，是一个可迭代对象。故该对象拥有可迭代对象的特征：</p><ul><li>拥有一个.next()函数</li><li>返回值是一个包含标识下一个迭代值的value和表示是否结束done的对象</li><li>还有一个可选的一个提前退出的return函数</li></ul><p>迭代器对象是在数据结构的迭代器构造函数中声明next()方法逻辑；</p><p>生成器对象中的.next()函数返回值的返回逻辑在生成器函数中定义，生成器函数返回什么就是.next()的value。</p><blockquote><p>如果生成器函数中没有返回值没有return语句，生成器对象在调用一次.next()函数就会返回{done:true,value:undefined}的值</p><p>如果有return语句，.next()返回的value属性 就是函数的返回值done为true</p></blockquote><p>如果要对生成器对象调用多次.next()方法，生成多个迭代值怎么办? return 语句后面的语句就不执行了啊?</p><p>一个新的语法关键字<strong>yield</strong>由此而来</p><h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>yield关键字理解起来就是<strong>只可以在生成器函数中使用的高配版的return语句</strong>，每次执行到yield语句就会执行停止，返回yield后面的值，同时这个生成器函数的执</p><p>行上下文会被保留，在下次调用.next()函数时会执行之后的代码。</p><ul><li><strong>暂停函数执行，返回返回值</strong></li></ul><p>常见使用场景1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> *<span class="hljs-title function_">nTimes</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        <span class="hljs-keyword">yield</span> i;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> <span class="hljs-title function_">nTimes</span>(<span class="hljs-number">3</span>))&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)<br>&#125;<br><span class="hljs-comment">// 0 1 2</span><br></code></pre></td></tr></table></figure><p>常见使用场景2     利用生成器函数返回一个可迭代对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> *<span class="hljs-title function_">zeros</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">while</span>(n--) &#123;<br>       <span class="hljs-keyword">yield</span> <span class="hljs-number">0</span>; <br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-title function_">zeroes</span>(<span class="hljs-number">8</span>)))<br><span class="hljs-comment">//[0,0,0,0,0,0,0,0]</span><br></code></pre></td></tr></table></figure><ul><li><strong>接收参数</strong></li></ul><p>除了暂停函数执行，返回值。<strong>yield</strong>关键字还可以作为函数的中间参数使用，<em><em>下一个</em>.next()函数的第一个调用入参，会传给上一次让函数暂停的yield关键字</em>*。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFn</span>(<span class="hljs-params">initial</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(initial);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">yield</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">yield</span>);<br>&#125;<br><span class="hljs-keyword">let</span> generator0bject = <span class="hljs-title function_">generatorFn</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);  <span class="hljs-comment">// 生成器函数只会在初次调用next()方法后开始执行</span><br>generatorObject.<span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;bar&#x27;</span>); <span class="hljs-comment">// foo   先执行括号中的yield关键字取值取到yield就立刻暂停，还没有开始打印第二个字</span><br>generator0bject .<span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;baz&#x27;</span>); <span class="hljs-comment">// baz</span><br>generator0bject.<span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;qux&#x27;</span>); <span class="hljs-comment">// qux</span><br></code></pre></td></tr></table></figure><ul><li>给<strong>yield</strong>语法增加星号，可以将其后面的可迭代对象序列化为一连串值</li></ul><p>遇到<strong>yield</strong><em>语句，可以将<strong>yield</strong></em>理解为一个for-of循环，<em><em>yield</em> &#x3D;  for-of</em>*</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFn</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">yield</span>* [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>&#125;<br><span class="hljs-keyword">let</span> generator0bject = <span class="hljs-title function_">generatorFn</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> X <span class="hljs-keyword">of</span> <span class="hljs-title function_">generatorFn</span>()) &#123;<br><span class="hljs-variable language_">console</span>.1og(x);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当做默认迭代器</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">values</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>    &#125;<br>    *[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]()&#123;  <span class="hljs-comment">// 生成器函数直接当做迭代器构造函数,表示Foo类型的Symbol.iterator属性是一个生成器函数，返回值就是一个可迭代对象</span><br>        <span class="hljs-keyword">yield</span>* <span class="hljs-variable language_">this</span>.<span class="hljs-property">values</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>对象的.next()方法返回值为yield的返回值，yield又解析了可迭代数据类型数组this.values</p></blockquote><h2 id="终止生成器对象"><a href="#终止生成器对象" class="headerlink" title="终止生成器对象"></a>终止生成器对象</h2><ul><li>return</li><li>throw</li></ul><p>和迭代器不一样的是，生成器调用这两个函数可以强制生成器对象进入中止状态，done会变成true，value就是return语句传入的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFn</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> X <span class="hljs-keyword">of</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>，<span class="hljs-number">3</span>]) &#123;<br>        <span class="hljs-keyword">yield</span> x;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> g = <span class="hljs-title function_">generatorFn</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g.<span class="hljs-keyword">return</span>(<span class="hljs-number">4</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g);<br></code></pre></td></tr></table></figure><p>而throw语句则表示传入生成器一个异常，如果生成器内部没有接住这个异常，生成器对象会强制进入中止状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFn</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> X <span class="hljs-keyword">of</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>，<span class="hljs-number">3</span>]) &#123;<br>        <span class="hljs-keyword">yield</span> x;   <span class="hljs-comment">// 内部无catch语法接住异常</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> g = <span class="hljs-title function_">generatorFn</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g); <span class="hljs-comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span><br><span class="hljs-keyword">try</span> &#123;<br>    g.<span class="hljs-keyword">throw</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br>&#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e) <span class="hljs-comment">//foo</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g); <span class="hljs-comment">// generatorFn &#123;&lt;closed&gt;&#125;</span><br></code></pre></td></tr></table></figure><p>但是如果内部有catch语法并且接住了这个异常，则生成器则不会关闭。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFn</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> X <span class="hljs-keyword">of</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>，<span class="hljs-number">3</span>]) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">yield</span> x;<br>        &#125; <span class="hljs-keyword">catch</span>(e)&#123;&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> g = <span class="hljs-title function_">generatorFn</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; done: false, value: 1&#125;</span><br>g.<span class="hljs-keyword">throw</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g.<span class="hljs-property">next</span>); <span class="hljs-comment">// &#123; done: false, value: 3&#125;</span><br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《Javascript 高级程序设计(第 4 版)》（JS 红宝书）</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS3特性</title>
    <link href="/2023/04/19/CSS3%E7%89%B9%E6%80%A7/"/>
    <url>/2023/04/19/CSS3%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS3特性"><a href="#CSS3特性" class="headerlink" title="CSS3特性"></a>CSS3特性</h1><h2 id="⭐️-响应式布局"><a href="#⭐️-响应式布局" class="headerlink" title="⭐️ 响应式布局"></a>⭐️ 响应式布局</h2><h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><ul><li><p>媒体类型</p><p>示例</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> print &#123;<br>    <span class="hljs-selector-tag">h1</span>&#123;<br>        <span class="hljs-attribute">background</span>: transparent;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>all</td><td>检测所有设备。</td></tr><tr><td>screen</td><td>检测电子屏幕，包括:电脑屏幕、平板屏幕、手机屏幕等。</td></tr><tr><td>print</td><td>检测打印机。</td></tr></tbody></table><p>完整列表参考：<a href="http://developer.mozilla.org/zh-CN/docs/Web/CSS/@media">http://developer.mozilla.org/zh-CN/docs/Web/CSS/@media</a></p></li><li><p>媒体特性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 检测到当前视口的宽度为800px时，应用如下样式 */</span><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">width</span>:<span class="hljs-number">800px</span>) &#123;<br>    <span class="hljs-selector-tag">h1</span> &#123;<br>        <span class="hljs-attribute">background-color</span>: green;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/* 检测到当前视口的宽度小于等于700px时，应用如下样式 */</span><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>:<span class="hljs-number">700px</span>) &#123;<br>    <span class="hljs-selector-tag">h1</span> &#123;<br>        <span class="hljs-attribute">background-color</span>: orange;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 检测到当前视口的宽度大于等于900px时，应用如下样式 */</span><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>:<span class="hljs-number">700px</span>) &#123;<br>    <span class="hljs-selector-tag">h1</span> &#123;<br>        <span class="hljs-attribute">background-color</span>: deepskyblue;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 检测到屏幕的宽度等于1536时，应用如下样式 */</span><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">device-width</span>:<span class="hljs-number">1536px</span>) &#123;<br>    <span class="hljs-selector-tag">h1</span> &#123;<br>       <span class="hljs-attribute">color</span>: white;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>完整列表参考：<a href="http://developer.mozilla.org/zh-CN/docs/Web/CSS/@media">http://developer.mozilla.org/zh-CN/docs/Web/CSS/@media</a></p></li><li><p>运算符</p><p>示例</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 且运算符 */</span><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>:<span class="hljs-number">700px</span>) <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>:<span class="hljs-number">800px</span>) &#123;<br>    <span class="hljs-selector-tag">h1</span>&#123;<br>         <span class="hljs-attribute">background-color</span>: orange;<br>    &#125;<br>&#125;  <br></code></pre></td></tr></table></figure><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>and</td><td>并且</td></tr><tr><td>,或or</td><td>或</td></tr><tr><td>not</td><td>否定</td></tr><tr><td>only</td><td>肯定</td></tr></tbody></table></li><li><p>常用阈值</p><p>在实际开发中，会将屏幕划分成几个区间，例如 超小屏幕-768px-中等屏幕-992px-大屏幕-1200px-超大屏幕</p><p>开发中常用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;link rel=&quot; stylesheet&quot; media=&quot;具体的媒体查询” href= &quot;./css/huge<span class="hljs-selector-class">.css</span>&quot;&gt;<br>// 大屏幕的样式单独写在huge<span class="hljs-selector-class">.css</span>中即可<br></code></pre></td></tr></table></figure></li></ul><h3 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h3><p>由于<code>Flex</code> 布局比较重要且常用，作者会单独开一篇文章。</p><h3 id="Grid-布局"><a href="#Grid-布局" class="headerlink" title="Grid 布局"></a>Grid 布局</h3><p><code>CSS3</code>引入的一种新的布局模型——<code>Grids</code>网格布局，目前暂未推广使用，使用频率较低，此处不作介绍。</p><h3 id="瀑布流"><a href="#瀑布流" class="headerlink" title="瀑布流"></a>瀑布流</h3><p><code>CSS3</code> 的<code>Multi-columns</code>是最早尝试使用纯CSS方法解决瀑布流布局的方法。</p><p>通过Multi-columns相关的属性<code>column-count</code>、<code>column-gap</code>配合<code>break-inside</code>可以实现瀑布流布局。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.masonry</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">column-count</span>: <span class="hljs-number">2</span>;</span><br><span class="language-css">        <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.item</span> &#123;</span><br><span class="language-css">        <span class="hljs-comment">/* 定义页面、列或区域发生中断时候的元素该如何表现。如果没有中断，则忽略该属性。*/</span></span><br><span class="language-css">        <span class="hljs-attribute">break-inside</span>: avoid; </span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;masonry&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color: pink&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item__content&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color: green&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item__content&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color: red&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item__content&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- more items --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>更优的解决方案还有Flex中使用列容器，使用Flexbox布局，对于<code>.item</code>可以不再使用<code>break-inside:avoid</code>。一般使用这个方法。</p><p>其他解决方案还有Grid布局，不过缺点是对于堆栈（列表项目）高度不能友好的控制。</p><h2 id="新增盒子属性"><a href="#新增盒子属性" class="headerlink" title="新增盒子属性"></a>新增盒子属性</h2><h3 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box- sizing"></a>box- sizing</h3><p><code>CSS3</code>中可以通过<code>box- sizing</code>来指定盒模型，有2个值：即可指定为<code>content- box</code>、<code>border-box</code>，这样我们计算盒子大小的方式就发生了改变。</p><ul><li>box-sizing: content-box   width和height设置的是盒子内容区的大小  盒子总大小 &#x3D; width + padding + border ( 默认模式)</li><li><strong>box-sizing: border-box</strong>    width和height设置的是盒子总大小</li></ul><h3 id="resize改变大小"><a href="#resize改变大小" class="headerlink" title="resize改变大小"></a>resize改变大小</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;<br>    <span class="hljs-attribute">width</span>:<span class="hljs-number">400px</span>;<br>    <span class="hljs-attribute">height</span>:<span class="hljs-number">400px</span>;<br>    <span class="hljs-attribute">background-color</span>:orange;<br>    // 如果想实现<span class="hljs-attribute">resize</span>必须添加<span class="hljs-attribute">overflow</span>属性<br>    <span class="hljs-attribute">overflow</span>:hidden; <br>    // 可以调节水平 || 垂直 || 两个方向的盒子大小,<span class="hljs-attribute">none</span>是默认的不允许用户调整元素大小<br>    <span class="hljs-attribute">resize</span>:horizontal || vertical || both || none<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>overflow的值为hidden即超出隐藏，为auto即超出使用滚动条 ，为scroll时一直有滚动条。</p></blockquote><h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><p><strong>盒子阴影box-shadow</strong></p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>h-shadow</td><td>必填。水平阴影的位置。允许负值。</td></tr><tr><td>v-shadow</td><td>必填。垂直阴影的位置。允许负值。</td></tr><tr><td>blur</td><td>可选。模糊距离。</td></tr><tr><td>spread</td><td>可选。阴影的尺寸。</td></tr><tr><td>color</td><td>可选。阴影的颜色。</td></tr><tr><td>inset</td><td>可选。将外部阴影(outset) 改为内部阴影。</td></tr></tbody></table><p>默认<code>box-shadow:none</code>表示没有阴影。</p><p>示例</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">10px</span> <span class="hljs-number">10px</span> <span class="hljs-number">10px</span> <span class="hljs-number">10px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, .<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p><strong>文字阴影text-shadow</strong></p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>h-shadow</td><td>必填。水平阴影的位置。允许负值。</td></tr><tr><td>v-shadow</td><td>必填。垂直阴影的位置。允许负值。</td></tr><tr><td>blur</td><td>可选。模糊距离。</td></tr><tr><td>color</td><td>可选。阴影的颜色。</td></tr></tbody></table><p>示例</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">text-shadow</span>: <span class="hljs-number">5px</span> <span class="hljs-number">5px</span> <span class="hljs-number">6px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, .<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h3 id="opacity透明度"><a href="#opacity透明度" class="headerlink" title="opacity透明度"></a>opacity透明度</h3><p>opacity属性能为整个元素添和透明效果，<strong>值是0到1之间的小数，0是完全透明，1 表示完全不透明</strong>。</p><blockquote><p>opacity与rgba的区别?</p><p>opacity是一个属性，设置的是整个元素(包括元素里的内容)的不透明度。rgba的透明度，仅调整颜色的透明度。</p></blockquote><h2 id="新增选择器"><a href="#新增选择器" class="headerlink" title="新增选择器"></a>新增选择器</h2><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><table><thead><tr><th>选择符</th><th>简介</th></tr></thead><tbody><tr><td>E[att]</td><td>选择具有att属性的E元素</td></tr><tr><td>E[att&#x3D;”val”]</td><td>选择具有att属性且属性值等于val的E元素</td></tr><tr><td>E[att^&#x3D;”val”]</td><td>匹配具有att 属性且值以val开头的E元素</td></tr><tr><td>E[att$&#x3D;”val”]</td><td>匹配具有att属性且值以val结尾的E元素</td></tr><tr><td>E[att*&#x3D;”val”]</td><td>匹配具有att属性且值中含有val的E元素</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-comment">/*只选择type=text 文本框的input 选取出来*/</span></span><br><span class="language-css">    <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=text]</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">color</span>:pink;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-comment">/*选择首先是div然后具有class属性并且属性值必须是icon开头的这些元素*/</span></span><br><span class="language-css">    <span class="hljs-selector-tag">div</span><span class="hljs-selector-attr">[class^=icon]</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">color</span>:red;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><br><span class="language-css"></span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span>  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span>  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon1&quot;</span> &gt;</span>小图标1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon2&quot;</span> &gt;</span>小图标2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon3&quot;</span> &gt;</span>小图标3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h3><table><thead><tr><th>选择器</th><th>简介</th></tr></thead><tbody><tr><td>E:first-child</td><td>匹配父元素中的第一个子元素 E</td></tr><tr><td>E:last-child</td><td>匹配父元素中最后一一个E元素</td></tr><tr><td>E:nth-child(n)</td><td>匹配父元素中的第n个子元素E</td></tr><tr><td>E:first-of-type</td><td>指定类型E的第一个</td></tr><tr><td>E:last-of-type</td><td>指定类型E的最后一个</td></tr><tr><td>E:nth-of-type(n)</td><td>指定类型E的第n个</td></tr></tbody></table><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 2.选择uL里面的最后一个孩子小Li */</span><br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-pseudo">:last-child</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: pink;<br>&#125;<br><span class="hljs-comment">/* 3.选择uL里面的第2个孩子小Li */</span><br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-attribute">background-color</span>:D skyblue;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>nth-child (n)</code>选择某个父元素的一个或多个特定的子元素，n可以是数字，关键字和公式</p><ul><li>n如果是数字，就是选择第n个子元素，里面数字从1开始…</li><li>n可以是关键字: even偶数, odd奇数</li><li>n可以是公式:常见的公式如下(如果n是公式,则从0开始计算,但是第0个元素或者超出了元素的个数会被忽略)</li></ul><h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><p>使用场景：伪元素选择器可以帮助我们利用CSS创建新标签元素，而不需要HTML标签，从而简化HTML结构。</p><table><thead><tr><th>选择器</th><th>简介</th></tr></thead><tbody><tr><td>::before</td><td>在元素<strong>内部</strong>的前面插入内容</td></tr><tr><td>::after</td><td>在元素<strong>内部</strong>的后面插入内容</td></tr></tbody></table><ul><li>语法：element::before{} </li><li>before和after必须有<strong>content属性</strong></li><li>由于创建的伪元素是<strong>行内元素</strong>，设置宽高不起作用，要转化为block或者inline-block，或者带浮动、定位。<strong>更多的与定位搭配使用</strong>。</li><li>伪元素选择器和标签选择器一样，权重为1。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">div</span>::before &#123;  <span class="hljs-comment">// 权重是2</span><br>    <span class="hljs-comment">/*这个content是必须要 写的*/</span><br>    <span class="hljs-attr">display</span>: inline-block;<br>    <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;我&#x27;</span>;<br>    <span class="hljs-attr">width</span>: 30px;<br>    <span class="hljs-attr">height</span>: 40px;<br>    background-<span class="hljs-attr">color</span>: purple;<br>&#125;<br><span class="hljs-attr">div</span>: :after &#123;<br>    <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;小猪佩奇 &#x27;</span>;<br>&#125;<br><br>&lt;div&gt;是&lt;div/&gt;<br></code></pre></td></tr></table></figure><h2 id="新增样式"><a href="#新增样式" class="headerlink" title="新增样式"></a>新增样式</h2><h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><ul><li><p>线性渐变</p><p>多个颜色之间的渐变，默认是<strong>从上到下</strong>渐变。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>( red, yellow, green);<br></code></pre></td></tr></table></figure><p>使用<strong>关键词设置线性渐变的方向</strong>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background</span>- image: <span class="hljs-built_in">linear-gradient</span>(to top, red, yellow, green);<br><span class="hljs-attribute">background</span>- image: <span class="hljs-built_in">linear-gradient</span>(to right top, red, yellow, green);<br></code></pre></td></tr></table></figure><p>使用<strong>角度设置线性渐变的方向</strong>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">30deg</span>, red, yellow, green);<br></code></pre></td></tr></table></figure><p>调整开始<strong>渐变的位置</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(red <span class="hljs-number">50px</span>, yellow <span class="hljs-number">100px</span> green <span class="hljs-number">150px</span>);<br></code></pre></td></tr></table></figure></li><li><p>径向渐变</p><p>多个颜色之间的渐变，默认从圆心向外发散。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">radial-gradient</span>(red,yellow,green);<br></code></pre></td></tr></table></figure><p>使用关键词调整渐变圆的圆心位置。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">radial-gradient</span>(at right top, red, yellow, green);<br></code></pre></td></tr></table></figure><p>使用像索值调整渐交圆的圆心位置。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">radial-gradient</span>(at <span class="hljs-number">100px</span> <span class="hljs-number">50px</span>, red, yellow, green);<br></code></pre></td></tr></table></figure><p>调整渐变形状为正圆。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">radial-gradient</span>(circle, red, yellow, green);<br></code></pre></td></tr></table></figure><p>调整形状的半径。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">radial-gradient</span>(<span class="hljs-number">100px</span>, red, yellow, green);<br><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">radial-gradient</span>(<span class="hljs-number">50px</span> <span class="hljs-number">100px</span>, red, yellow, green); <br></code></pre></td></tr></table></figure><p>调整开始渐变的位置。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">radial-gradient</span>(red <span class="hljs-number">50px</span>, yellow <span class="hljs-number">108px</span>, green <span class="hljs-number">158px</span>);<br></code></pre></td></tr></table></figure></li><li><p>重复渐变</p><p>在没有发生渐变的区域（纯色区域），重新开始渐变，就是重复渐变</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box1</span> &#123;<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">repeating-linear-gradient</span>(red <span class="hljs-number">50px</span>, yellow <span class="hljs-number">100px</span>, green <span class="hljs-number">150px</span>);<br>&#125;<br><span class="hljs-selector-class">.box2</span> &#123;<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">repeating-radial-gradient</span>(red <span class="hljs-number">50px</span>, yellow <span class="hljs-number">100px</span>, green <span class="hljs-number">150px</span>);<br>&#125;  <br></code></pre></td></tr></table></figure></li></ul><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><ul><li><p>圆角</p><p>使用<code>border-radius</code>可以将盒子变为圆角</p><p>同时设置四个角的圆角示例</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border-radius</span>:<span class="hljs-number">10px</span>;<br></code></pre></td></tr></table></figure></li><li><p>外轮廓</p><p>可以理解为盒子发出的“光”，不占位置，不参数盒子大小计算。</p><ul><li><p><code>outline-width</code>：外轮廓的宽度</p></li><li><p><code>outline-color</code>：外轮廓的颜色</p></li><li><p><code>outline-style</code>：外轮廓的风格</p><ul><li><code>none</code>：无轮廓</li><li><code>dotted</code>：点状轮廓</li><li><code>dashed</code>：虚线轮廓</li><li><code>solid</code>：实线轮廓</li><li><code>double</code>：双线轮廓</li></ul></li><li><p><code>outline-offset</code>：设置外轮廓与边框的距离，正负值都可以设置。</p><blockquote><p>outline-offset不是outline的子属性，是一个独立的属性。</p></blockquote></li><li><p><code>outline</code>：复合属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">outline</span>:<span class="hljs-number">50px</span> solid blue;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><h4 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h4><ul><li><p>文本阴影<code>text-shadow</code>在前面谈新增盒子属性阴影时一并说了。</p></li><li><p>文本换行<code>white-space</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">white-space</span>:normal | pre | pre-wrap | pre-line | nowrap<br></code></pre></td></tr></table></figure><ul><li><code>normal</code>：文本超出边界自动换行，文本中的换行被测览器识别为一个空格。(默认值)</li><li><code>pre</code>：原样输出，与<code>pre</code>标签的效果相同。</li><li><code>pre-wrap </code>：在<code>pre</code>果的基础上，超出元素边界自动换行，且只识别文本中的换行，空格会忽略。</li><li><code>nowrap</code>：强制不换行。</li></ul></li><li><p>文本溢出<code>text-overflow</code></p><p>常用值</p><ul><li><code>clip</code>：当内联内容溢出时，将溢出部分裁剪掉。</li><li><code>ellipsis</code>：当内联内容溢出块容器时，将溢出部分替换为…。</li></ul><blockquote><p>要使得<code>text-overflow</code>属性生效，块容器必须显式定义overflow为非visible值，<code>white-space</code>为<code>nowrap</code>值。</p></blockquote></li><li><p>文本修饰<code>text-decoration</code></p><p>CSS3将<code>text-decoration</code>升级成了一个复合属性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">text-decoration</span>: text-decoration-line || text-decoration-style || text-decoration-color<br></code></pre></td></tr></table></figure><ul><li><code>text-decoration-line</code> 设置文本装饰线的位置<ul><li><code>none</code>：指定文字无装饰（默认值）</li><li><code>underline</code>：指定文字的装饰是下划线</li><li><code>overline</code>：指定文字的装饰是上划线</li><li><code>line-through</code>：指定文字的装饰是贯穿线</li></ul></li><li><code>text-decoration-style</code> 文本装饰线条的形状<ul><li><code>solid</code>：实线（默认）</li><li><code>double</code>：双线</li><li><code>dotted</code>：点状线条</li><li><code>dashed</code>：虚线</li><li><code>wavy</code>：波浪线</li></ul></li><li><code>text-decoration-color</code>文本装饰线条的颜色</li></ul></li><li><p>文本描边<code>-webkit-text-stroke</code></p><p>文本描边属性仅<code>webkit</code>内核浏览器支持</p><ul><li><code>-webkit-text-stroke-width</code>：设置文字描边的宽度，写长度值。</li><li><code>-webkit-text-stroke-color</code>：设置文字描边的颜色，写颜色值。</li><li><code>-webkit-text-stroke</code>：复合属性,设置文字描边宽度和颜色。</li></ul></li></ul><h4 id="web字体"><a href="#web字体" class="headerlink" title="web字体"></a>web字体</h4><ul><li>相比图片更加清晰。</li><li>灵活性高，更方便改变大小、颜色、风格等。</li><li>兼容性好，IE 也能支持。</li></ul><p>参考阿中图标百网地址： <a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></p><h3 id="滤镜filter"><a href="#滤镜filter" class="headerlink" title="滤镜filter"></a>滤镜filter</h3><p>filter CSS属性将模糊或颜色偏移等图形效果应用于元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* blur是一个函数小括号里面数值越大，图片越模糊注意数值要加px单位*/</span><br><span class="hljs-attribute">filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">5px</span>);  <br></code></pre></td></tr></table></figure><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li><p>background-origin</p><p>用于设置背景图的原点。默认原点是从padding的左上角开始的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-origin</span>:<span class="hljs-built_in">padding-box</span>(默认) | content-box | border-box<br></code></pre></td></tr></table></figure></li><li><p>background-clip</p><p>设置背景图的向外裁剪的区域。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-origin</span>:<span class="hljs-built_in">border-box</span>(默认) | padding-box | content-box | text<br></code></pre></td></tr></table></figure><ul><li>border-box: 从border区域开始向外裁剪背景。- -默认值</li><li>padding- box:从padding区域开始向外裁剪背景。</li><li>content- box:从content区域开始向外裁剪背品。</li><li>text: 背景图只呈现在文字上。</li></ul></li></ul><blockquote><p>若值为text，那么backgroun-clip要加上-webkit-前缀。</p></blockquote><ul><li><p>background-size</p><p>语法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-size</span>: length|percentage|cover|contain;<br></code></pre></td></tr></table></figure><ul><li>length：设置背景图片的高度与宽度。第一个值设置宽度，第二个值为高度。</li><li>percentage：将计算相对于背景定位区域的百分比。第一个值设置宽度，第二个值为高度。</li><li>cover：保持图像的横纵比将图像缩放成完全覆盖背景定位区域的最小大小。</li><li>contain：保持图像的横纵比将图像缩放成适应背景区域的最大大小。</li></ul></li><li><p>background-复合属性</p><p>语法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background</span>:背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置 原点位置 向外裁剪的区域<br></code></pre></td></tr></table></figure><p>顺序不要求一致，可自动识别</p><blockquote><p>origin和cltp的值如果-样，如果只写一一个值，则origin和clip都设置:如果设置了两个值，前面的是origin,后面的clip.</p></blockquote></li><li><p>多背景图</p><p>CSS3允许元素设置多个背景图片</p><p>示例</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 添加多个背景图 */</span> <br><span class="hljs-attribute">background</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">../images/bg-lt.png</span>) np-repeat,<br>           <span class="hljs-built_in">url</span>(<span class="hljs-string">../images/bg-rt.png</span>) np-repeat right top,<br>           <span class="hljs-built_in">url</span>(<span class="hljs-string">../images/bg-lb.png</span>) np-repeat left bottom,<br>           <span class="hljs-built_in">url</span>(<span class="hljs-string">../images/bg-rb.png</span>) np-repeat right bottom;<br></code></pre></td></tr></table></figure></li></ul><h2 id="新增长度单位"><a href="#新增长度单位" class="headerlink" title="新增长度单位"></a>新增长度单位</h2><p>CSS2的长度单位有px（像素单位）、%、em（相对于当前元素的字体尺寸），CSS3新增了rem（相对于根元素字体大小）、<strong>vw</strong>（相对于视窗宽度）、<strong>vh</strong>（相对</p><p>于视窗高度）、vmax、vmin长度单位。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">50vw</span>; <br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">20vw</span>;<br>    <span class="hljs-attribute">background-color</span>: green;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="计算宽度calc"><a href="#计算宽度calc" class="headerlink" title="计算宽度calc"></a>计算宽度calc</h3><p>此CSS函数让你在声明CSS属性值时执行一些计算。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">width: calc(100% 80px);<br></code></pre></td></tr></table></figure><p>括号里面可以使用+ 、—、*、&#x2F; 来进行计算。</p><h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><p>过渡动画：是从一个状态渐渐的过渡到另外一个状态。</p><blockquote><p>过渡( transition)是CSS3中具有颠覆性的特征之一，我们可以在不使用 Flash 动画或JavaScript的情况下，控制元素属性发生变化时的过程效果。经常和<code>:hover</code></p><p>一起搭配使用。</p></blockquote><p>格式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transition</span>:要过渡的属性  花费时间  运动曲线  何时开始;<br></code></pre></td></tr></table></figure><ul><li>属性：想要变化的css属性，宽度高度背景颜色内外边距都可以。如果想要所有的属性都变化过渡，写一个<strong>all</strong> 就可以。</li><li>花费时间：单位是秒(必须写单位)比如0.5s</li><li>运动曲线：默认是ease：逐渐慢下来  linear：匀速    ease-in：加速   ease-out：减速   ease-in-out：先加速后减速</li><li>何时开始：单位是秒(必)可以设置延迟触发时间  默认是0s ( 可以省略)</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">background-color</span>: pink;<br>    <span class="hljs-comment">/* transition:变化的属性  花费时间  运动曲线   何时开始 */</span><br>    <span class="hljs-attribute">transition</span>: width .<span class="hljs-number">5s</span>;<br>     <span class="hljs-comment">/* transition: width .5s,height .5s; */</span><br>&#125;<br><br><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>    // <span class="hljs-attribute">height</span>:<span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>动画( animation )可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。</p><p>相比较过渡，动画可以实现更多变化，更多控制，比如连续<strong>自动播放</strong>等效果是过渡做不了的。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol><li><p>先定义动画</p><p>用Keyframes定义动画（类似定义类选择器）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">// move是自定义的动画 <br><span class="hljs-keyword">@keyframs</span> move &#123;<br>    <span class="hljs-comment">/* 开始状态 */</span><br>    <span class="hljs-number">0%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0px</span>); <br>    &#125;<br>    <span class="hljs-comment">/* 结束状态 */</span><br>    <span class="hljs-number">100%</span>&#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">1000px</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>再使用（调用）动画</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">// 调用动画<br><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">width</span>:<span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">height</span>:<span class="hljs-number">200px</span>;<br>    <span class="hljs-comment">/* 调用动画 */</span><br>    <span class="hljs-attribute">animation-name</span>:move;<br>    <span class="hljs-comment">/* 持续时间 */</span><br>    <span class="hljs-attribute">animation-duration</span>:<span class="hljs-number">2s</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="动画序列"><a href="#动画序列" class="headerlink" title="动画序列"></a>动画序列</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs css">// 可以做多个状态的变化 里面的百分比是总时间的划分 <br><span class="hljs-keyword">@keyframs</span> move &#123;<br>    <span class="hljs-comment">/* 开始状态 */</span><br>    <span class="hljs-number">0%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>); <br>    &#125;<br>    <span class="hljs-number">25%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">10000px</span>,<span class="hljs-number">0</span>); <br>    &#125;<br>    <span class="hljs-number">50%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">1000px</span>,<span class="hljs-number">500px</span>); <br>    &#125;<br>    <span class="hljs-number">75%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">0</span>,<span class="hljs-number">500px</span>); <br>    &#125;<br>    <span class="hljs-comment">/* 结束状态 */</span><br>    <span class="hljs-number">100%</span> &#123;<br>       <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>); <br>    &#125;<br>&#125;<br><br>// 调用动画<br><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">width</span>:<span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">height</span>:<span class="hljs-number">200px</span>;<br>    <span class="hljs-comment">/* 调用动画 */</span><br>    <span class="hljs-attribute">animation-name</span>:move;<br>    <span class="hljs-comment">/* 持续时间 */</span><br>    <span class="hljs-attribute">animation-duration</span>:<span class="hljs-number">10s</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动画常见属性"><a href="#动画常见属性" class="headerlink" title="动画常见属性"></a>动画常见属性</h3><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>@keyframes</td><td>规定动画</td></tr><tr><td>animation</td><td>所有动画属性的简写属性,除了animation-play-state属性。</td></tr><tr><td><strong>animation-name</strong></td><td>规定@keyframes动画的名称。( 必填)</td></tr><tr><td><strong>animation-duration</strong></td><td>规定动画完成一个周期所花费的秒或毫秒 ，默认是0。( 必填)</td></tr><tr><td>animation-timing-function</td><td>规定动画的速度曲线，默认是”ease” 。</td></tr><tr><td>animation-delay</td><td>规定动画何时开始，默认是0。</td></tr><tr><td>animation-iteration-count</td><td>规定动画被播放的次数，默认是1 ，还有infinite。</td></tr><tr><td>animation-direction</td><td>规定动画是否在下一周期逆向播放，默认是”normal “,alternate逆播放。</td></tr><tr><td>animation-play-state</td><td>规定动画是否正在运行或暂停。默认是”running ，还有”paused”。</td></tr><tr><td>animation-fill-mode</td><td>规定动画结束后状态，保持forwards回到起始backwards。</td></tr></tbody></table><p>简写形式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">animation</span>: 动画名称  持续时间  运动曲线  何时开始  播放次数  是否反方向  动画起始或者结束的状态;<br></code></pre></td></tr></table></figure><ul><li>简写属性里面不包含animation-play- state</li><li>暂停动画: animation-play-state: puased; 经常和鼠标经过等其他配合使用</li><li>想要动画走回来, 而不是直接跳回来: animation-direction : alternate</li><li>盒子动画结束后,停在结束位置: animatiofnfill-mode : forwards</li></ul><h2 id="2D-x2F-3D-转换"><a href="#2D-x2F-3D-转换" class="headerlink" title="2D &#x2F; 3D 转换"></a>2D &#x2F; 3D 转换</h2><p><strong>转换transform</strong>是CSS3中具有颠覆性的特征之一，可以实现元素的位移、旋转、缩放等效果。</p><p><strong>常常与过渡结合，将转换写在hover中。实现鼠标经过慢动作展示移动、旋转、缩放。</strong></p><h3 id="二维坐标系"><a href="#二维坐标系" class="headerlink" title="二维坐标系"></a>二维坐标系</h3><h4 id="移动translate"><a href="#移动translate" class="headerlink" title="移动translate"></a>移动translate</h4><p>2D移动是2D转换里面的一种功能，可以改变元素在页面中的位置，类似定位。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>:<span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">height</span>:<span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background-color</span>:pink;<br>    <span class="hljs-comment">/* x就是x轴上移动位置y就是y辅上移动位置 中间用逗号分隔*/</span><br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">100px</span>, <span class="hljs-number">100px</span>);<br>     <span class="hljs-comment">/* 参数可以用%，按照盒子自身的宽度或者高度来对比*/</span><br>    // <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定义2D转换中的移动,沿着X和Y轴移动元素</li><li>translate最大的优点 :不会影响到其他元素的位置</li><li>translate中的百分比单位是相对于自身元素的 translate:(50%,50%);</li><li>对行内标签没有效果</li></ul><h4 id="旋转rotate"><a href="#旋转rotate" class="headerlink" title="旋转rotate"></a>旋转rotate</h4><p>2D旋转指的是让元素在2维平面内顺时针旋转或者逆时针旋转。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span> &#123;<br>    <span class="hljs-attribute">width</span>:<span class="hljs-number">150px</span>;<br>    <span class="hljs-comment">/* 顺时针旋转45度 */</span><br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">45deg</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>rotate里面跟度数，单位是deg比如rotate(45deg)</li><li>角度为正时，顺时针，负时，为逆时针</li><li>默认旋转的中心点是元素的中心点</li></ul><p>改变旋转中心点transform-origin </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transform-origin</span>: x y;  //x,y默认是<span class="hljs-number">50%</span><br></code></pre></td></tr></table></figure><blockquote><p>还可以给xy设置像素或者方位名词 ( top bottom left right center )</p></blockquote><p>旋转<code>rotate</code>和过度<code>transition</code>结合可以实现旋转的过程展示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span> &#123;<br>    <span class="hljs-attribute">width</span>:<span class="hljs-number">150px</span>;<br>    <span class="hljs-comment">/* 顺时针旋转45度 */</span><br>    <span class="hljs-attribute">transition</span>:all <span class="hljs-number">0.3s</span>;<br>&#125;<br><span class="hljs-selector-tag">img</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">360deg</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="缩放scale"><a href="#缩放scale" class="headerlink" title="缩放scale"></a>缩放scale</h4><p>只要给元素添加上了这个属性就能控制它放大还是缩小。</p><p>语法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(x,y);  // x,y表示放大多少倍.只写一个参数的话第二个参数和第一个参数一样<br></code></pre></td></tr></table></figure><p>可以设置转换中心点缩放，默认以中心点缩放的,而且不影响其他盒子</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transform-origin</span>: x y;  <br></code></pre></td></tr></table></figure><h4 id="2D转换综合写法"><a href="#2D转换综合写法" class="headerlink" title="2D转换综合写法"></a>2D转换综合写法</h4><ol><li>同时使用多个转换,其格式为: transform: translate() rotate()scale0) .等</li><li>其顺序会影转换的效果。( 先旋转会改变坐标轴方向)</li><li>当我们同时有位移和其他属性的时候,记得要将位移放到最前</li></ol><h3 id="三维坐标系"><a href="#三维坐标系" class="headerlink" title="三维坐标系"></a>三维坐标系</h3><p>三维坐标系其实就是指立体空间,立体空间是由3个轴共同组成的。</p><ul><li>x轴:水平向右  注意: x右边是正值，左边是负值</li><li>y轴:垂直向下  注意: y下面是正值，上面是负值</li><li>z轴:垂直屏幕  注意：往外面是正值，往里面是负值</li></ul><h4 id="3D位移translate3d-x-y-z"><a href="#3D位移translate3d-x-y-z" class="headerlink" title="3D位移translate3d(x,y,z)"></a>3D位移translate3d(x,y,z)</h4><p>3D移动在2D移动的基础上多加了一一个可以移动的方向，就是z轴方向。</p><ul><li>translform:translateX(100px) ：仅仅是在x轴上移动</li><li>translform:translateY(100px) ：仅仅是在Y轴上移动</li><li>translform:translateZ(100px) ：仅仅是在Z轴上移动(注意: translateZ-般用px单位 )</li><li>transform:translate3d(x,y,z) ：其中x、y、z分别指要移动的轴的方向的距离，xyz不能省略，没有就写0</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate3d</span>(<span class="hljs-number">100px</span>, <span class="hljs-number">100px</span>, <span class="hljs-number">100px</span>);<br></code></pre></td></tr></table></figure><h4 id="透视：perspective"><a href="#透视：perspective" class="headerlink" title="透视：perspective"></a>透视：perspective</h4><p>在2D平面产生近大远小视觉立体，但是只是效果二维的。如果想要在网页产生3D效果需要透视(理解成3D物体投影在2D平面内)。</p><p>透视写在被观察元系的父盒子上面的</p><ul><li>d：就是视距,视距就是一个距离人的眼睛到屏幕的距离。</li><li>z：就是z轴,物体距离屏幕的距离, z轴越大(正值)我们看到的物体就越大。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>&#123;<br>    <span class="hljs-attribute">perspective</span>:<span class="hljs-number">500px</span>;  // 透视d越小，眼睛距离屏幕越近，看到的物体越大<br>&#125;<br></code></pre></td></tr></table></figure><p>在父盒子上设置了透视， 此时再在子上设置translform:translateZ就可以控制盒子的大小，值越大越靠近眼睛越大。</p><h4 id="3D旋转rotate3d-x-y-z"><a href="#3D旋转rotate3d-x-y-z" class="headerlink" title="3D旋转rotate3d(x,y,z)"></a>3D旋转rotate3d(x,y,z)</h4><p>3D旋转指可以让元素在三维平面内沿着x轴, y轴, z轴或者自定义轴进行旋转。</p><ul><li>transform:rotateX(45deg) ：沿着x轴正方向旋转45度</li><li>transform:rotateY(45deg) ：沿着y轴正方向旋转45deg</li><li>transform:rotateZ(45deg) ：沿着Z轴正方向旋转45deg</li><li>transform:rotate3d(x,y,z,deg) ： 沿着自定义轴旋转deg为角度(了解即可)</li></ul><blockquote><p>根据左手法则判断度数为正时的旋转方向，即左手大拇指指向轴的正方形，其他手指自然弯曲的方向。</p></blockquote><h4 id="3D呈现transfrom-style"><a href="#3D呈现transfrom-style" class="headerlink" title="3D呈现transfrom-style"></a>3D呈现transfrom-style</h4><ul><li>控制子元素是否开启三维立体环境。</li><li>transform-style: flat子元素不开启3d立体空间默认的</li><li>transform-style: preserve- 3d; 子元素开启立体空间</li><li>代码写给父级，但是影响的是子盒子</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>    <span class="hljs-selector-tag">body</span>&#123;<br>        // 加透视<br>        <span class="hljs-attribute">perspective</span>:<span class="hljs-number">500px</span>;<br>    &#125;<br>    <span class="hljs-selector-class">.box</span>&#123;<br>        <span class="hljs-attribute">position</span>: relative;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>; <br>        <span class="hljs-attribute">margin</span>: <span class="hljs-number">100px</span> auto;<br>        // 看到属性改变的过程(hover的过程)<br>        <span class="hljs-attribute">transition</span>: all <span class="hljs-number">2s</span>;<br>        <span class="hljs-comment">/*让子元素保持3d立体空间环境*/</span><br>        <span class="hljs-attribute">transform-style</span>: preserve-<span class="hljs-number">3</span>d;<br>    &#125;<br><br>    <span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br>        <span class="hljs-attribute">transform</span>:<span class="hljs-built_in">rotateY</span>(<span class="hljs-number">60deg</span>);<br>    &#125;<br><br>    <span class="hljs-selector-class">.box</span> <span class="hljs-selector-tag">div</span>&#123;<br><span class="hljs-attribute">position</span>:absolute;<br>        <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br><span class="hljs-attribute">background-color</span>:pink;<br>    &#125;<br><br><span class="hljs-selector-class">.box</span> <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:last-child</span>&#123;<br><span class="hljs-attribute">background-color</span>:purple;<br>        <span class="hljs-attribute">transform</span>:<span class="hljs-built_in">rotateX</span>(<span class="hljs-number">60deg</span>); <br>    &#125;<br>&lt;/style&gt;<br><br>&lt;<span class="hljs-selector-tag">body</span>&gt;<br>&lt;<span class="hljs-selector-tag">div</span> class=&quot;box&gt;<br>&lt;<span class="hljs-selector-tag">div</span>&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;<span class="hljs-selector-tag">div</span>&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;/<span class="hljs-selector-tag">body</span>&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFC和IFC机制</title>
    <link href="/2023/04/17/BFC%E5%92%8CIFC%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/04/17/BFC%E5%92%8CIFC%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><ul><li><p><code>BFC</code>是<code>Block Formatting Context</code> (块级格式上下文) ，提供了一个环境，<code>HTML</code>在这个环境中按照一定的规则进行布局。可以理解</p><p>成元素的一个”特殊功能”。</p></li><li><p>该“特异功能”，在默认的情况下处于关闭状态；当元素满足了某些条件后，该”特殊功能”被激活。</p></li><li><p>所谓激活“特异功能”，专业点说就是：该元素创建了<code>BFC</code> (又称: 开启了<code>BFC</code>)。 </p></li><li><p>简单来说就是，<code>BFC</code>是页面上的一个隔离的独立容器，让容器里的子元素不会影响到外面的布局。</p></li></ul><h2 id="开启了BFC能解决什么问题"><a href="#开启了BFC能解决什么问题" class="headerlink" title="开启了BFC能解决什么问题"></a>开启了BFC能解决什么问题</h2><ul><li>元素开启<code>BFC</code>后，其子元素不会再产生<code>margin</code>外边距折叠（父子间）。</li><li>元素开启<code>BFC</code>后，自己不会被其他浮动元素所覆盖。</li><li>元素开启<code>BFC</code>后，就算其子元素浮动，元素自身高度也不会塌陷。</li></ul><blockquote><p>BFC可以解决父子间边距折叠问题，浮动元素覆盖标准流问题、盒子高度塌陷问题</p><p>后两个问题是浮动引起的，故BFC是清除浮动的<strong>一种</strong>方法。</p></blockquote><h2 id="如何触发BFC"><a href="#如何触发BFC" class="headerlink" title="如何触发BFC"></a>如何触发BFC</h2><ul><li>根元素（html）</li><li>浮动元素</li><li>绝对定位、固定定位的元素</li><li>行内块元素</li><li>表格单元格 ：<code>table</code>、<code>thead</code>、<code>tbody</code>、<code>tfoot</code>、<code>th</code>、<code>td</code>、<code>tr</code>、<code>caption</code></li><li><code>overflow</code>的值不为<code>visible</code>的块元素</li><li>伸缩项目</li><li>多列容器</li><li><code>column-span</code>为<code>all</code>的元素（即使该元素没有包裹在多列容器）</li><li><code>display</code>的值，设置为<code>flow-root</code>（推荐）</li></ul><blockquote><p><code>flow-root</code> 该元素生成一个块级元素盒, 其会建立一个新的块级格式化上下文，定义格式化上下文的根元素。</p></blockquote><h1 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><ul><li><code>IFC</code>全称：<code>Inline Formatting Context</code>，名为<strong>行级格式化上下文</strong>。在一个IFC内，子元素是水平方向横向排列的。</li></ul><h2 id="如何触发IFC"><a href="#如何触发IFC" class="headerlink" title="如何触发IFC"></a>如何触发IFC</h2><ul><li>块级元素中仅包含内联级别元素</li></ul><h2 id="IFC规则"><a href="#IFC规则" class="headerlink" title="IFC规则"></a>IFC规则</h2><ul><li>盒子是<code>水平</code>一个接一个的排列, 水平的margin, 内边距, 边框是可以有的</li><li>垂直方向的对齐, 可能是底部对齐, 顶部对齐, 也可能是基线对齐</li><li>行框中的内联盒子的高度小于行框的高度时, 内联盒子的垂直方向的对齐方式取决于 <code>vertical-align</code> 属性</li><li>当 <code>IFC</code> 中有块级元素插入时，会产生两个匿名块将父元素分割开来，产生两个<code>IFC</code>；</li><li>当一个行框水平不能容纳内联盒子时, 他们将会在垂直方向上产生多个行框, 他们上下一个挨着一个, 但是不会重叠</li><li>可以用父元素的<code>text-align</code>去控制里面行内元素的水平对齐方式</li><li>是当 <code>IFC</code> 中有块级元素插入时，会产生两个匿名块将父元素分割开来，产生两个<code>IFC</code>；</li></ul><h2 id="开启了IFC能解决什么问题"><a href="#开启了IFC能解决什么问题" class="headerlink" title="开启了IFC能解决什么问题"></a>开启了IFC能解决什么问题</h2><ul><li><p>可以用父元素的<code>text-align</code>去控制里面行内元素的<strong>水平</strong>对齐方式</p></li><li><p>元素本身可以通过<code>vertical-align</code>结合父元素的<code>line-height</code>控制自己的<strong>垂直</strong>对齐方式</p><blockquote><p>子元素最好设置line-height: normal;使文字垂直居中方式也随<code>vertical-align</code>改变。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript语言基础</title>
    <link href="/2023/04/13/JavaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/04/13/JavaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p><code>ECMAScript</code> 变量可以用于保存任何类型的数据。</p><p>有 3 个关键字可以声明变量：<code>var</code>、<code>const</code> 和<code> let</code>。其中，<code>var </code>在<code>ECMAScript </code>的所有版本中都可以使用，而 <code>const</code> 和 <code>let</code> 只能在 <code>ECMAScript 6</code> 及更晚的版本中使用。</p><h2 id="var和let"><a href="#var和let" class="headerlink" title="var和let"></a>var和let</h2><p>在<code>ES2015</code>之前，<code>JavaScript</code> 只有两种类型的作用域：全局作用域和函数作用域。</p><p><code>var</code>和<code>let</code>的作用差不多，但有着非常重要的区别。</p><ul><li><p><strong>作用域不同</strong></p><p><code> var</code> 声明的范围是<strong>函数作用域</strong>，<code>let</code> 声明的范围是<strong>块作用域</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 此处的代码不可以使用 carName</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> carName = <span class="hljs-string">&quot;porsche&quot;</span>; <span class="hljs-comment">//使用var操作符定义的变量会成为包含它的函数的局部变量</span><br>  <span class="hljs-comment">// 此处的代码可以使用 carName</span><br>&#125;<br><span class="hljs-comment">// 此处的代码不可以使用 carName</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123; <br>  <span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>; <br>&#125;<br><span class="hljs-comment">// 此处可以使用 x</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123; <br>  <span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-comment">// 此处不可以使用 x</span><br></code></pre></td></tr></table></figure></li><li><p><strong>冗余声明</strong></p><p><code>var</code>允许在其作用域内冗余声明（重复声明一个变量），但<code>let</code>不允许相同作用域中出现冗余声明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> age = <span class="hljs-number">16</span>; <br> <span class="hljs-keyword">var</span> age = <span class="hljs-number">36</span>; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age); <br>&#125; <br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 36</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name; <br><span class="hljs-keyword">var</span> name; <br><span class="hljs-keyword">let</span> age; <br><span class="hljs-keyword">let</span> age; <span class="hljs-comment">// SyntaxError；标识符 age 已经声明过了</span><br></code></pre></td></tr></table></figure></li><li><p><strong>声明提升</strong></p><p><code>var</code>声明的变量会自动提升到函数作用域顶部，<code>let</code>声明的变量不会在作用域中被提升。</p><p>事实上，在解析代码时，用<code>let/const</code>声明的变量会先在作用域中被创建出来，但因此时还未进行词法绑定（对声明语句进行求值运算），所以不能被访问（访问就会抛出错误）。</p><p><strong>暂时性死区</strong>：在运行流程进入作用域创建变量，到变量开始被访问之间的一段时间，就称之为TDZ（暂时性死区），是一种语法错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// name 会被提升</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// undefined </span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Matt&#x27;</span>; <br><br><span class="hljs-comment">// age 不会被提升</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age); <span class="hljs-comment">// ReferenceError：age 没有定义</span><br><span class="hljs-keyword">let</span> age = <span class="hljs-number">26</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>全局声明</strong></p><p><code>var</code>在全局声明的变量会成为<code>window</code>对象的属性，<code>let</code>声明的变量不会成为<code>window</code>对象的属性，可以直接访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Matt&#x27;</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// &#x27;Matt&#x27; </span><br><span class="hljs-keyword">let</span> age = <span class="hljs-number">26</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">age</span>); <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age); <span class="hljs-comment">// 26</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="const声明"><a href="#const声明" class="headerlink" title="const声明"></a>const声明</h2><p><code>const</code> 的行为与<code> let</code> 基本相同，唯一一个重要的区别是用它声明变量时必须<strong>同时初始化变量</strong>，且尝试修改 const 声明的变量会导致运行时错误。</p><p>但<code>const</code>定义的不是真正的常量值，它定义的是对值的常量<strong>引用</strong>。</p><p>因此，我们不能更改常量原始值，但我们可以更改常量对象的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> age = <span class="hljs-number">26</span>; <br>age = <span class="hljs-number">36</span>; <span class="hljs-comment">// TypeError: 给常量赋值</span><br><br><span class="hljs-comment">// 可以创建 const 对象</span><br><span class="hljs-keyword">const</span> car = &#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&quot;porsche&quot;</span>, <span class="hljs-attr">model</span>:<span class="hljs-string">&quot;911&quot;</span>, <span class="hljs-attr">color</span>:<span class="hljs-string">&quot;Black&quot;</span>&#125;;<br><br><span class="hljs-comment">// 可以更改属性：</span><br>car.<span class="hljs-property">color</span> = <span class="hljs-string">&quot;White&quot;</span>;<br><br><span class="hljs-comment">// 可以添加属性：</span><br>car.<span class="hljs-property">owner</span> = <span class="hljs-string">&quot;Bill&quot;</span>;<br></code></pre></td></tr></table></figure><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p><code>ECMAScript </code>有 6 种简单数据类型（也称为原始类型）：<strong>Undefined、Null、Boolean、Number、String 和 Symbol。Symbol（符号）</strong>是 <code>ECMAScript 6</code> 新</p><p>增的。还有一种复杂数据类型叫 <strong>Object（对象）</strong>。</p><h2 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h2><p><code>typeof</code>可以确定任意变量的数据类型。对一个值使用 <code>typeof</code> 操作符只会返回下列字符串之一：</p><ul><li><code>&quot;undefined&quot;</code>表示值未定义；</li><li><code>&quot;boolean&quot;</code>表示值为布尔值；</li><li><code>&quot;string&quot;</code>表示值为字符串；</li><li><code>&quot;number&quot;</code>表示值为数值；</li><li><code>&quot;symbol&quot;</code>表示值为符号;</li><li><code>&quot;object&quot;</code>表示值为对象（而不是函数）或 <code>null</code>；</li><li><code>&quot;function&quot;</code>表示值为函数。</li></ul><p><strong>注意[1]：调用typeof null返回的是”object”。这是因为特殊值<code>null</code>被认为是一个对空对象的引用。</strong></p><p>​        <strong>[2]：函数在 ECMAScript 中被认为是对象，并不代表一种数据类型。但函数也有自己特殊的属性，就有必要通过 typeof 操作符来区分函数和其他对象。</strong></p><h2 id="Undefined类型"><a href="#Undefined类型" class="headerlink" title="Undefined类型"></a>Undefined类型</h2><p><strong>仅声明未初始化</strong>的情况下相当于给变量赋予了<code>undefined</code>值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> message = <span class="hljs-literal">undefined</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message == <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>注意，仅声明未初始化（ <code>undefined值</code>）的变量跟未声明的变量是有区别的。但在使用<code>typeof</code>操作符时返回的结果均是<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> message; <span class="hljs-comment">// 这个变量被声明了，只是值为undefined</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <span class="hljs-comment">// &quot;undefined&quot; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age); <span class="hljs-comment">// 报错,age未被声明</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> message); <span class="hljs-comment">// &quot;undefined&quot; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> age); <span class="hljs-comment">// &quot;undefined&quot;</span><br></code></pre></td></tr></table></figure><p>建议在声明变量的同时进行初始化。这样，当 typeof 返回”undefined”时，你就会知道那是因为给定的变量尚未声明，而不是声明了但未初始化。</p><h2 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h2><p>逻辑上讲，<code>null</code> 值表示一个空对象指针。这也是给<code>typeof</code>传一个<code>null</code>会返回<code>&quot;object&quot;</code>的原因：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> car = <span class="hljs-literal">null</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> car); <span class="hljs-comment">// &quot;object&quot;</span><br></code></pre></td></tr></table></figure><p>在定义将来要保存对象值的变量时，<strong>建议使用null来初始化</strong>，不要使用其他值。这样，只要检查这个变量的值是不是 null 就可以知道这个变量是否在后来被重新</p><p>赋予了一个对象的引用，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (car != <span class="hljs-literal">null</span>) &#123; <br> <span class="hljs-comment">// car 是一个对象的引用</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><h3 id="null-和-undefined-有什么区别？"><a href="#null-和-undefined-有什么区别？" class="headerlink" title="null 和 undefined 有什么区别？"></a>null 和 undefined 有什么区别？</h3><p>undefined 是没有定义的，null 是定义了但是为空对象。</p></blockquote><h2 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h2><p><code>Boolean</code>（布尔值）类型是 <code>ECMAScript</code> 中使用最频繁的类型之一，有两个字面值：<code>true</code> 和 <code>false</code>。</p><p>虽然布尔值只有两个，但所有其他类型的值都有相应布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以调用特定的 <strong>Boolean()转型</strong>函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 给变量赋布尔值</span><br><span class="hljs-keyword">let</span> found = <span class="hljs-literal">true</span>; <br><span class="hljs-keyword">let</span> lost = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 调用特定的 Boolean()转型函数将其他类型的值转换为布尔值</span><br><span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;Hello world!&quot;</span>; <br><span class="hljs-keyword">let</span> messageAsBoolean = <span class="hljs-title class_">Boolean</span>(message);<br></code></pre></td></tr></table></figure><h2 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h2><p><code>Number</code> 类型使用 <code>IEEE 754</code> 格式表示整数和浮点值（在某些语言中也叫双精度值）</p><ol><li><p>浮点值</p><p>要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。</p><p>浮点值的精确度最高可达 17 位小数，但在算术计算中远不如整数精确。例如，0.1 加 0.2 得到的不是 0.3，而是 0.300 000 000 000 000 04。由于这种微小的</p><p>舍入错误，导致很难测试特定的浮点值。因此永远不要测试某个特定的浮点值。</p></li><li><p>值的范围</p><p><code>ECMAScript</code>可以表示的最小数值保存在<strong>Number.MIN_VALUE</strong>中，可以表示的最大数值保存在<strong>Number.MAX_VALUE</strong>中；</p><p>任何无法表示的负数以<code>-Infinity</code>（负无穷大）表示，任何无法表示的正数以 <code>Infinity</code>（正无穷大）表示。</p><p>要确定一个值是不是有限大（即介于 <code>JavaScript</code> 能表示的最小值和最大值之间），可以使用 <strong>isFinite()函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> result = <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_VALUE</span> + <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_VALUE</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isFinite</span>(result)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li><li><p>NaN</p><p>有一个特殊的数值叫**NaN，意思是“不是数值”（Not a Number)**，用于表示本来要返回数值的操作失败了（而不是抛出错误）。</p><p>比如，用 0 除任意数值从而中止代码执行返回 NaN、任何涉及 NaN 的操作始终返回 NaN、</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">0</span>/<span class="hljs-number">0</span>); <span class="hljs-comment">// NaN </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(-<span class="hljs-number">0</span>/+<span class="hljs-number">0</span>); <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p><code>ECMAScript</code> 提供了**isNaN()**函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否“不是数值”。把一个值传给<code>isNaN()</code>后，该函数会尝</p><p>试把它转换为数值。某些非数值的值可以直接转换成数值，如字符串”10”或布尔值。任何不能转换为数值的值都会导致这个函数返回<code>true</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-number">10</span>)); <span class="hljs-comment">// false，10 是数值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&quot;10&quot;</span>)); <span class="hljs-comment">// false，可以转换为数值 10 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&quot;blue&quot;</span>)); <span class="hljs-comment">// true，不可以转换为数值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">true</span>)); <span class="hljs-comment">// false，可以转换为数值 1</span><br></code></pre></td></tr></table></figure></li><li><p>数值转换</p><p>有 3 个函数可以将非数值转换为数值：**Number()、parseInt()和 parseFloat()**。</p><p>**Number()**是转型函数，可用于任何数据类型。</p><p>**parseInt()**函数更专注于字符串是否包含数值模式，如果第一个字符不是数值字符、加号或减号，<code>parseInt()</code>立即返回 <code>NaN</code>。</p><p>**parseFloat()**只解析十进制值。</p></li></ol><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>字符串可以使用双引号（”）、单引号（’）或反引号（&#96;）标示。</p><ol><li><p>转换为字符串</p><p>有两种方式把一个值转换为字符串。首先是使用几乎所有值都有的 <strong>toString()方法</strong>。这个方法唯一的用途就是返回当前值的字符串等价物。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> age = <span class="hljs-number">11</span>; <br><span class="hljs-keyword">let</span> ageAsString = age.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// 字符串&quot;11&quot; </span><br><span class="hljs-keyword">let</span> found = <span class="hljs-literal">true</span>; <br><span class="hljs-keyword">let</span> foundAsString = found.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// 字符串&quot;true&quot;</span><br></code></pre></td></tr></table></figure><p><strong>String()转型函数</strong>其实就是调用了值的<code>toString()</code>方法，但是<strong>null 和 undefined 值没有 toString()方法</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> value1 = <span class="hljs-number">10</span>; <br><span class="hljs-keyword">let</span> value3 = <span class="hljs-literal">null</span>; <br><span class="hljs-keyword">let</span> value4; <br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>(value1)); <span class="hljs-comment">// &quot;10&quot; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>(value3)); <span class="hljs-comment">// &quot;null&quot; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>(value4)); <span class="hljs-comment">// &quot;undefined&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>用加号操作符给一个值加上一个空字符串””也可以将其转换为字符串</p></blockquote></li><li><p>模板字面量</p><p>与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> myMultiLineString = <span class="hljs-string">&#x27;first line\nsecond line&#x27;</span>; <br><span class="hljs-keyword">let</span> myMultiLineTemplateLiteral = <span class="hljs-string">`first line </span><br><span class="hljs-string">second line`</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myMultiLineString); <br><span class="hljs-comment">// first line </span><br><span class="hljs-comment">// second line&quot; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myMultiLineTemplateLiteral); <br><span class="hljs-comment">// first line</span><br><span class="hljs-comment">// second line</span><br></code></pre></td></tr></table></figure></li><li><p>字符串插值</p><p>模板字面量最常用的一个特性是支持字符串插值，字符串插值通过在**${}<strong>中使用一个</strong>JavaScript 表达式**（可以用<code>console.log</code>打印出）实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> value = <span class="hljs-number">5</span>; <br><span class="hljs-keyword">let</span> exponent = <span class="hljs-string">&#x27;second&#x27;</span>;<br><span class="hljs-keyword">let</span> interpolatedTemplateLiteral = <br> <span class="hljs-string">`<span class="hljs-subst">$&#123; value &#125;</span> to the <span class="hljs-subst">$&#123; exponent &#125;</span> power is <span class="hljs-subst">$&#123; value * value &#125;</span>`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(interpolatedTemplateLiteral); <span class="hljs-comment">// 5 to the second power is 25</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="Symbol类型"><a href="#Symbol类型" class="headerlink" title="Symbol类型"></a>Symbol类型</h2><p><code>Symbol（符号）</code>是 <code>ECMAScript 6</code> 新增的数据类型。</p><p><code>ES5</code> 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字</p><p>就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的，就从根本上防止属性名的冲突。这就是 <code>ES6</code> 引入<code>Symbol</code>的原因。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> genericSymbol = <span class="hljs-title class_">Symbol</span>(); <br><span class="hljs-keyword">let</span> otherGenericSymbol = <span class="hljs-title class_">Symbol</span>(); <br><br><span class="hljs-keyword">let</span> fooSymbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); <br><span class="hljs-keyword">let</span> otherFooSymbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); <br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(genericSymbol == otherGenericSymbol); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fooSymbol == otherFooSymbol); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><p><code>Object</code> 的实例本身并不是很有用，但理解与它相关的概念非常重要。<code>ECMAScript</code> 中的 <code>Object</code> 也是派生其他对象的基类。<code>Object</code> 类型的所有属性和方法在派生的对象上同样存在。</p><p>每个 <code>Object</code> 实例都有如下属性和方法。</p><ul><li><p>constructor：用于创建当前对象的函数。在前面的例子中，这个属性的值就是Object() 函数。</p></li><li><p>hasOwnProperty(<em>propertyName</em>)：用于判断当前对象实例（不是原型）上是否存在给定的属性。</p></li><li><p>isPrototypeOf(<em>object</em>)：用于判断当前对象是否为另一个对象的原型。</p></li><li><p>propertyIsEnumerable(<em>propertyName</em>)：用于判断给定的属性是否可以使用（本章稍后讨论的）for-in 语句枚举。与 hasOwnProperty()一样，属性名必须是字符串。</p></li><li><p>toLocaleString()：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。</p></li><li><p>toString()：返回对象的字符串表示。</p></li><li><p>valueOf()：返回对象对应的字符串、数值或布尔值表示。通常与 toString()的返回值相同。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原始值和引用值概括</title>
    <link href="/2023/04/13/%E5%8E%9F%E5%A7%8B%E5%80%BC%E5%92%8C%E5%BC%95%E7%94%A8%E5%80%BC%E6%A6%82%E6%8B%AC/"/>
    <url>/2023/04/13/%E5%8E%9F%E5%A7%8B%E5%80%BC%E5%92%8C%E5%BC%95%E7%94%A8%E5%80%BC%E6%A6%82%E6%8B%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="变量值"><a href="#变量值" class="headerlink" title="变量值"></a>变量值</h1><p>ECMAScript变量可以包含两种不同类型的数据：<strong>原始值和引用值</strong>。</p><p>原始值（primitive value）就是最简单的数据，引用值（reference value）则是由多个值构成的对象。</p><p>在把一个值赋给变量时，JavaScript 引擎必须确定这个值是原始值还是引用值。</p><p><strong>保存原始值的变量是按值（by value）访问的</strong>，因为我们操作的就是存储在变量中的<strong>实际值</strong>；</p><p>引用值是保存在内存中的对象，<strong>保存引用值的变量是按引用（by reference）访问的</strong>。在操作对象时，实际上操作的是对该对象的<strong>引用</strong>（reference）而非实际的对象本身。</p><blockquote><p>6种简单数据类型的值都是原始值。</p></blockquote><h2 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h2><p>原始值不能有属性，而对于引用值而言，可以随时添加、修改和删除其属性和方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <br>person.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Nicholas&quot;</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;Nicholas&quot;</span><br><br><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;Nicholas&quot;</span>; <br>name.<span class="hljs-property">age</span> = <span class="hljs-number">27</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name.<span class="hljs-property">age</span>);    <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>但如果使用new关键字，显示的创建Number、String、Boolean原始值包装类型对象， 也可以使该变量拥引用值的行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> name1 = <span class="hljs-string">&quot;Nicholas&quot;</span>; <br><span class="hljs-keyword">let</span> name2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Matt&quot;</span>); <br><br>name1.<span class="hljs-property">age</span> = <span class="hljs-number">27</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name1.<span class="hljs-property">age</span>); <span class="hljs-comment">// undefined </span><br><br>name2.<span class="hljs-property">age</span> = <span class="hljs-number">26</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name2.<span class="hljs-property">age</span>); <span class="hljs-comment">// 26 </span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> name1); <span class="hljs-comment">// string </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> name2); <span class="hljs-comment">// object</span><br></code></pre></td></tr></table></figure><h2 id="复制值"><a href="#复制值" class="headerlink" title="复制值"></a>复制值</h2><p>除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。</p><ul><li>原始值复制</li></ul><p>在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。这两个变量可以独立使用，互不干扰。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> num1 = <span class="hljs-number">5</span>; <br><span class="hljs-keyword">let</span> num2 = num1;<br></code></pre></td></tr></table></figure><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230427221404929.png" alt="image-20230427221404929" style="zoom:80%;"><ul><li>引用值复制</li></ul><p>在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。</p><p>区别在于，这里复制的值实际上是一个指针，指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象。</p><p>因此一个对象上面的变化会在另一个对象上反映出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <br><span class="hljs-keyword">let</span> obj2 = obj1; <br>obj1.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Nicholas&quot;</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;Nicholas&quot;</span><br></code></pre></td></tr></table></figure><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230427221423536.png" alt="image-20230427221423536" style="zoom:80%;"><h2 id="instanceof操作符"><a href="#instanceof操作符" class="headerlink" title="instanceof操作符"></a>instanceof操作符</h2><p>我们通常不关心一个引用值是不是对象，而是想知道它是什么类型的对象。<code>instanceof</code>操作符用来确定引用值类型。</p><p>如果变量是给定引用类型（由其原型链决定）的实例，则<code>instanceof</code>操作符返回<code>true</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);  <span class="hljs-comment">// 变量 person 是 Object 吗？</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(colors <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>);   <span class="hljs-comment">// 变量 colors 是 Array 吗？</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>); <span class="hljs-comment">// 变量 pattern 是 RegExp 吗？</span><br></code></pre></td></tr></table></figure><h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><h2 id="基本引用类型"><a href="#基本引用类型" class="headerlink" title="基本引用类型"></a>基本引用类型</h2><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>要创建日期对象，就使用<code>new</code>操作符来调用<code>Date</code>构造函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br></code></pre></td></tr></table></figure><p>要基于其他日期和时间创建日期对象，必须传入其毫秒表示（UNIX 纪元 1970 年 1 月 1 日午夜之后的毫秒数）。</p><p><code>Date.parse()</code>方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建一个表示“2019 年 5 月 23 日”的日期对象</span><br><span class="hljs-keyword">let</span> someDate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&quot;May 23, 2019&quot;</span>));<br><span class="hljs-comment">// 如果直接把表示日期的字符串传给 Date 构造函数，那么 Date 会在后台调用 Date.parse()</span><br><span class="hljs-keyword">let</span> someDate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;May 23, 2019&quot;</span>);<br></code></pre></td></tr></table></figure><p><code>Date.UTC()</code>方法也返回日期的毫秒表示，传给 Date.UTC()的参数是年、零起点月数（1 月是 0，2 月是 1，以此类推）、日（1-31）、时（0-23）、分、秒和毫</p><p>秒。有前两个（年和月）是必需的。如果不提供日，那么默认为 1 日。其他参数的默认值都是 0。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// GMT 时间 2000 年 1 月 1 日零点</span><br><span class="hljs-keyword">let</span> y2k = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">UTC</span>(<span class="hljs-number">2000</span>, <span class="hljs-number">0</span>)); <br><span class="hljs-comment">// GMT 时间 2005 年 5 月 5 日下午 5 点 55 分 55 秒</span><br><span class="hljs-keyword">let</span> allFives = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">UTC</span>(<span class="hljs-number">2005</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">17</span>, <span class="hljs-number">55</span>, <span class="hljs-number">55</span>));<br></code></pre></td></tr></table></figure><p>同样的，如果直接把表示日期的字符串传给 <code>Date</code> 构造函数，那么 <code>Date</code> 会在后台调用 <code>Date.parse()</code>。</p><p><code>Date</code> 类型有几个专门用于格式化日期的方法，它们都会返回字符串</p><ul><li>toDateString()显示日期中的周几、月、日、年（格式特定于实现）；</li><li>toTimeString()显示日期中的时、分、秒和时区（格式特定于实现）；</li><li>toLocaleDateString()显示日期中的周几、月、日、年（格式特定于实现和地区）；</li><li>toLocaleTimeString()显示日期中的时、分、秒（格式特定于实现和地区）；</li><li>toUTCString()显示完整的UTC 日期（格式特定于实现）。</li></ul><h3 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h3><p>ECMAScript 通过RegExp 类型支持正则表达式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> expression = <span class="hljs-regexp">/pattern/</span>flags;<br></code></pre></td></tr></table></figure><p>这个正则表达式的<code>pattern</code>（模式）可以是任何简单或复杂的正则表达式，包括字符类、限定符、分组、向前查找和反向引用。</p><p>每个正则表达式可以带零个或多个<code>flags</code>（标记），用于控制正则表达式的行为。</p><p>下面给出了表示匹配模式的标记：</p><ul><li>g：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。</li><li>i：不区分大小写，表示在查找匹配时忽略pattern 和字符串的大小写。</li><li>m：多行模式，表示查找到一行文本末尾时会继续查找。</li><li>y：粘附模式，表示只查找从lastIndex 开始及之后的字符串。</li><li>u：Unicode 模式，启用Unicode 匹配。</li><li>s：dotAll 模式，表示元字符.匹配任何字符（包括\n 或\r）。</li></ul><p>使用不同模式和标记可以创建出各种正则表达式，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 匹配字符串中的所有&quot;at&quot;</span><br><span class="hljs-keyword">let</span> pattern1 = <span class="hljs-regexp">/at/g</span>;<br><span class="hljs-comment">// 匹配第一个&quot;bat&quot;或&quot;cat&quot;，忽略大小写</span><br><span class="hljs-keyword">let</span> pattern2 = <span class="hljs-regexp">/[bc]at/i</span>;<br><span class="hljs-comment">// 匹配所有以&quot;at&quot;结尾的三字符组合，忽略大小写</span><br><span class="hljs-keyword">let</span> pattern3 = <span class="hljs-regexp">/.at/gi</span>;<br></code></pre></td></tr></table></figure><p>详细见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式</a></p><p>除了<strong>字面量形式</strong>外，正则表达式也可以使用<strong>RegExp 构造函数</strong>来创建，它接收两个参数：模式字符串和（可选的）标记字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 匹配第一个&quot;bat&quot;或&quot;cat&quot;，忽略大小写</span><br><span class="hljs-keyword">let</span> pattern1 = <span class="hljs-regexp">/[bc]at/i</span>;<br><span class="hljs-comment">// 跟pattern1 一样，只不过是用构造函数创建的</span><br><span class="hljs-keyword">let</span> pattern2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot;[bc]at&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>);<br></code></pre></td></tr></table></figure><p>**RegExp 实例主要方法是<code>exec()</code>**，用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，则返回包含第一个匹配信息的</p><p>数组；如果没找到匹配项，则返回<code>null</code>。</p><p>返回的数组包含两个额外的属性：index 和input。index 是字符串中匹配的起始位置，input 是要进行匹配的字符串（即exec接收的字符串）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> text = <span class="hljs-string">&#x27;a cat go and a cat come&#x27;</span>;<br>l4 = <span class="hljs-regexp">/a\s((cat)\sgo)/g</span>;<br>l4.<span class="hljs-title function_">exec</span>(text)<br><span class="hljs-comment">// (3) [&quot;a cat go&quot;, &quot;cat go&quot;, &quot;cat&quot;, index: 0, input: &quot;a cat go and a cat come&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure><h3 id="原始值包装类型"><a href="#原始值包装类型" class="headerlink" title="原始值包装类型"></a>原始值包装类型</h3><p>为了方便操作原始值，<strong>ECMAScript 提供了 3 种特殊的引用类型：Boolean、Number 和 String</strong>。</p><p>除了可以用new显式地创建原始值包装类型的实例，还可以直接使用原始值的方法或属性，隐式地自动创建原始值包装对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s1 = <span class="hljs-string">&quot;some text&quot;</span>; <br><span class="hljs-keyword">let</span> s2 = s1.<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过 new 实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对</p><p>象则只存在于访问它的那行代码执行期间。这意味着不能在运行时给原始值添加属性和方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s1 = <span class="hljs-string">&quot;some text&quot;</span>; <br>s1.<span class="hljs-property">color</span> = <span class="hljs-string">&quot;red&quot;</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1.<span class="hljs-property">color</span>); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>这里的第二行代码尝试给字符串 <code>s1</code> 添加了一个 <code>color</code> 属性。可是，第三行代码访问<code>color</code>属性时，它却不见了。原因就是第二行代码运行时会临时创建一个</p><p><code>String</code>对象，而当第三行代码执行时，这个对象已经被销毁了。实际上，第三行代码在这里创建了自己的<code>String</code>对象，但这个对象没有<code>color</code>属性。</p><p>注意，使用<code>new</code>调用原始值包装类型的构造函数，与调用同名的转型函数并不一样。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> value = <span class="hljs-string">&quot;25&quot;</span>; <br><span class="hljs-keyword">let</span> number = <span class="hljs-title class_">Number</span>(value);  <span class="hljs-comment">// 转型函数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> number);  <span class="hljs-comment">// &quot;number&quot; </span><br><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(value); <span class="hljs-comment">// 构造函数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> obj);     <span class="hljs-comment">// &quot;object&quot;</span><br></code></pre></td></tr></table></figure><h3 id="单例内置对象Global和Math"><a href="#单例内置对象Global和Math" class="headerlink" title="单例内置对象Global和Math"></a>单例内置对象Global和Math</h3><p>当代码开始执行时，全局上下文中会存在两个内置对象：<strong>Global 和 Math</strong>。其中，<code>Global</code> 对象在大多数 <code>ECMAScript</code> 实现中无法直接访问。不过，浏览器将其</p><p>实现为<code>window</code> 对象。所有全局变量和函数都是 <code>Global</code> 对象的属性。<code>Math</code> 对象包含辅助完成复杂计算的属性和方法。</p><h2 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>创建方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj=&#123;&#125;;<span class="hljs-comment">//对象字面量</span><br>或<br><span class="hljs-keyword">let</span> obj <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">// 使用 new 操作符和 Object 构造函数</span><br></code></pre></td></tr></table></figure><p>访问对象属性的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj=&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;lly&quot;</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&quot;Man&quot;</span>&#125;<br>obj.<span class="hljs-property">name</span>    <span class="hljs-comment">//点语法</span><br>或<br>obj[<span class="hljs-string">&quot;name&quot;</span>] <span class="hljs-comment">//中括号</span><br></code></pre></td></tr></table></figure><blockquote><p>在使用对象字面量表示法定义对象时，不会实际调用Object构造函数。</p></blockquote><p>关于Object更全面，更深层次的学习，作者会单独开篇。</p><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>跟其他语言中的数组一样，ECMAScript 数组也是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以存储任意类型的数据。</p><p>ECMAScript 数组也是动态大小的，会随着数据添加而自动增长。</p><p>关于Array更全面，更深层次的学习，作者会单独开篇。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h4><table><thead><tr><th>API</th><th>描述</th></tr></thead><tbody><tr><td>new Map()</td><td>创建新的 Map 对象。</td></tr><tr><td>set()</td><td>为 Map 对象中的键设置值。</td></tr><tr><td>get()</td><td>获取 Map 对象中键的值。</td></tr><tr><td>entries()</td><td>取得映射实例默认的迭代器，返回 Map 对象中键&#x2F;值对的数组。</td></tr><tr><td>keys()</td><td>返回 Map 对象中键的数组。</td></tr><tr><td>values()</td><td>返回 Map 对象中值的数组。</td></tr><tr><td>has()</td><td>如果键存在，则返回 true。</td></tr><tr><td>delete()</td><td>删除由键指定的元素。</td></tr><tr><td>clear()</td><td>删除 Map 中的所有元素。</td></tr><tr><td>forEach()</td><td>为每个键&#x2F;值对调用回调。</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// new Map()创建一个空映射</span><br><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br><span class="hljs-comment">// set()为 Map 对象中的键设置值。</span><br>m.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;val1&quot;</span>) <br> .<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;val2&quot;</span>);<br><br><span class="hljs-comment">// 或者使用嵌套数组初始化</span><br><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br> [<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;val1&quot;</span>], <br> [<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;val2&quot;</span>]<br>]);<br><br><span class="hljs-comment">// get()获取 Map 对象中键的值。</span><br><span class="hljs-title function_">alert</span>(m.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;key1&quot;</span>)); <span class="hljs-comment">// val1</span><br><br><span class="hljs-comment">// entries()取得映射实例的默认迭代器，以插入的顺序生成[key, value]形式的数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> pair <span class="hljs-keyword">of</span> m.<span class="hljs-title function_">entries</span>()) &#123; <br> <span class="hljs-title function_">alert</span>(pair);   <br> <span class="hljs-comment">// [key1,val1]   </span><br> <span class="hljs-comment">// [key2,val2]</span><br>&#125;<br><br><span class="hljs-comment">// keys()和 values()分别返回以插入顺序生成键和值的迭代器</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> m.<span class="hljs-title function_">keys</span>()) &#123; <br> <span class="hljs-title function_">alert</span>(key); <br> <span class="hljs-comment">// key1</span><br> <span class="hljs-comment">// key2</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> m.<span class="hljs-title function_">values</span>()) &#123; <br> <span class="hljs-title function_">alert</span>(key); <br> <span class="hljs-comment">// val1</span><br> <span class="hljs-comment">// val2</span><br>&#125;<br><span class="hljs-comment">// forEach(callback, opt_thisArg) 依次迭代每个键/值对</span><br>m.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">val, key</span>) =&gt;</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span> -&gt; <span class="hljs-subst">$&#123;val&#125;</span>`</span>)); <br><span class="hljs-comment">// key1 -&gt; val1</span><br><span class="hljs-comment">// key2 -&gt; val2</span><br></code></pre></td></tr></table></figure><p>属性</p><table><thead><tr><th>Property</th><th>Description</th></tr></thead><tbody><tr><td>size</td><td>获取并返回 Map 对象中键值对的数量</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">alert</span>(m.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h4 id="Object-vs-Map"><a href="#Object-vs-Map" class="headerlink" title="Object vs Map"></a>Object vs Map</h4><table><thead><tr><th></th><th>Object</th><th>Map</th></tr></thead><tbody><tr><td>键类型</td><td>必须是字符串（或符号）</td><td><strong>可以是任何数据类型</strong></td></tr><tr><td>键顺序</td><td>对象键没有很好地排序</td><td>Map 键按插入排序（故可进行迭代操作）</td></tr><tr><td>默认</td><td>有</td><td>无</td></tr></tbody></table><h4 id="WeakMap-vs-Map"><a href="#WeakMap-vs-Map" class="headerlink" title="WeakMap vs Map"></a>WeakMap vs Map</h4><p><code>WeakMap</code>是 ES6 中新增的一种集合类型，叫做“弱映射”。它与<code>Map</code>的区别就在于这个<strong>弱字</strong>，API 还是<code>Map</code>的那套（只有<code>set</code> <code>get</code> <code>has</code> <code>delete</code>) 。</p><p>一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，即垃圾回收机制不将该引用考虑在内。只要所引用的对象的其他引用都被清除，垃圾回收</p><p>机制就会释放该对象所占用的内存。也就是说，一旦不再需要，<code>WeakMap</code> 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p><table><thead><tr><th></th><th>WeakMap</th><th>Map</th></tr></thead><tbody><tr><td>键类型</td><td>必须是对象（但不能是null）</td><td><strong>可以是任何数据类型</strong></td></tr><tr><td>迭代</td><td>不能被遍历</td><td>可以被遍历</td></tr><tr><td>是否需要手动删除引用释放内存</td><td>不需要，垃圾回收机制自动释放</td><td>必须手动释放</td></tr></tbody></table><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set 是唯一值的集合（无重复值），一个 Set 可以容纳任何数据类型的任何值。</p><p>Set 在很多方面都像是加强的 Map，这是因为它们的大多数 API 和行为都是共有的。区别可能在于Map是基于“键&#x2F;值”机制存储的。</p><h4 id="基本API-1"><a href="#基本API-1" class="headerlink" title="基本API"></a>基本API</h4><table><thead><tr><th>API</th><th>描述</th></tr></thead><tbody><tr><td>new Set()</td><td>创建新的 Set 对象。</td></tr><tr><td>add()</td><td>向 Set 添加新元素。</td></tr><tr><td>clear()</td><td>从 Set 中删除所有元素。</td></tr><tr><td>delete()</td><td>删除由其值指定的元素。</td></tr><tr><td>entries()</td><td>返回一个迭代器，按照插入顺序生成包含两个元素（值的重复出现）的数组。</td></tr><tr><td>has()</td><td>如果值存在则返回 true。</td></tr><tr><td>forEach()</td><td>为每个元素调用回调。</td></tr><tr><td>keys()</td><td>取得集合实例默认的迭代器，返回 Set 对象中值的数组。</td></tr><tr><td>values()</td><td>与 keys() 相同，keys()的别名。</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&quot;val1&quot;</span>, <span class="hljs-string">&quot;val2&quot;</span>]); <br><br><span class="hljs-comment">// keys()取得集合实例默认的迭代器，返回 Set 对象中值的数组。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> s.<span class="hljs-title function_">values</span>()) &#123; <br> <span class="hljs-title function_">alert</span>(value); <br>    <span class="hljs-comment">// val1 </span><br>    <span class="hljs-comment">// val2 </span><br>&#125; <br><span class="hljs-comment">// entries()返回一个迭代器，按照插入顺序生成包含两个元素（值的重复出现）的数组。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> pair <span class="hljs-keyword">of</span> s.<span class="hljs-title function_">entries</span>()) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pair); <br><span class="hljs-comment">// [&quot;val1&quot;, &quot;val1&quot;] </span><br><span class="hljs-comment">// [&quot;val2&quot;, &quot;val2&quot;] </span><br>&#125; <br></code></pre></td></tr></table></figure><p>属性</p><table><thead><tr><th>Property</th><th>Description</th></tr></thead><tbody><tr><td>size</td><td>获取并返回 Set对象中值的数量。</td></tr></tbody></table><h4 id="WeakSet-vs-Set"><a href="#WeakSet-vs-Set" class="headerlink" title="WeakSet vs Set"></a>WeakSet vs Set</h4><p>参考<code>WeakMap</code>弱映射的理解，<code>WeakSet</code>弱集合的”弱“也是针对于<code>JavaScript</code> 垃圾回收程序对待“弱集合”中值的方式。</p><table><thead><tr><th></th><th>WeakSet</th><th>Set</th></tr></thead><tbody><tr><td>值类型</td><td>必须是对象（但不能是null）</td><td><strong>可以是任何数据类型</strong></td></tr><tr><td>迭代</td><td>不能被遍历</td><td>可以被遍历</td></tr><tr><td>是否需要手动删除引用释放内存</td><td>不需要，垃圾回收机制自动释放</td><td>必须手动释放</td></tr></tbody></table><blockquote><p>在前面介绍的集合引用类型中，Array、Map、Set 这4 种原生集合类型均定义了默认迭代器。其实还包括所有的定型数组。</p></blockquote><h2 id="特殊引用类型"><a href="#特殊引用类型" class="headerlink" title="特殊引用类型"></a>特殊引用类型</h2><p><code>JavaScript</code>比较独特的一点是，函数实际上是<code>Function</code>类型的实例，也就是说函数也是对象。因为函数也是对象，所以函数也有方法，可以用于增强其能力。</p><p>关于<code>Function</code>更全面，更深层次的学习，作者会单独开篇。</p>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML5特性</title>
    <link href="/2023/04/12/HTML5%E7%89%B9%E6%80%A7/"/>
    <url>/2023/04/12/HTML5%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h2><p>为了实现语义化标记，HTML 提供了明确这些区段的专用标签，例如：</p><ul><li><code>&lt;header&gt;</code>：页眉</li><li><code>&lt;nav&gt;</code>：导航栏</li><li><code>&lt;main&gt;</code>：主内容。主内容中还可以有各种子内容区段，可用<code>&lt;article&gt;</code>、<code>&lt;section&gt; </code>和<code>&lt;div&gt; </code>等元素表示。</li><li><code>&lt;aside&gt;</code>：侧边栏，经常嵌套在<code>&lt;main&gt;</code>中。</li><li><code>&lt;footer&gt;</code>：页脚。</li></ul><p>优势</p><ul><li>使界面的代码结构清晰，方便代码的阅读和团队的合作开发</li><li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义的方式来渲染网页。</li><li>有利于搜索引擎优化（<code>SEO</code>）。</li></ul><h2 id="多媒体标签"><a href="#多媒体标签" class="headerlink" title="多媒体标签"></a>多媒体标签</h2><ul><li><p>音频：<code>&lt;audio&gt;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">src</span>= <span class="hljs-string">&quot;media/music.mp3&quot;</span> <span class="hljs-attr">autoplay</span>= <span class="hljs-string">&quot;autoplay&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>谷歌把自动播放音频和视频的功能关闭了，视频可以通过muted属性来静音播放视频，音频不可以（可以通过JavaScript解决）</p></blockquote></li><li><p>视频：<code>&lt;video&gt;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>= <span class="hljs-string">&quot;media/mi.mp4&quot;</span> <span class="hljs-attr">autoplay</span>= <span class="hljs-string">&quot;autoplay&quot;</span> <span class="hljs-attr">muted</span>= <span class="hljs-string">”muted</span>&quot;&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="新增的input类型"><a href="#新增的input类型" class="headerlink" title="新增的input类型"></a>新增的input类型</h2><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>type&#x3D;”email”</td><td>限制用户输入必须为Email类型</td></tr><tr><td>type&#x3D;”url”</td><td>限制用户输入必须为URL类型</td></tr><tr><td>type&#x3D;”date”</td><td>限制用户输入必须为日期类型</td></tr><tr><td>type&#x3D;”time”</td><td>限制用户输入必须为时间类型</td></tr><tr><td>type&#x3D;”month”</td><td>限制用户输入必须为月类型</td></tr><tr><td>type&#x3D;”week”</td><td>限制用户输入必须为周类型</td></tr><tr><td>type&#x3D;”number”</td><td>限制用户输入必须为数字类型</td></tr><tr><td>type&#x3D;”tel”</td><td>手机号码</td></tr><tr><td>type&#x3D;”search”</td><td>搜索框</td></tr><tr><td>type&#x3D;”color”</td><td>生成一个颜色选择表单</td></tr></tbody></table><h2 id="新增的表单属性"><a href="#新增的表单属性" class="headerlink" title="新增的表单属性"></a>新增的表单属性</h2><table><thead><tr><th>属性</th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>placehoder</td><td>输入框默认提示文字</td></tr><tr><td>required</td><td>要求输入的内容是否可为空</td></tr><tr><td>pattern</td><td>描述一个正则表达式验证输入的值</td></tr><tr><td>min&#x2F;max</td><td>设置元素最小&#x2F;最大值</td></tr><tr><td>step</td><td>为输入域规定合法的数字间隔</td></tr><tr><td>height&#x2F;wdith</td><td>用于image类型<code>&lt;input&gt;</code>标签图像高度&#x2F;宽度</td></tr><tr><td>autofocus</td><td>规定在页面加载时，域自动获得焦点</td></tr><tr><td>multiple</td><td>规定<code>&lt;input&gt;</code>元素中可选择多个值</td></tr></tbody></table><h2 id="Canvas绘图"><a href="#Canvas绘图" class="headerlink" title="Canvas绘图"></a>Canvas绘图</h2><p><code>canvas</code>就是画布，可以画线，图形，填充，图像绘制等操作。</p><p><code>Canvas</code>元素的定义</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">// 基本语法：在使用canvas时需要设定一个高度跟宽度将画布定下<br>// 文中的信息为浏览器不支持canvas标签时显示的文字<br><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;drawing&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot; 200&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;200&quot;</span>&gt;</span>A drawing of something.<span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>id</code> 是<code>canvas</code>元素的标识；</li><li><code>height</code>是<code>canvas</code>画布的高度，单位为像素；</li><li><code>width</code>是<code>canvas</code>画布的宽度，单位为像素。</li></ul><p>使用<code>JavaScript</code>获取网页中的<code>Canvas</code>对象</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 获取对象</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> drawing  = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;drawing&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 获取drawing对象的2D绘图上下文</span></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> ctx = drawing.<span class="hljs-title function_">getContext</span>(‘2d’);</span><br><span class="language-javascript">    <span class="hljs-comment">// 开始绘制图像，可以是直线、矩形、圆弧</span></span><br><span class="language-javascript">    ...</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（1）绘制直线</p><ul><li>调用<code>beginPath()</code>方法，指示开始绘图路径： <code>ctx.beginPath()</code>;</li><li>调用<code>moveTo()</code>方法将坐标移至直线起点： <code>ctx.moveTo(x,y)</code>;</li><li>调用<code>lineTo()</code>方法绘制直线： <code>ctx.lineTo(x,y)</code>，会改变当前点；</li><li>调用<code>stroke()</code>方法，绘制图形的边界轮廓： <code>ctx.stroke()</code>;</li><li>调用<code>closePath()</code>方法，闭合路径。拉一条从当前点到<code>path</code>起始点的直线。如果当前点与起始点重合，则什么都不做：<code>ctx.closePath()</code>;</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> mycanvas=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;canvas&quot;</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> ctx=mycanvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&quot;2d&quot;</span>);</span><br><span class="language-javascript">ctx.<span class="hljs-title function_">beginPath</span>();</span><br><span class="language-javascript">ctx.<span class="hljs-title function_">moveTo</span>(<span class="hljs-number">100</span>,<span class="hljs-number">200</span>);</span><br><span class="language-javascript">ctx.<span class="hljs-title function_">lineTo</span>(<span class="hljs-number">400</span>,<span class="hljs-number">200</span>);</span><br><span class="language-javascript">ctx.<span class="hljs-title function_">lineTo</span>(<span class="hljs-number">250</span>,<span class="hljs-number">400</span>);</span><br><span class="language-javascript">ctx.<span class="hljs-title function_">closePath</span>();</span><br><span class="language-javascript">ctx.<span class="hljs-property">strokeStyle</span>=<span class="hljs-string">&quot;#000000&quot;</span>;</span><br><span class="language-javascript">ctx.<span class="hljs-title function_">stroke</span>();</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）绘制矩形</p><ul><li><p>绘制矩形：<code>rect(x,y,width,height)</code>； </p></li><li><p>绘制矩形边框：<code>strokeRect(x, y, width, height)</code>;</p></li><li><p>绘制填充矩形：<code>fillRect(x, y, width, height)</code>;</p></li><li><p>擦除指定矩形区域：<code>clearRect(x, y, width, height)</code>;</p></li></ul><blockquote><p>x：矩形左上角的X坐标</p><p>y：矩形左上角的y坐标</p><p>width：矩形的宽度</p><p>height：矩形的高度</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> mycanvas=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;canvas&quot;</span>);</span><br><span class="language-javascript"><span class="hljs-keyword">var</span> ctx=mycanvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&quot;2d&quot;</span>);</span><br><span class="language-javascript"> </span><br><span class="language-javascript"><span class="hljs-comment">//rect()函数调用</span></span><br><span class="language-javascript">ctx.<span class="hljs-title function_">beginPath</span>();</span><br><span class="language-javascript">ctx.<span class="hljs-title function_">rect</span>(<span class="hljs-number">20</span>,<span class="hljs-number">20</span>,<span class="hljs-number">100</span>,<span class="hljs-number">50</span>);</span><br><span class="language-javascript">ctx.<span class="hljs-title function_">stroke</span>();</span><br><span class="language-javascript"> </span><br><span class="language-javascript"><span class="hljs-comment">//strokeRect()函数调用</span></span><br><span class="language-javascript">ctx.<span class="hljs-title function_">strokeRect</span>(<span class="hljs-number">200</span>,<span class="hljs-number">20</span>,<span class="hljs-number">150</span>,<span class="hljs-number">60</span>);</span><br><span class="language-javascript"> </span><br><span class="language-javascript"><span class="hljs-comment">//fillRect()函数调用</span></span><br><span class="language-javascript">ctx.<span class="hljs-title function_">fillRect</span>(<span class="hljs-number">400</span>,<span class="hljs-number">20</span>,<span class="hljs-number">150</span>,<span class="hljs-number">60</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注：<code>strokeRect()</code>方法与<code>rect()</code>方法的区别在于调用<code>strokeRect()</code>方法时不需要使用<code>beginPath()</code>和<code>stroke()</code>即可绘图。</p><p>（3）绘制圆弧</p><ul><li><code>arc(centerx,centery,radius,startAngle,endAngle,antiClockwise)</code>;<ul><li><code>centerx,centery</code>   圆弧中心点坐标</li><li><code>Radius</code> 半径</li><li><code>startAngle</code>  起始弧度</li><li><code>endAngle</code>  终止弧度</li><li><code>antiClockwise</code>  是否按逆时针方向绘图，   是一个可选参数，默认为<code>false</code>（即顺时针方向绘图）</li><li>弧度 &#x3D; 角度* ( <code>Math.PI / 180</code> )</li></ul></li></ul><p>（4）填充和描边</p><ul><li><p>描边</p><ul><li><code>strokeStyle</code>指定描边颜色（三种颜色方式均可）</li><li><code>lineWidth</code>指定描边宽度（像素为单位）</li></ul></li><li><p>填充</p><ul><li><code>fillStyle</code>指定填充颜色（三种颜色方式均可）</li></ul></li></ul><h2 id="应用缓存（Application-Cache）"><a href="#应用缓存（Application-Cache）" class="headerlink" title="应用缓存（Application Cache）"></a>应用缓存（Application Cache）</h2><p>在<code>HYML5</code>之前，我们需要接入网络才能访问，这毫无疑问是网站多次请求服务器，造成速度变慢。</p><p>实际开发中，主要是使用<code>Application Cache</code>和<code>LocalStorage</code>技术实现离线存储。</p><h3 id="Application-Cache"><a href="#Application-Cache" class="headerlink" title="Application Cache"></a>Application Cache</h3><p>通常用于静态资源（静态页面）的缓存。</p><p>涉及角色：服务器和<code>html</code>文件。</p><ul><li><p>服务器端：负责管理维护<code>manifest.appcache</code>文件。</p><ul><li><p><code>manifest</code> 文件可分为三个部分：</p><p><code>CACHE MANIFEST</code> - 在此标题下列出的文件将在首次下载后进行缓存(要缓存的文件)</p><p><code>NETWORK</code> - 在此标题下列出的文件需要与服务器连接，且不会被缓存（千万不要把首页<code>index</code>放入<code>NETWORK</code>中禁止缓存，否则插件等无法使用）</p><p><code>FALLBACK</code> - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）</p></li></ul></li><li><p><code>Application Cache</code>生命销毁规则</p><ul><li><p>用户清空浏览器的缓存，此时<code>Application Cache</code>本地缓存将销毁。</p></li><li><p><code>manifest</code>文件被修改时，因为应用的缓存会在其 <code>manifest</code> 文件更改时被更新。如果您编辑了一幅图片，或者修改了一个 <code>JavaScript</code> 函数，这些改</p><p>变都不会被重新缓存，此时<code>Application Cache</code>本地缓存将销毁。</p></li><li><p>由程序来更新应用缓存</p></li></ul></li></ul><h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><p><code>Web Storage</code> 是<code>H5</code> 引入的一个帮助解决<code>cookie</code>存储本地缓存的重要功能。</p><blockquote><p>Webstorage 中有5M容量，cookie只有4k。</p></blockquote><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p><code>sessionStorage</code>将数据保存在<code>session</code>中，浏览器关闭数据就消失。</p><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p><code>localStorage</code>则一直将数据保存在客户端本地，除非手动删除，否则一直保存。</p><p>不管是<code>sessionStorage</code>，还是<code>localStorage</code>，可使用的<code>API</code>相同，常用的有如下几个（以<code>localStorage</code>为例）：</p><ul><li><p>保存数据：<code>localStorage.setItem(key,value)</code>;</p></li><li><p>读取数据：<code>localStorage.getItem(key)</code>;</p></li><li><p>删除单个数据：<code>localStorage.removeItem(key)</code>;</p></li><li><p>删除所有数据：<code>localStorage.clear()</code>;</p></li><li><p>得到某个索引的<code>key</code>：<code>localStorage.key(index)</code>;</p></li></ul><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><ul><li><p>WebSocket协议为web应用程序客户端和服务端之间提供了一种全双工通信机制。</p></li><li><p>握手阶段采用HTTP协议，在服务端与客户端初次握手时，将HTTP协议升级成WebSocket协议当链接成功时就可以在双工模式下来回传递信息。</p></li><li><p>没有同源限制，客户端可以与任意服务器通信。</p></li><li><p>协议标识符为wx（如果加密为wxs）。</p></li><li><p>除了协议定义外还有JS定义，只需要链接远程主机，并建立一个WebSocket实例链接到对端的URL即可。</p></li></ul><h2 id="无障碍"><a href="#无障碍" class="headerlink" title="无障碍"></a>无障碍</h2><p>无障碍是一种让尽可能多的用户可以使用你的网站的做法。</p><p>只要确保恰当的 HTML 元素被用于适当的目的，大量的网页内容即可具有无障碍；当正确使用 CSS 与 JavaScript 的时候，也能够使得网</p><p>页具有很好的无障碍；可以提高无障碍的另一类内容是多媒体（视频，音频和图像）内容提供适当的文本替代方案，以便辅助技术和相应</p><p>的用户能够理解。</p>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>html</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webpack原理</title>
    <link href="/2023/04/10/Webpack%EF%BC%88%E4%B8%80%EF%BC%89%E5%8E%9F%E7%90%86/"/>
    <url>/2023/04/10/Webpack%EF%BC%88%E4%B8%80%EF%BC%89%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Webpack究竟解决了什么问题？"><a href="#Webpack究竟解决了什么问题？" class="headerlink" title="Webpack究竟解决了什么问题？"></a>Webpack究竟解决了什么问题？</h1><p>前端应用的繁荣发展，项目代码不断膨胀.。为了减少维护成本，提高代码的可复用性，在前端项目中更高效的管理和维护项目中的每一个资源 &#x3D;&#x3D;&gt; 模块化思想&#x3D;&gt;模块化演变&#x3D;&gt;模块化规范&#x3D;&gt;模块化打包工具</p><h2 id="模块化演变"><a href="#模块化演变" class="headerlink" title="模块化演变"></a>模块化演变</h2><p>早在模块化标准还没有诞生的时候，前端模块化的雏形有三种形式：</p><ul><li><p>文件划分</p></li><li><p>命名空间</p></li><li><p>IIFE 私有作用域</p></li></ul><p>文件划分：</p><p>把应用的状态和逻辑放到不同的 JS 文件中，HTML 中通过不同的 script 标签一一引入。这样的缺点是：</p><ol><li>模块变量相当于在全局声明和定义，会有变量名冲突的问题。</li><li>变量都在全局定义，导致难以调试，我们很难知道某个变量到底属于哪些模块。</li><li><strong>无法清晰地管理模块之间的依赖关系和加载顺序。假如 a.js 依赖 b.js，那么 HTML 中的 script 执行顺序需要手动调整，不然可能会产生运行时错误。</strong></li></ol><p>命名空间和IIFE（立即执行函数）都可以解决文件划分的前两个缺点，但同样的存在第三个缺点，以及代码不优雅等问题。</p><p>之后开始出现一些模块化的规范。</p><h2 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h2><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>是<strong>Node.js</strong>中遵循的模块规范，约定</p><ul><li>一个文件就是一个模块</li><li>每个模块都有单独的作用域</li><li>通过module.exports 导出成员</li><li>通过require函数载入模块</li></ul><p>CommonJS 定义了一套完整的模块化代码规范，不过仍然存在一些问题：</p><ul><li>它的模块加载器由 Node.js 提供，依赖了 Node.js 本身的功能实现。如果 CommonJS 模块直接放到浏览器中无法执行。</li><li>CommonJS 约定以同步的方式进行模块加载，这种加载机制放到浏览器端，会带来明显的性能问题。它会产生大量同步的模块请求，浏览器要等待响应返回后才能继续解析模块。即，模块请求会造成<strong>浏览器 JS 解析过程的阻塞，导致页面加载速度缓慢</strong>。</li></ul><p>因此，该规范主要适用于服务端，因为服务端可以直接从硬盘中调用所需要的模块，而这个过程速度是非常快的。</p><p><strong>典型代表有：Node.js、微信小程序。</strong></p><blockquote><p>但是使用webpack以后中可以在浏览器中使用commonjs，因为webpack可以对其进行处理。</p></blockquote><h3 id="ES-Module"><a href="#ES-Module" class="headerlink" title="ES Module"></a>ES Module</h3><p>在浏览器中使用<code>ES Module</code>模块化规范</p><h4 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导出变量或方法</span><br><span class="hljs-keyword">export</span> &#123; name,hello,<span class="hljs-title class_">Preson</span> &#125;<br><span class="hljs-comment">// 取别名</span><br><span class="hljs-keyword">export</span> &#123; hello <span class="hljs-keyword">as</span> fooHello &#125;<br><br><span class="hljs-comment">// 默认导出变量、方法，接收可以随便取名</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> name  <span class="hljs-comment">// 导出</span><br><br><span class="hljs-keyword">import</span> abc <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>  <span class="hljs-comment">// 导入</span><br></code></pre></td></tr></table></figure><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><ul><li>export导出不是把值复制一份给你，而是把存放值的<strong>地址</strong>给你（拿到的值会受内部值修改的影响），外部只读不可修改。（浅复制）</li><li>导入的成员必须要有完整的文件名称，相对路径中的.&#x2F;不能省略，可以使用绝对路径或完整的url（ &#x2F;xx&#x2F;modules.js 或 http:&#x2F;&#x2F; ）</li></ul><p>完整文件名称</p><blockquote><p>使用相对路径的话，不能省略.&#x2F;</p></blockquote> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 不能省略文件后缀，也不能省略index.js</span><br><span class="hljs-keyword">import</span> &#123; lowercase &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utils/index.js&#x27;</span><br></code></pre></td></tr></table></figure><p>若只需要执行模块，而不提取成员</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span><br></code></pre></td></tr></table></figure><p>要拿的成员很多可以先放到一个对象里</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> mod <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mod) <span class="hljs-comment">// mod上有模块导出的所有成员</span><br></code></pre></td></tr></table></figure><p>如果需要动态加载模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./module.js&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">module</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="运行环境兼容性问题"><a href="#运行环境兼容性问题" class="headerlink" title="运行环境兼容性问题"></a>运行环境兼容性问题</h4><p>由于<code>ES Module</code>是2014年提出来的，早期的浏览器不支持这一特性。兼容性问题还是需要考虑</p><h2 id="模块化打包工具的出现"><a href="#模块化打包工具的出现" class="headerlink" title="模块化打包工具的出现"></a>模块化打包工具的出现</h2><p>问题：</p><ul><li>ES Modules模块系统本身存在环境兼容问题</li><li>模块化的方式划分出来的模块文件过多，导致浏览器需要频繁发送网络请求，影响应用工作效率</li><li>HTML和CSS这些资源文件也会面临需要被模块化的问题</li></ul><p>需要一些解决方案&#x2F;工具可以让我们在开发应用的过程中继续享受模块化带来的优势，又不必担心模块化对生产环境的影响。</p><p>需求：</p><ul><li><p>具备编译能力，可以将开发阶段编写的包含新特性的代码转化为能够兼容大多数环境的代码   —— 解决环境兼容问题</p></li><li><p>将散落的模块打包到一起，解决浏览器频繁请求模块文件、发送网络请求的问题                      —— 解决请求频繁问题</p></li><li><p>支持不同种类的前端资源模块类型（css,png,…）                                                                          —— 解决不同资源文件模块化问题</p><blockquote><p>前两点gulp也可以实现，但第三点gulp很难实现，所以前端主流打包工具——Webpack</p></blockquote></li></ul><h1 id="如何使用Webpack进行模块化打包？"><a href="#如何使用Webpack进行模块化打包？" class="headerlink" title="如何使用Webpack进行模块化打包？"></a>如何使用Webpack进行模块化打包？</h1><p>本质：实现前端整体的模块化开发的一个模块化打包工具。</p><p>作为一个模块打包器，<code>webpack</code>具有以下特性</p><ul><li>模块加载器（<code>Loader</code>）  编译转换有环境兼容问题的代码 ( 比如转换源代码，解决有些浏览器不兼容ES Module)</li><li>代码拆分（<code>Code Splitting</code>） 解决打包文件太大、太碎的问题。比如可以把一开始用到的模块打包到一起，其他模块等到需要时再加载，实现<code>渐进式加载</code></li><li>资源模块（<code>Asset Module</code>） <code>webpack</code>支持在<code>js</code>以模块化的方式载入任意类型的资源文件,比如<code>css</code>类型文件</li></ul><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>1.不使用webpack打包工具</p><p><code>ES Module</code>的一种载入方式，<code>type=&quot;module&quot;</code>用来区分加载的是一个普通<code>JS</code>脚本还是一个模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script  <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;module&quot;</span>  src=<span class="hljs-string">&quot;src/index.js&quot;</span>&gt; &lt;/script&gt;<br></code></pre></td></tr></table></figure><blockquote><p>对于不支持<code>ES Module</code>的浏览器，直接这样使用就会报错</p></blockquote><p>2.使用webpack打包工具</p><ul><li>初始化<ul><li>webpack本身是npm的一个工具模块，首先初始化package.json用来管理npm依赖的版本</li><li>webpack是Webpack的核心模块，webpack-cli是Webpack的CLI程序，用来在命令行中调用Webpack</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 生成package.json<br>npm init --y <br><br>// 安装Webpack的核心模块和cli程序<br>npm i webpack webpack-cli --save-dev<br></code></pre></td></tr></table></figure><blockquote><p>npx是npm5.2以后新增的一个命令，可以更方便的执行远程模块或者node_modules中的CLI程序</p></blockquote><ul><li>运行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx webpack<br></code></pre></td></tr></table></figure><p><code>Webpack</code>默认会自动从<code>src/index.js</code>文件开始打包，然后根据代码中的模块导入操作自动将所有用到的模块打包到一起。</p><ul><li><code>dist</code></li></ul><p>打包结果存放在项目根目录下的<code>dist</code>目录下的<code>main.js</code>文件中</p><p>&#x3D;&#x3D;3.修改webpack的默认配置&#x3D;&#x3D;</p><p><code>entry</code>（入口）:  指示 Webpack 从哪个文件开始打包</p><p><code>output</code>（输出）:  指示 Webpack 打包完的文件输出到哪里去，如何命名等</p><p><code>loader</code>（加载器）: webpack 本身只能处理 js、json 等资源，其他资源需要借助 loader，Webpack 才能解析</p><p><code>plugins</code>（插件）:  扩展 Webpack 的功能</p><p><code>mode</code>（模式）: 主要有两种模式，development（开发模式）和  production（生产模式）</p><p>格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">module.exports = &#123;<br>  // 入口<br>  entry: <span class="hljs-string">&quot;&quot;</span>,<br>  // 输出<br>  output: &#123;&#125;,<br>  // 加载器<br>  module: &#123;<br>    rules: [],<br>  &#125;,<br>  // 插件<br>  plugins: [],<br>  // 模式<br>  mode: <span class="hljs-string">&quot;&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>在项目根目录下添加一个<code>webpack.config.js</code>配置文件</p><p>这个文件运行在<code>nodejs</code>环境中，需要按照<code>CommonJS</code>的规范导入模块导出成员，可以直接在这个文件中使用<code>path</code>之类的<code>Node.js</code>内置模块</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ./webpack.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span> = &#123;<br>    <span class="hljs-attr">entry</span>:<span class="hljs-string">&#x27;./src/main.js&#x27;</span> <span class="hljs-comment">// 注意这里的./不能省略</span><br>    <span class="hljs-attr">output</span>:&#123;<br>        <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>        <span class="hljs-attr">path</span>:path.<span class="hljs-title function_">join</span>(__dirname,<span class="hljs-string">&#x27;output&#x27;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="如何通过Loader实现特殊资源加载？"><a href="#如何通过Loader实现特殊资源加载？" class="headerlink" title="如何通过Loader实现特殊资源加载？"></a>如何通过Loader实现特殊资源加载？</h1><p><strong>Loader</strong> 专注实现 <strong>资源模块的加载</strong>，从而实现整体项目的打包。</p><p>webpack内部默认的<code>loader</code>只能处理<code>js</code>模块，如果需要加载其他类型的模块，就需要配置不同的<code>loader</code></p><p>以加载<code>css</code>资源模块为例</p><ul><li><p>通过<code>npm</code>先去安装这个<code>Loader</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bas">npm install css-loader --save-dev<br></code></pre></td></tr></table></figure></li><li><p>在配置文件添加对应的配置——css-loader   </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">// ./webpack.config.js<br>module.export = &#123;<br>    entry:<span class="hljs-string">&#x27;./src/main.js&#x27;</span> // 注意这里的./不能省略<br>    output:&#123;<br>        filename:<span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>&#125;,<br>module:&#123;<br>    rules:[<br>        <span class="hljs-built_in">test</span>:/\.css$/,   // 正则表达式匹配，根据打包过程中所遇到文件路径匹配是否使用这个loader<br>        use:<span class="hljs-string">&#x27;css-loader&#x27;</span> //指定具体的loader<br>    ]<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>安装<code>style-loader</code></p><p>由于<code>css-loader</code>只会把<code>css</code>模块加载到<code>JS</code>代码中，但并不会使用这个模块,需要<code>style-loader</code>将<code>css-loader</code>转换后的结果通过<code>style</code>标签的方式追加在页面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ./webpack.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span> = &#123;<br>    <span class="hljs-attr">entry</span>:<span class="hljs-string">&#x27;./src/main.js&#x27;</span> <span class="hljs-comment">// 注意这里的./不能省略</span><br>    <span class="hljs-attr">output</span>:&#123;<br>        <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;bundle.js&#x27;</span><br>&#125;,<br><span class="hljs-attr">module</span>:&#123;<br>    <span class="hljs-attr">rules</span>:[<br>        <span class="hljs-attr">test</span>:<span class="hljs-regexp">/\.css$/</span>,   <span class="hljs-comment">// 正则表达式匹配，根据打包过程中所遇到文件路径匹配是否使用这个loader</span><br>        <span class="hljs-attr">use</span>:[<br>                <span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-comment">// 注意有多个loader时，执行顺序是从数组后面往前</span><br>                <span class="hljs-string">&#x27;css-loader&#x27;</span> <br>        ]<br>    ]<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="如何利用插件机制横向扩展Webpack的构建能力？"><a href="#如何利用插件机制横向扩展Webpack的构建能力？" class="headerlink" title="如何利用插件机制横向扩展Webpack的构建能力？"></a>如何利用插件机制横向扩展Webpack的构建能力？</h1><p><strong>Plugin</strong> 解决项目中 <strong>除了资源加载以外</strong> 的自动化工作。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>实现自动在打包之前清除<code>dist</code>目录（上次的打包结果）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install clean-webpack-plugin --save-dev<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">const &#123;CleanWebpackPlugin&#125; = require(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>)<br><br>module.export = &#123;<br>    entry:<span class="hljs-string">&#x27;./src/main.js&#x27;</span> // 注意这里的./不能省略<br>    output:&#123;<br>        filename:<span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>&#125;,<br>plugins:[<br>    new CleanWebpackPlugin()<br>]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>自动生成应用所需要的<code>HTML</code>文件</li></ul><blockquote><p>即自动生成一个使用所有打包结果的html文件到dist目录下。自动引入资源文件的方式，可以确保文件路径正确。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install html-webpack-plugin --save-dev<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">const &#123;CleanWebpackPlugin&#125; = require(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>)<br>const HtmlWebpackPlugin = require(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)<br><br>module.export = &#123;<br>    entry:<span class="hljs-string">&#x27;./src/main.js&#x27;</span> // 注意这里的./不能省略<br>    output:&#123;<br>        filename:<span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>&#125;,<br>plugins:[<br>    new CleanWebpackPlugin(),<br>    new HtmlWebpackPlugin(&#123;<br>    filename:<span class="hljs-string">&#x27;index.html&#x27;</span>  // 生成的dist下html文件名，默认是index.html<br>            title:<span class="hljs-string">&#x27;自定义标题名&#x27;</span>，<br>            template：<span class="hljs-string">&#x27;./src/index.html&#x27;</span> // 自定义html模板动态生成<br>    &#125;)<br>]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>根据不同环境为代码注入类似API地址这种可能变化的部分</li><li>拷贝不需要参与打包的资源文件到输出目录</li></ul><blockquote><p>有一些不需要参与构建的静态文件，最终也需要发布到线上，建议把这类文件统一 放在项目根目录下的public或者static目录中。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install copy-webpack-plugin --save-dev<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">const &#123;CleanWebpackPlugin&#125; = require(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>)<br>const HtmlWebpackPlugin = require(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)<br>const CopyWebpackPlugin = require(<span class="hljs-string">&#x27;copy-webpack-plugin&#x27;</span>)<br><br>module.export = &#123;<br>    entry:<span class="hljs-string">&#x27;./src/main.js&#x27;</span> // 注意这里的./不能省略<br>    output:&#123;<br>        filename:<span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>&#125;,<br>plugins:[<br>    new CleanWebpackPlugin(),<br>    new HtmlWebpackPlugin(&#123;<br>    filename:<span class="hljs-string">&#x27;index.html&#x27;</span>  // 生成的dist下html文件名，默认是index.html<br>            title:<span class="hljs-string">&#x27;自定义标题名&#x27;</span>，<br>            template：<span class="hljs-string">&#x27;./src/index.html&#x27;</span> // 自定义html模板动态生成<br>    &#125;),<br>    new CopyWebpackPlugin([<br>        <span class="hljs-string">&#x27;pulic&#x27;</span>  // 需要拷贝的目录或者路径<br>    ])<br>]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>压缩Webpack打包完成后输出的文件</li><li>自动发布打包结果到服务器实现自动部署</li></ul><h2 id="插件机制实现原理"><a href="#插件机制实现原理" class="headerlink" title="插件机制实现原理"></a>插件机制实现原理</h2><p>往webpack的生命周期的钩子函数中挂载一些任务函数实现的。</p><h1 id="处理-js-兼容性和规范性"><a href="#处理-js-兼容性和规范性" class="headerlink" title="处理 js 兼容性和规范性"></a>处理 js 兼容性和规范性</h1><p>有人可能会问，<code>js </code>资源<code> Webpack</code> 不能已经处理了吗，为什么我们还要处理呢？</p><p>原因是 <code>Webpack</code> 对 <code>js </code>处理是有限的，只能编译<code> js</code> 中 ES 模块化语法，不能编译其他具有新特性的<code>js</code>语法。</p><p>其次开发中，团队对代码格式是有严格要求的，我们不能由肉眼去检测代码格式，需要使用专业的工具来检测。</p><ul><li>针对<code> js</code> 兼容性处理，我们使用<code>Babel</code>来完成</li><li>针对代码格式，我们使用 <code>Eslint </code>来完成</li></ul><p>我们先完成<code> Eslint</code>，检测代码格式无误后，在由<code>Babel</code>做代码兼容性处理</p><h2 id="Eslint"><a href="#Eslint" class="headerlink" title="Eslint"></a>Eslint</h2><p>用来检测 js 和 jsx 语法的工具，可以配置各项功能。(Plugin)</p><p>1.下载包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i eslint-webpack-plugin eslint -D<br></code></pre></td></tr></table></figure><p>2.定义<code>Eslint</code>配置文件<code>.eslintrc.js</code>（位于项目根目录）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// 继承 Eslint 规则</span><br>  <span class="hljs-attr">extends</span>: [<span class="hljs-string">&quot;eslint:recommended&quot;</span>],<br>  <span class="hljs-attr">env</span>: &#123;<br>    <span class="hljs-attr">node</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 启用node中全局变量</span><br>    <span class="hljs-attr">browser</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 启用浏览器中全局变量</span><br>  &#125;,<br>  <span class="hljs-attr">parserOptions</span>: &#123;<br>    <span class="hljs-attr">ecmaVersion</span>: <span class="hljs-number">6</span>,<br>    <span class="hljs-attr">sourceType</span>: <span class="hljs-string">&quot;module&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">rules</span>: &#123;<br>    <span class="hljs-string">&quot;no-var&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-comment">// 不能使用 var 定义变量</span><br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>3.将<code>Eslint</code>配置到webpack中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ESLintWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;eslint-webpack-plugin&quot;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span> = &#123;<br>    <span class="hljs-attr">entry</span>:<span class="hljs-string">&#x27;./src/main.js&#x27;</span>, <span class="hljs-comment">// 注意这里的./不能省略</span><br>    <span class="hljs-attr">output</span>:&#123;<br>        <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>&#125;,<br><span class="hljs-attr">plugins</span>:[<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ESLintWebpackPlugin</span>([<br>            <span class="hljs-comment">// 指定检查文件的根目录</span><br>            <span class="hljs-attr">context</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;src&quot;</span>)<br>    ])<br>],<br>    <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;development&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>4.运行指令，在控制台查看<code>Eslint</code>检查效果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx webpack<br></code></pre></td></tr></table></figure><p>5.可以通过配置<code>.eslintignore</code>更精细的控制<code>Eslint</code>检查、不检查的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 忽略dist目录下所有文件</span><br>dist<br></code></pre></td></tr></table></figure><h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p><code>Babel</code>是目前主流的一款<code>js</code>编译器，可以帮助我们将一些使用了新特性的代码编译为当前环境支持的代码。</p><p>Babel是基于插件机制实现的，我们需要一个插件来转换一个代码特性，preset-env相当于一个插件的集合，这个集合包含了最新的js新特性，</p><p>1.下载包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i babel-loader @babel/core @babel/preset-env -D<br></code></pre></td></tr></table></figure><p>2.定义<code>Babel</code>配置文件<code>babel.config.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// 预设</span><br>  <span class="hljs-attr">presets</span>: [<span class="hljs-string">&quot;@babel/preset-env&quot;</span>]<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>presets 预设：就是一组 Babel 插件, 扩展 Babel 功能<ul><li><code>@babel/preset-env</code>: 一个智能预设，允许您使用最新的 JavaScript。</li><li><code>@babel/preset-react</code>：一个用来编译 React jsx 语法的预设</li><li><code>@babel/preset-typescript</code>：一个用来编译 TypeScript 语法的预设</li></ul></li></ul><p>3.将<code>Babel </code>配置到<code>webpack</code>中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span> = &#123;<br>    <span class="hljs-attr">entry</span>:<span class="hljs-string">&#x27;./src/main.js&#x27;</span> <span class="hljs-comment">// 注意这里的./不能省略</span><br>    <span class="hljs-attr">output</span>:&#123;<br>        <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>&#125;,<br><span class="hljs-attr">module</span>:&#123;<br>    <span class="hljs-attr">rules</span>:[<br>            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,<br>            <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>, <span class="hljs-comment">// 排除node_modules代码不编译</span><br>            <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;babel-loader&quot;</span><br>    ]<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Webpack核心工作原理"><a href="#Webpack核心工作原理" class="headerlink" title="Webpack核心工作原理"></a>Webpack核心工作原理</h1><p><code>Webpack</code>在整个打包的过程中：</p><ul><li>通过<code>Loader</code>处理特殊类型资源的加载，例如加载样式、图片</li><li>通过<code>Plugin</code>各种自动化的构建任务，例如自动压缩、自动发布</li></ul><p>查阅源码的思路：</p><ol><li><p><code>Webpack CLI</code>启动打包流程</p><blockquote><p><code>Webpack CLI</code>：作用就是将<code>CLI</code>参数和<code>Webpack</code>配置文件中的配置整合得到一个完整的配置对象</p></blockquote><p><code>Webpack CLI</code>会通过<code>yargs</code>模块解析<code>CLI</code>参数(运行<code>webpack</code>命令时通过命令行传入的参数)，调用<code>bin/utils/convert-argv.js</code>模块将得到的命令行参数转换为<code>Webpack</code>的配置选项对象。然后开始载入<code>Webpack</code>核心模块，传入配置选项，创建<code>Compiler</code>对象。</p></li><li><p>载入<code>Webpack</code>核心模块，创建<code>Compiler</code>对象</p><p>根据传入的<code>Option</code>是数组还是对象，决定多路打包还是单线打包。</p></li><li><p>使用<code>Compiler</code>对象开始编译整个项目</p><p>创建了<code>Compiler</code>之后<code>Webpack</code>开始注册已配置的插件，触发特定的<code>Hook</code>,调用<code>Compiler</code>对象的<code>run</code>方法，开始构建整个应用。</p></li><li><p>从入口文件开始，解析模块依赖,形成依赖关系树</p><p>创建<code>compilation</code>作为整个上下文变量，紧接着触发<code>make</code>钩子，进入到整个构建过程中最核心的阶段：<code>make</code>阶段。</p></li><li><p>递归依赖树，将每个模块交给对应的<code>Loader</code>处理</p><p><code>make</code>阶段主体的目标：根据<code>entry</code>配置找到入口模块，开始依次递归出所有依赖，形成依赖关系树，然后将递归到的每个模块交给不同的<code>Loader</code>处理 。 </p></li><li><p>合并<code>Loader</code>处理完的结果，将打包结果输出到<code>dist</code>目录</p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://webpack.docschina.org/concepts/">官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>打包工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>打包工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webpack生产环境优化</title>
    <link href="/2023/04/10/Webpack%EF%BC%88%E4%BA%8C%EF%BC%89%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%BC%98%E5%8C%96/"/>
    <url>/2023/04/10/Webpack%EF%BC%88%E4%BA%8C%EF%BC%89%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="生产环境优化"><a href="#生产环境优化" class="headerlink" title="生产环境优化"></a>生产环境优化</h1><p><strong>生产模式</strong>是开发完成代码后，我们需要得到代码将来部署上线。这个模式下我们主要对代码进行优化，让其运行性能更好。</p><p>优化主要从两个角度出发:</p><ul><li>优化代码运行性能</li><li>优化代码打包速度</li></ul><h2 id="CSS文件处理"><a href="#CSS文件处理" class="headerlink" title="CSS文件处理"></a>CSS文件处理</h2><p>默认生产模式已经开启了：<code>html</code>压缩和 <code>js</code> 压缩，不需要额外进行配置。故着重考虑<code>CSS</code>文件处理。</p><h3 id="优化CSS加载性能"><a href="#优化CSS加载性能" class="headerlink" title="优化CSS加载性能"></a>优化CSS加载性能</h3><h4 id="link标签载入"><a href="#link标签载入" class="headerlink" title="link标签载入"></a>link标签载入</h4><p><code>css</code> 文件目前被打包到<code> js</code> 文件中，当<code> js</code> 文件加载时，会创建一个 <code>style</code> 标签来生成样式。<code>mini-css-extract-plugin</code>会将<code>css</code>提取出来，通过<code>link</code>标签加载。</p><p>1.下载包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i mini-css-extract-plugin -D<br></code></pre></td></tr></table></figure><p>2.配置<code>webpack.prod.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mini-css-extract-plugin&quot;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span> = &#123;<br>    <span class="hljs-attr">entry</span>:<span class="hljs-string">&#x27;./src/main.js&#x27;</span> <span class="hljs-comment">// 注意这里的./不能省略</span><br>    <span class="hljs-attr">output</span>:&#123;<br>        <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>&#125;,<br>    <span class="hljs-attr">modele</span>:&#123;<br>        <span class="hljs-attr">rules</span>:[<br>            <span class="hljs-attr">test</span>:<span class="hljs-regexp">/\.css$/</span>,<br>            <span class="hljs-attr">use</span>:[<br>            <span class="hljs-string">&#x27;css-loader&#x27;</span><br>        ]<br>        ]<br>    &#125;<br><span class="hljs-attr">plugins</span>:[<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>(&#123;<br>            <span class="hljs-comment">// 定义输出文件名和目录</span><br>            <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;static/css/main.css&quot;</span>,<br>        &#125;)<br>    ]<br>    <span class="hljs-attr">mode</span>:<span class="hljs-string">&quot;production&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="兼容性处理"><a href="#兼容性处理" class="headerlink" title="兼容性处理"></a>兼容性处理</h4><p>1.下载包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i postcss-loader postcss postcss-preset-env -D<br></code></pre></td></tr></table></figure><p>2.配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mini-css-extract-plugin&quot;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span> = &#123;<br>    <span class="hljs-attr">entry</span>:<span class="hljs-string">&#x27;./src/main.js&#x27;</span> <span class="hljs-comment">// 注意这里的./不能省略</span><br>    <span class="hljs-attr">output</span>:&#123;<br>        <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>&#125;,<br><span class="hljs-attr">module</span>:&#123;<br>    <span class="hljs-attr">rules</span>:[<br>        <span class="hljs-attr">test</span>:<span class="hljs-regexp">/\.css$/</span>,   <span class="hljs-comment">// 正则表达式匹配，根据打包过程中所遇到文件路径匹配是否使用这个loader</span><br>        <span class="hljs-attr">use</span>:[<br>            <span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>,<br>            <span class="hljs-string">&quot;css-loader&quot;</span>,<br>            &#123;<br>            <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;postcss-loader&quot;</span>,<br>            <span class="hljs-attr">options</span>:&#123;<br>            <span class="hljs-attr">postcssOptions</span>:&#123;<br>            <span class="hljs-attr">plugins</span>:[<br>            <span class="hljs-string">&quot;postcss-preset-env&quot;</span>, <span class="hljs-comment">// 能解决大多数样式兼容性问题</span><br>        ]<br>            &#125;<br>            &#125;<br>            &#125;<br>       ]<br>    ]<br>&#125;<br>    <span class="hljs-attr">mode</span>:<span class="hljs-string">&quot;production&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS压缩"><a href="#CSS压缩" class="headerlink" title="CSS压缩"></a>CSS压缩</h3><p>1.下载包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i css-minimizer-webpack-plugin -D<br></code></pre></td></tr></table></figure><p>2.配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">CssMinimizerPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;css-minimizer-webpack-plugin&quot;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span> = &#123;<br>    <span class="hljs-attr">entry</span>:<span class="hljs-string">&#x27;./src/main.js&#x27;</span> <span class="hljs-comment">// 注意这里的./不能省略</span><br>    <span class="hljs-attr">output</span>:&#123;<br>        <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>&#125;,<br><span class="hljs-attr">plugins</span>:[<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CssMinimizerPlugin</span>()<br>]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h2><p>作用：去除代码中未引用部分和冗余部分。</p><blockquote><p>不是指某个配置选项，是一组功能搭配使用后的优化效果。</p></blockquote><p><code>./src/components.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">Button</span> = (<span class="hljs-params"> </span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>( <span class="hljs-string">&#x27;button&#x27;</span> )<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;dead-code&#x27;</span>)   <span class="hljs-comment">// 未引用代码</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">Link</span> = (<span class="hljs-params"> </span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>( <span class="hljs-string">&#x27;a&#x27;</span> )<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">Heading</span> = level =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>( <span class="hljs-string">&#x27;h&#x27;</span> + level )<br>&#125;<br></code></pre></td></tr></table></figure><p> <code>./src/index.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components&#x27;</span><br><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(<span class="hljs-title class_">Button</span>())<br></code></pre></td></tr></table></figure><p>在生产模式<code>production</code>下，Webpack会自动开启<code>Tree Shacking</code>功能</p><p>在其他模式下开启<code>Tree Shacking</code>功能配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span> = &#123;<br>    <span class="hljs-attr">mode</span>:<span class="hljs-string">&#x27;none&#x27;</span>,<br>    <span class="hljs-attr">entry</span>:<span class="hljs-string">&#x27;./src/main.js&#x27;</span> <span class="hljs-comment">// 注意这里的./不能省略</span><br>    <span class="hljs-attr">output</span>:&#123;<br>        <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>&#125;,<br><span class="hljs-attr">optimization</span>:&#123;    <span class="hljs-comment">// 集中配置webpack内部优化功能</span><br>        <span class="hljs-attr">usedExports</span>: <span class="hljs-literal">true</span>,   <span class="hljs-comment">// 在输出结果中只导出外部使用了的成员</span><br>        <span class="hljs-attr">minimize</span>: <span class="hljs-literal">true</span>,<span class="hljs-comment">// 压缩未引用的代码 </span><br>        <span class="hljs-attr">concatenateModules</span>: <span class="hljs-literal">true</span>  <span class="hljs-comment">// 尽可能的将所有模块合并输出到一个函数中</span><br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><p>如果把代码看做一颗大树，<code>usedExports</code>负责标记「枯树叶」，<code>minimize</code>负责[ 摇掉」它们。</p><p>普通的打包结果是将每一个模块放在单独的函数中，如果模块很多，结果中就会有很多的模块函数，可以使用合并模块功能。</p><h2 id="Code-Splitting"><a href="#Code-Splitting" class="headerlink" title="Code Splitting"></a>Code Splitting</h2><p>分包&#x2F;代码分割</p><p>通过<code>Webpack</code>实现前端模块化，所有代码最终都被打包到一起，可能会造成<code>bundle</code>体积过大，并不是每个模块在启动时都是必要的。</p><p>实现分包的方式主要有两种。</p><h3 id="多入口打包"><a href="#多入口打包" class="headerlink" title="多入口打包"></a>多入口打包</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span> = &#123;<br>    <span class="hljs-attr">mode</span>:<span class="hljs-string">&#x27;none&#x27;</span>,<br>    <span class="hljs-attr">entry</span>: &#123;<br>        <span class="hljs-attr">index</span>:<span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>        <span class="hljs-attr">album</span>:<span class="hljs-string">&#x27;./src/album.js&#x27;</span><br>    &#125;<br>    <span class="hljs-attr">output</span>:&#123;<br>        <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;[name].bundle.js&#x27;</span> <span class="hljs-comment">// 有多少个入口就会有多少个出口</span><br>&#125;,<br>    <span class="hljs-attr">plugins</span>:[<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>(),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>    <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;index.html&#x27;</span>  <span class="hljs-comment">// 生成的dist下html文件名，默认是index.html</span><br>            <span class="hljs-attr">title</span>:<span class="hljs-string">&#x27;多入口打包&#x27;</span>，<br>            template：<span class="hljs-string">&#x27;./src/index.html&#x27;</span>, <span class="hljs-comment">// 自定义html模板动态生成</span><br>            <span class="hljs-attr">chunks</span>:[<span class="hljs-string">&#x27;index&#x27;</span>] <br>    &#125;),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>    <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;album.html&#x27;</span>  <span class="hljs-comment">// 生成的dist下html文件名，默认是index.html</span><br>            <span class="hljs-attr">title</span>:<span class="hljs-string">&#x27;多入口打包&#x27;</span>，<br>            template：<span class="hljs-string">&#x27;./src/album.html&#x27;</span>, <span class="hljs-comment">// 自定义html模板动态生成</span><br>            <span class="hljs-attr">chunks</span>:[<span class="hljs-string">&#x27;album&#x27;</span>] <span class="hljs-comment">// 指定html导入的js文件</span><br>    &#125;)<br>]<br>&#125;<br></code></pre></td></tr></table></figure><p> 不同入口中肯定会有公共模块，多入口打包方式肯定会出现不同的打包结果中会有相同的模块出现。</p><p>欲将这些公共的模块单独提取到一个<code>bundle</code>中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span> = &#123;<br>    <span class="hljs-attr">mode</span>:<span class="hljs-string">&#x27;none&#x27;</span>,<br>    <span class="hljs-attr">entry</span>: &#123;<br>        <span class="hljs-attr">index</span>:<span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>        <span class="hljs-attr">album</span>:<span class="hljs-string">&#x27;./src/album.js&#x27;</span><br>    &#125;<br>    <span class="hljs-attr">output</span>:&#123;<br>        <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;[name].bundle.js&#x27;</span> <span class="hljs-comment">// 有多少个入口就会有多少个出口</span><br>&#125;,<br>    <span class="hljs-attr">plugins</span>:[<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>(),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>    <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;index.html&#x27;</span>  <span class="hljs-comment">// 生成的dist下html文件名，默认是index.html</span><br>            <span class="hljs-attr">title</span>:<span class="hljs-string">&#x27;多入口打包&#x27;</span>，<br>            template：<span class="hljs-string">&#x27;./src/index.html&#x27;</span>, <span class="hljs-comment">// 自定义html模板动态生成</span><br>            <span class="hljs-attr">chunks</span>:[<span class="hljs-string">&#x27;index&#x27;</span>] <br>    &#125;),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>    <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;album.html&#x27;</span>  <span class="hljs-comment">// 生成的dist下html文件名，默认是index.html</span><br>            <span class="hljs-attr">title</span>:<span class="hljs-string">&#x27;多入口打包&#x27;</span>，<br>            template：<span class="hljs-string">&#x27;./src/album.html&#x27;</span>, <span class="hljs-comment">// 自定义html模板动态生成</span><br>            <span class="hljs-attr">chunks</span>:[<span class="hljs-string">&#x27;album&#x27;</span>]<br>    &#125;)<br>],<br>    <span class="hljs-attr">optimization</span>: &#123;<br>        <span class="hljs-attr">splitChunks</span>:&#123;<br>            <span class="hljs-attr">chunks</span>:<span class="hljs-string">&#x27;all&#x27;</span> <span class="hljs-comment">// 把所有的公共模块都提取到单独的bundle中</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态导入"><a href="#动态导入" class="headerlink" title="动态导入"></a>动态导入</h3><p><code>Webpack</code>中使用动态导入来实现模块的按需加载，而且动态导入的模块会被自动分包（提取到单独的<code>bundle</code>中）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (hash == <span class="hljs-string">&#x27;#posts&#x27;</span>) &#123;<br>    <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./posts/posts&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">&#123; <span class="hljs-keyword">default</span>: posts &#125;</span>) =&gt;</span> &#123;<br>        mainElement.<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">posts</span>())<br>    &#125;)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hash == <span class="hljs-string">&#x27;#album&#x27;</span>) &#123;<br>    <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./album/album&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">&#123; <span class="hljs-keyword">default</span>: album &#125;</span>) =&gt;</span> &#123;<br>        mainElement.<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">album</span>())<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>无须配置，只需要按照<code>ESModule</code>动态导入成员的方式去导入模块就可以，<code>Webpack</code>会自动处理分包和按需加载。<code>vue</code>中的路由映射组件就是通过这种动态导入的方式实现了按需加载。</p><h2 id="输出文件名Hash"><a href="#输出文件名Hash" class="headerlink" title="输出文件名Hash"></a>输出文件名Hash</h2><p>静态资源首次被加载后浏览器会进行缓存，同一个资源在缓存未过期情况下一般不会再去请求，那么当资源有更新时如何通知浏览器资源有变化呢？资源文件命名 <code>hash</code> 化就是解决该问题而生；</p><blockquote><p>对于浏览器来说，一方面期望每次请求页面资源时，获得的都是最新的资源；一方面期望在资源没有发生变化时，能够复用缓存对象。</p><p>开启客户端静态资源缓存，是为了减少访问服务器资源次数，提高响应速度。缓存过期时间一般需要设置的长一点，这个过程中如果引用发生了更新重新部署，无法及时更新到客户端。</p></blockquote><p>使用【文件名+文件哈希值】的方式，就可以实现只要通过文件名，就可以区分资源是否有更新。</p><blockquote><p>一旦资源文件发现变化，文件名称也可以跟着一起变换。对于客户端而言，全新的文件名就是全新的请求，没有缓存的问题。</p></blockquote><p><code>Webpack</code> 内置 <code>hash</code>有三种：</p><ul><li><code>hash</code>：每次构建会生成一个<code> hash</code>。和整个项目有关，只要项目有文件更改，就会改变 <code>hash</code>。</li><li><code>contenthash</code>：和单个文件的内容有关。指定文件的内容发生改变，就会改变 <code>hash</code>。</li><li><code>chunkhash</code>：和 <code>webpack </code>打包生成的 <code>chunk</code> 相关。每一个 <code>entry</code> ，都会有不用的 <code>hash</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span> = &#123;<br>    <span class="hljs-attr">mode</span>:<span class="hljs-string">&#x27;none&#x27;</span>,<br>    <span class="hljs-attr">entry</span>:<span class="hljs-string">&#x27;./src/main.js&#x27;</span> <span class="hljs-comment">// 注意这里的./不能省略</span><br>    <span class="hljs-attr">output</span>:&#123;<br>        <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;[name]-[hash].bundle.js&#x27;</span>  <span class="hljs-comment">// 文件</span><br>        <span class="hljs-comment">// filename:&#x27;[name]-[contenthash].bundle.js&#x27;  </span><br>    <span class="hljs-comment">// filename:&#x27;[name]-[chunkhash].bundle.js&#x27;  </span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h1><p><code>webpack-dev-server</code>： 是一个本地开发服务器，会自动监听变化，自动打包构建，自动更新刷新浏览器。</p><p><strong>特点</strong>： </p><ul><li>不会产生<code>dist</code>文件，将打包结果暂时存在内存中，内部的<code>http-sever</code>访问这些文件并读取数据，发送给浏览器</li><li>减少磁盘的读取，提高构建效率</li></ul><p>1.下载包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i webpack-dev-server -D<br></code></pre></td></tr></table></figure><p>2.在<code>webpack.config.js</code>配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">module.export = &#123;<br>    entry:<span class="hljs-string">&#x27;./src/main.js&#x27;</span> // 注意这里的./不能省略<br>    output:&#123;<br>        filename:<span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>&#125;,<br>// 开发服务器<br>    devServer: &#123;<br>        host: <span class="hljs-string">&quot;localhost&quot;</span>, // 启动服务器域名<br>        port: <span class="hljs-string">&quot;3000&quot;</span>, // 启动服务器端口号<br>        open: <span class="hljs-literal">true</span> // 是否自动打开浏览器<br>    &#125;,<br>    mode:<span class="hljs-string">&quot;development&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>3.运行指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx webpack serve<br></code></pre></td></tr></table></figure><p><strong>注意运行指令发生了变化</strong></p><p>并且当你使用开发服务器时，所有代码都会在内存中编译打包，并不会输出到 dist 目录下。</p><p>开发时我们只关心代码能运行，有效果即可，至于代码被编译成什么样子，我们并不需要知道。</p>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>打包工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>打包工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB</title>
    <link href="/2023/04/01/MongoDB/"/>
    <url>/2023/04/01/MongoDB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-MongoDB-相关概念"><a href="#1-MongoDB-相关概念" class="headerlink" title="*1.MongoDB 相关概念"></a>*1.MongoDB 相关概念</h1><h2 id="1-1-业务场景"><a href="#1-1-业务场景" class="headerlink" title="1.1 业务场景"></a>1.1 业务场景</h2><p>传统的关系型数据库 (比如 MySQL), 在数据操作的”三高”需求以及对应的 Web 2.0 网站需求面前, 会有”力不从心”的感觉</p><p>所谓的三高需求:</p><p><strong>高并发, 高性能, 高可用</strong>, 简称三高</p><ul><li>High Performance: 对数据库的高并发读写的要求</li><li>High Storage: 对海量数据的高效率存储和访问的需求</li><li>High Scalability &amp;&amp; High Available: 对数据的高扩展性和高可用性的需求</li></ul><p><strong>而 MongoDB 可以应对三高需求</strong></p><p>具体的应用场景:</p><ul><li>社交场景, 使用 MongoDB 存储存储用户信息, 以及用户发表的朋友圈信息, 通过地理位置索引实现附近的人, 地点等功能.</li><li>游戏场景, 使用 MongoDB 存储游戏用户信息, 用户的装备, 积分等直接以内嵌文档的形式存储, 方便查询, 高效率存储和访问.</li><li>物流场景, 使用 MongoDB 存储订单信息, 订单状态在运送过程中会不断更新, 以 MongoDB 内嵌数组的形式来存储, 一次查询就能将订单所有的变更读取出来.</li><li>物联网场景, 使用 MongoDB 存储所有接入的智能设备信息, 以及设备汇报的日志信息, 并对这些信息进行多维度的分析.</li><li>视频直播, 使用 MongoDB 存储用户信息, 点赞互动信息等.</li></ul><p>这些应用场景中, 数据操作方面的共同点有: </p><ol><li>数据量大</li><li>写入操作频繁</li><li>价值较低的数据, 对<strong>事务性</strong>要求不高</li></ol><p>对于这样的数据, 更适合用 MongoDB 来实现数据存储</p><p>那么我们<strong>什么时候选择 MongoDB 呢?</strong></p><p>除了架构选型上, 除了上述三个特点之外, 还要考虑下面这些问题:</p><ul><li>应用不需要事务及复杂 JOIN 支持</li><li>新应用, 需求会变, 数据模型无法确定, 想快速迭代开发</li><li>应用需要 2000 - 3000 以上的读写QPS（更高也可以）</li><li>应用发展迅速, 需要能快速水平扩展</li><li>应用要求存储的数据不丢失</li><li>应用需要 <code>99.999%</code> 高可用</li><li>应用需要大量的地理位置查询, 文本查询</li></ul><p>如果上述有1个符合, 可以考虑 MongoDB, 2个及以上的符合, 选择 MongoDB 绝不会后悔.</p><blockquote><p>如果用MySQL呢?</p><p>相对MySQL, 可以以更低的成本解决问题（包括学习, 开发, 运维等成本）</p></blockquote><h2 id="1-2-MongoDB-简介"><a href="#1-2-MongoDB-简介" class="headerlink" title="1.2 MongoDB 简介"></a>1.2 MongoDB 简介</h2><blockquote><p>MongoDB是一个开源, 高性能, 无模式的文档型数据库, 当初的设计就是用于简化开发和方便扩展, 是NoSQL数据库产品中的一种.是最 像关系型数据库（MySQL）的非关系型数据库. 它支持的数据结构非常松散, 是一种类似于 JSON 的 格式叫BSON, 所以它既可以存储比较复杂的数据类型, 又相当的灵活. MongoDB中的记录是一个文档, 它是一个由字段和值对（ﬁeld:value）组成的数据结构.MongoDB文档类似于JSON对象, 即一个文档认 为就是一个对象.字段的数据类型是字符型, 它的值除了使用基本的一些类型外, 还可以包括其他文档, 普通数组和文档数组.</p></blockquote><h2 id="1-3-体系结构"><a href="#1-3-体系结构" class="headerlink" title="1.3 体系结构"></a>1.3 体系结构</h2><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230427221158812.png" alt="image-20230427221158812"></p><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230427221228362.png" alt="image-20230427221228362"></p><h2 id="1-4-数据模型"><a href="#1-4-数据模型" class="headerlink" title="1.4 数据模型"></a>1.4 数据模型</h2><p>MongoDB的最小存储单位就是文档(document)对象。文档(document)对象对应于关系型数据库的行。数据在MongoDB中以</p><p>BSON（Binary-JSON）文档的格式存储在磁盘上。</p><p>BSON（Binary Serialized Document Format）是一种类json的一种二进制形式的存储格式，简称Binary JSON。BSON和JSON一样，支持</p><p>内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，如Date和BinData类型。</p><p>BSON采用了类似于 C 语言结构体的名称、对表示方法，支持内嵌的文档对象和数组对象，具有轻量性、可遍历性、高效性的三个特点，可</p><p>以有效描述非结构化数据和结构化数据。这种格式的优点是灵活性高，但它的缺点是空间利用率不是很理想。</p><p>Bson中，除了基本的JSON类型：string,integer,boolean,double,null,array和object，mongo还使用了特殊的数据类型。这些类型包括</p><p>date,object id,binary data,regular expression 和code。每一个驱动都以特定语言的方式实现了这些类型，查看你的驱动的文档来获取详</p><p>细信息。</p><p>BSON数据类型参考列表：</p><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230427221303717.png" alt="image-20230427221303717"></p><p>提示：</p><p>shell默认使用64位浮点型数值。{“x”：3.14}或{“x”：3}。对于整型值，可以使用NumberInt（4字节符号整数）或NumberLong（8字节符</p><p>号整数），{“x”:NumberInt(“3”)}{“x”:NumberLong(“3”)}</p><h2 id="1-5-MongoDB的特点"><a href="#1-5-MongoDB的特点" class="headerlink" title="1.5 MongoDB的特点"></a>1.5 MongoDB的特点</h2><p>高性能、高可用性、高扩展性、丰富的查询支持</p><h1 id="2-单机部署"><a href="#2-单机部署" class="headerlink" title="2.单机部署"></a>2.单机部署</h1><h2 id="2-1-Windows系统中的安装启动"><a href="#2-1-Windows系统中的安装启动" class="headerlink" title="2.1 Windows系统中的安装启动"></a>2.1 Windows系统中的安装启动</h2><h3 id="第一步：下载安装包"><a href="#第一步：下载安装包" class="headerlink" title="第一步：下载安装包"></a>第一步：下载安装包</h3><p>MongoDB 提供了可用于 32 位和 64 位系统的预编译二进制包，你可以从MongoDB官网下载安装，MongoDB 预编译二进制包下载地址：<a href="https://www.mongodb.com/try/download/communit">https://www.mongodb.com/try/download/communit</a>  </p><p>或直接从网盘获取</p><h3 id="第二步：解压安装启动服务"><a href="#第二步：解压安装启动服务" class="headerlink" title="第二步：解压安装启动服务"></a>第二步：解压安装启动服务</h3><p>在解压目录中bin同级目录下，手动建立一个目录用于存放数据文件，如 data&#x2F;db</p><h4 id="方式1：命令行参数方式启动服务（平时采用）"><a href="#方式1：命令行参数方式启动服务（平时采用）" class="headerlink" title="方式1：命令行参数方式启动服务（平时采用）"></a>方式1：命令行参数方式启动服务（平时采用）</h4><p>在 bin 目录中打开cmd，输入如下命令：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">mongod <span class="hljs-params">--dbpath=</span><span class="hljs-string">..</span>\data\db<br></code></pre></td></tr></table></figure><p>我们在启动信息中可以看到，mongoDB的默认端口是<strong>27017</strong>，如果我们想改变默认的启动端口，可以通过–port来指定端口。</p><p>为了方便我们每次启动，可以将安装目录的bin目录设置到环境变量的path中， bin 目录下是一些常用命令，比如 mongod 启动服务用的，</p><p>mongo 客户端连接服务用的。</p><h4 id="方式2：配置文件方式启动服务-部署时采用）"><a href="#方式2：配置文件方式启动服务-部署时采用）" class="headerlink" title="方式2：配置文件方式启动服务(部署时采用）"></a>方式2：配置文件方式启动服务(部署时采用）</h4><p>在解压目录bin同级目录新建 config 文件夹，该文件夹中新建配置文件 mongod.conf ，参考如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">storage:</span><br>  <span class="hljs-comment">#The directory where the mongod instance stores its data.Default Value is &quot;\data\db&quot; on Windows.</span><br>  <span class="hljs-attr">dbPath:</span> <span class="hljs-string">D:\02_Server\DBServer\mongodb-win32-x86_64-2008plus-ssl-4.0.1\data</span><br></code></pre></td></tr></table></figure><blockquote><p>dbPath是自己建的数据文件的具体位置</p></blockquote><p>启动方式在bin目录下打开cmd</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">mongod -f ..<span class="hljs-regexp">/conf/m</span>ongod.conf<br>或<br>mongod --config ..<span class="hljs-regexp">/conf/m</span>ongod.conf<br></code></pre></td></tr></table></figure><p>更多参数配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">systemLog:</span><br>    <span class="hljs-attr">destination:</span> <span class="hljs-string">file</span><br>    <span class="hljs-comment">#The path of the log file to which mongod or mongos should send all diagnostic logging information</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;D:/02_Server/DBServer/mongodb-win32-x86_64-2008plus-ssl-4.0.1/log/mongod.log&quot;</span><br>    <span class="hljs-attr">logAppend:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">storage:</span><br>    <span class="hljs-attr">journal:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment">#The directory where the mongod instance stores its data.Default Value is &quot;/data/db&quot;.</span><br>    <span class="hljs-attr">dbPath:</span> <span class="hljs-string">&quot;D:/02_Server/DBServer/mongodb-win32-x86_64-2008plus-ssl-4.0.1/data&quot;</span><br><span class="hljs-attr">net:</span><br>    <span class="hljs-comment">#bindIp: 127.0.0.1</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">27017</span><br><span class="hljs-attr">setParameter:</span><br>    <span class="hljs-attr">enableLocalhostAuthBypass:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h2 id="2-2-Shell连接-mongo命令"><a href="#2-2-Shell连接-mongo命令" class="headerlink" title="2.2 Shell连接(mongo命令)"></a>2.2 Shell连接(mongo命令)</h2><p>在命令提示符输入以下shell命令即可完成登陆</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">mongo<br>或<br>mongo <span class="hljs-attribute">--host</span>=127.0.0.1 <span class="hljs-attribute">--port</span>=27017<br></code></pre></td></tr></table></figure><p>查看已经有的数据库</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">&gt;<span class="hljs-keyword">show</span> databases<br></code></pre></td></tr></table></figure><p>退出mongodb</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure><p>更多参数可以通过帮助查看：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">mongo <span class="hljs-comment">--help</span><br></code></pre></td></tr></table></figure><p>提示：</p><p>MongoDB javascript shell是一个基于javascript的解释器，故是支持js程序的。</p><h2 id="2-3-Compass-图形化界面客户端"><a href="#2-3-Compass-图形化界面客户端" class="headerlink" title="2.3 Compass-图形化界面客户端"></a>2.3 Compass-图形化界面客户端</h2><p>到MongoDB官网下载MongoDB Compass，</p><p>地址：<a href="https://www.mongodb.com/download-center/v2/compass?initial=true">https://www.mongodb.com/download-center/v2/compass?initial=true</a></p><p>或直接从网盘获取</p><p>执行里面的 MongoDBCompassCommunity.exe 文件即可。</p><h2 id="2-4-Linux系统中的安装启动和连接"><a href="#2-4-Linux系统中的安装启动和连接" class="headerlink" title="2.4 Linux系统中的安装启动和连接"></a>2.4 Linux系统中的安装启动和连接</h2><p>目标：在Linux中部署一个单机的MongoDB，作为生产环境下使用。</p><p>提示：和Windows下操作差不多。</p><p>步骤如下：</p><p>（1）先到官网下载压缩包 mongod-linux-x86_64-4.0.10.tgz 。</p><p>（2）上传压缩包到Linux中，解压到当前目录：</p><figure class="highlight plaintext"><figcaption><span>-xvf mongodb-linux-x86_64-4.0.10.tgz</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tar">tar -xvf mongodb-linux-x86_64-4.0.10.tgz<br></code></pre></td></tr></table></figure><p>（3）移动解压后的文件夹到指定的目录中：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mv</span> mongodb-linux-x86_64-<span class="hljs-number">4</span>.<span class="hljs-number">0</span>.<span class="hljs-number">10</span> /usr/local/mongodb<br></code></pre></td></tr></table></figure><p>（4）新建几个目录，分别用来存储数据和日志：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#数据存储目录</span><br>mkdir -p <span class="hljs-regexp">/mongodb/</span>single<span class="hljs-regexp">/data/</span>db<br><span class="hljs-comment">#日志存储目录</span><br>mkdir -p <span class="hljs-regexp">/mongodb/</span>single/log<br></code></pre></td></tr></table></figure><p>（5）新建并修改配置文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vi <span class="hljs-regexp">/mongodb/</span>single/mongod.conf<br></code></pre></td></tr></table></figure><p>配置文件的内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">systemLog:</span><br>    <span class="hljs-comment">#MongoDB发送所有日志输出的目标指定为文件</span><br>    <span class="hljs-comment"># #The path of the log file to which mongod or mongos should send all diagnostic logging information</span><br>    <span class="hljs-attr">destination:</span> <span class="hljs-string">file</span><br>    <span class="hljs-comment">#mongod或mongos应向其发送所有诊断日志记录信息的日志文件的路径</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;/mongodb/single/log/mongod.log&quot;</span><br>    <span class="hljs-comment">#当mongos或mongod实例重新启动时，mongos或mongod会将新条目附加到现有日志文件的末尾。</span><br>    <span class="hljs-attr">logAppend:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">storage:</span><br>    <span class="hljs-comment">#mongod实例存储其数据的目录。storage.dbPath设置仅适用于mongod。</span><br>    <span class="hljs-comment">##The directory where the mongod instance stores its data.Default Value is &quot;/data/db&quot;.</span><br>    <span class="hljs-attr">dbPath:</span> <span class="hljs-string">&quot;/mongodb/single/data/db&quot;</span><br>    <span class="hljs-attr">journal:</span><br>    <span class="hljs-comment">#启用或禁用持久性日志以确保数据文件保持有效和可恢复。</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">processManagement:</span><br>    <span class="hljs-comment">#启用在后台运行mongos或mongod进程的守护进程模式。</span><br>    <span class="hljs-attr">fork:</span> <span class="hljs-literal">true</span>  <br><span class="hljs-attr">net:</span><br>    <span class="hljs-comment">#服务实例绑定的IP，默认是localhost</span><br>    <span class="hljs-attr">bindIp:</span> <span class="hljs-string">localhost,192.168.0.2</span><br>    <span class="hljs-comment">#bindIp</span><br>    <span class="hljs-comment">#绑定的端口，默认是27017</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">27017</span><br></code></pre></td></tr></table></figure><p>(6) 启动MongoDB服务</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[root@bobohost single]# <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/mongodb/</span>bin<span class="hljs-regexp">/mongod -f /m</span>ongodb<span class="hljs-regexp">/single/m</span>ongod.conf<br>about to fork child process, waiting until server is ready <span class="hljs-keyword">for</span> connections.<br>forked process: <span class="hljs-number">90384</span><br>child process started successfully, parent exiting<br></code></pre></td></tr></table></figure><p>注意：</p><p>如果启动后不是 successfully ，则是启动失败了。原因基本上就是配置文件有问题。</p><p>通过进程来查看服务是否启动了：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">[root@bobohost single]<span class="hljs-comment"># ps -ef |grep mongod</span><br>root <span class="hljs-number">90384</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">8</span>月<span class="hljs-number">26</span> ? <span class="hljs-number">00</span>:<span class="hljs-number">02</span>:<span class="hljs-number">13</span> <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/mongdb/</span>bin<span class="hljs-regexp">/mongod -f /m</span>ongodb<span class="hljs-regexp">/single/m</span>ongod.conf<br></code></pre></td></tr></table></figure><p>（7）分别使用mongo命令和compass工具来连接测试。</p><p>提示：如果远程连接不上，需要配置防火墙放行，或直接关闭linux防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">查看防火墙状态</span><br>systemctl status firewalld<br><span class="hljs-meta prompt_">#</span><span class="language-bash">临时关闭防火墙</span><br>systemctl stop firewalld<br><span class="hljs-meta prompt_">#</span><span class="language-bash">开机禁止启动防火墙</span><br>systemctl disable firewalld<br></code></pre></td></tr></table></figure><p>（8）停止关闭服务</p><p>停止服务的方式有两种：快速关闭和标准关闭，下面依次说明：</p><p>（一）快速关闭方法（快速，简单，数据可能会出错）</p><p>目标：通过系统的kill命令直接杀死进程：</p><p>杀完要检查一下，避免有的没有杀掉。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">通过进程编号关闭节点</span><br>kill -2 54410<br></code></pre></td></tr></table></figure><p>【补充】</p><p>如果一旦是因为数据损坏，则需要进行如下操作（了解）：</p><p>1）删除lock文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -f /mongodb/single/data/db/*.lock<br></code></pre></td></tr></table></figure><p>2）修复数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/usr/local/mongdb/bin/mongod --repair --dbpath=/mongodb/single/data/db<br></code></pre></td></tr></table></figure><p>（二）标准的关闭方法（数据不容易出错，但麻烦）：</p><p>目标：通过mongo客户端中的shutdownServer命令来关闭服务</p><p>主要的操作步骤参考如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">//客户端登录服务，注意，这里通过localhost登录，如果需要远程登录，必须先登录认证才行。<br>mongo --port 27017<br><span class="hljs-meta prompt_">//#</span><span class="language-bash">切换到admin库</span><br>use admin<br>//关闭服务<br>db.shutdownServer()<br></code></pre></td></tr></table></figure><h1 id="3-基本常用命令"><a href="#3-基本常用命令" class="headerlink" title="3 基本常用命令"></a>3 基本常用命令</h1><p>推荐参考：<a href="https://www.csdn.net/tags/OtTaIgzsOTQ1Ny1ibG9n.html">https://www.csdn.net/tags/OtTaIgzsOTQ1Ny1ibG9n.html</a></p><h2 id="3-1-案例需求"><a href="#3-1-案例需求" class="headerlink" title="3.1 案例需求"></a>3.1 案例需求</h2><p>存放文章评论的数据存放到MongoDB中，数据结构参考如下：</p><p>数据库：articledb</p><table><thead><tr><th><strong>专栏文章评论</strong></th><th><strong>comment</strong></th><th></th><th></th></tr></thead><tbody><tr><td>字段名称</td><td>字段含义</td><td>ObjectId或String</td><td>Mongo的主键的字段</td></tr><tr><td>_id</td><td>ID</td><td>ObjectId或String</td><td>Mongo的主键的字段</td></tr><tr><td>articleid</td><td>文章ID</td><td>String</td><td></td></tr><tr><td>content</td><td>评论内容</td><td>String</td><td></td></tr><tr><td>userid</td><td>评论人ID</td><td>String</td><td></td></tr><tr><td>nickname</td><td>评论人昵称</td><td>String</td><td></td></tr><tr><td>createdatetime</td><td>评论的日期时间</td><td>Date</td><td></td></tr><tr><td>likenum</td><td>点赞数</td><td>Int32</td><td></td></tr><tr><td>replynum</td><td>回复数</td><td>Int32</td><td></td></tr><tr><td>state</td><td>状态</td><td>String</td><td>0：不可见；1：可见；</td></tr><tr><td>parentid</td><td>上级ID</td><td>String</td><td>如果为0表示文章的顶级评论</td></tr></tbody></table><h2 id="3-2-数据库操作"><a href="#3-2-数据库操作" class="headerlink" title="3.2 数据库操作"></a>3.2 数据库操作</h2><h3 id="3-2-1-选择和创建数据库"><a href="#3-2-1-选择和创建数据库" class="headerlink" title="3.2.1 选择和创建数据库"></a>3.2.1 选择和创建数据库</h3><p>选择和创建数据库的语法格式：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">use</span> 数据库名称<br></code></pre></td></tr></table></figure><p>如果数据库不存在则自动创建，例如，以下语句创建 spitdb 数据库：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">use</span> articledb<br></code></pre></td></tr></table></figure><p>查看有权限查看的所有的数据库命令</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">show</span> dbs<br>或<br><span class="hljs-keyword">show</span> databases<br></code></pre></td></tr></table></figure><blockquote><p>注意 在 MongoDB 中，集合只有在内容插入后才会创建! 就是说，创建集合(数据表)后要再插入一个文档(记录)，集合才会真正创建。</p></blockquote><h4 id="查看当前正在使用的数据库命令"><a href="#查看当前正在使用的数据库命令" class="headerlink" title="查看当前正在使用的数据库命令"></a>查看当前正在使用的数据库命令</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">db</span><br></code></pre></td></tr></table></figure><p>MongoDB 中默认的数据库为 test，如果你没有选择数据库，集合将存放在 test 数据库中。</p><p>另外：</p><p>数据库名可以是满足以下条件的任意UTF-8字符串。</p><ul><li>不能是空字符串（””)。</li><li>不得含有’ ‘（空格)、.、$、&#x2F;、\和\0 (空字符)。</li><li>应全部小写。</li><li>最多64字节。</li></ul><p>有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。</p><p><strong>admin</strong>： 从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特</p><p>定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</p><p><strong>local:</strong> 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</p><p><strong>confifig</strong>: 当Mongo用于分片设置时，confifig数据库在内部使用，用于保存分片的相关信息。</p><h3 id="3-2-2-数据库的删除"><a href="#3-2-2-数据库的删除" class="headerlink" title="3.2.2 数据库的删除"></a>3.2.2 数据库的删除</h3><p>MongoDB 删除数据库的语法格式如下：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">db.dropDatabase<span class="hljs-comment">()</span><br></code></pre></td></tr></table></figure><p>提示：主要用来删除已经持久化的数据库</p><h2 id="3-3-集合操作"><a href="#3-3-集合操作" class="headerlink" title="3.3 集合操作"></a>3.3 集合操作</h2><p>集合，类似关系型数据库中的表。</p><p>可以显示的创建，也可以隐式的创建.</p><p>MongoDB 中默认的数据库为 test，如果你没有创建新的数据库，集合将存放在 test 数据库中。</p><h3 id="3-3-1-集合的显式创建（了解）"><a href="#3-3-1-集合的显式创建（了解）" class="headerlink" title="3.3.1 集合的显式创建（了解）"></a>3.3.1 集合的显式创建（了解）</h3><p>基本语法格式：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">db.create<span class="hljs-constructor">Collection(<span class="hljs-params">name</span>)</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><p>name: 要创建的集合名称</p><p>例如：创建一个名为 mycollection 的普通集合。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">db.create<span class="hljs-constructor">Collection(<span class="hljs-string">&quot;mycollection&quot;</span>)</span><br></code></pre></td></tr></table></figure><p>查看当前数据库中的表：show tables命令</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> collections<br>或<br><span class="hljs-keyword">show</span> <span class="hljs-keyword">tables</span><br></code></pre></td></tr></table></figure><p>集合的命名规范：</p><p>集合名不能是空字符串””。</p><p>集合名不能含有\0字符（空字符)，这个字符表示集合名的结尾。</p><p>集合名不能以”system.”开头，这是为系统集合保留的前缀。</p><p>用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除</p><p>非你要访问这种系统创建的集合，否则千万不要在名字里出现$。</p><h3 id="3-3-2-集合的隐式创建"><a href="#3-3-2-集合的隐式创建" class="headerlink" title="3.3.2 集合的隐式创建"></a>3.3.2 集合的隐式创建</h3><p>当向一个集合中插入一个文档的时候，如果集合不存在，则会自动创建集合。</p><p>详见 文档的插入 章节。</p><p>提示：通常我们使用隐式创建文档即可。</p><h3 id="3-3-3-集合的删除"><a href="#3-3-3-集合的删除" class="headerlink" title="3.3.3 集合的删除"></a>3.3.3 集合的删除</h3><p>集合删除语法格式如下：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">db</span>.collection.<span class="hljs-keyword">drop</span>()<br>或<br><span class="hljs-keyword">db</span>.集合.<span class="hljs-keyword">drop</span>()<br></code></pre></td></tr></table></figure><p><strong>返回值</strong></p><p>如果成功删除选定集合，则 drop() 方法返回 true，否则返回 false。</p><p>例如：要删除mycollection集合</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">db</span>.mycollection.<span class="hljs-keyword">drop</span>()<br></code></pre></td></tr></table></figure><h2 id="3-4-文档基本CRUD"><a href="#3-4-文档基本CRUD" class="headerlink" title="3.4 文档基本CRUD"></a>3.4 文档基本CRUD</h2><p>文档（document）的数据结构和 JSON 基本一样。</p><p>所有存储在集合中的数据都是 BSON 格式。</p><h3 id="3-4-1-文档的插入"><a href="#3-4-1-文档的插入" class="headerlink" title="3.4.1 文档的插入"></a>3.4.1 文档的插入</h3><h4 id="（1）单个文档插入"><a href="#（1）单个文档插入" class="headerlink" title="（1）单个文档插入"></a>（1）单个文档插入</h4><p>使用insert() 或 save() 方法向集合中插入文档，语法如下：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xquery">db<span class="hljs-built_in">.collection</span>.<span class="hljs-keyword">insert</span>(<br>    &lt;<span class="hljs-keyword">document</span> or array of documents&gt;,<br>    &#123;<br>        writeConcern: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">document</span>&gt;</span>,</span><br><span class="language-xml">        ordered: </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">boolean</span>&gt;</span></span><br><span class="language-xml">    &#125;</span><br><span class="language-xml">)</span><br></code></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th><strong>Parameter</strong></th><th><strong>Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>document</td><td>document or array</td><td>要插入到集合中的文档或文档数组。（(json格式）</td></tr><tr><td>writeConcern</td><td>document</td><td>Optional. A document expressing the write concern. Omit to use the default write concern. See Write Concern.Do not explicitly set the write concern for the operation if run in a transaction. To use write concern with transactions, see Transactions and Write Concern.</td></tr><tr><td>ordered</td><td>boolean</td><td>可选。如果为真，则按顺序插入数组中的文档，如果其中一个文档出现错误，MongoDB将返回而</td></tr></tbody></table><p>【示例】</p><p>要向comment的集合(表)中插入一条测试数据： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.insert(&#123;&quot;articleid&quot;:&quot;100000&quot;,&quot;content&quot;:&quot;今天天气真好，阳光明媚&quot;,&quot;userid&quot;:&quot;1001&quot;,&quot;nickname&quot;:&quot;Rose&quot;,<br>&quot;createdatetime&quot;:new Date(),&quot;likenum&quot;:NumberInt(10),&quot;state&quot;:null&#125;)<br></code></pre></td></tr></table></figure><p>提示：</p><p>1）comment集合如果不存在，则会隐式创建</p><p>2）mongo中的数字，默认情况下是double类型，如果要存整型，必须使用函数NumberInt(整型数字)，否则取出来就有问题了。</p><p>3）插入当前日期使用 new Date()</p><p>4）插入的数据没有指定 _id ，会自动生成主键值</p><p>5）如果某字段没值，可以赋值为null，或不写该字段。</p><p>执行后，如下，说明插入一个数据成功了。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">WriteResult</span><span class="hljs-params">(&#123; <span class="hljs-string">&quot;nInserted&quot;</span> : <span class="hljs-number">1</span> &#125;)</span></span><br></code></pre></td></tr></table></figure><p>注意：</p><ol><li><p>文档中的键&#x2F;值对是有序的。</p></li><li><p>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。</p></li><li><p>MongoDB区分类型和大小写。</p></li><li><p>MongoDB的文档不能有重复的键。</p></li><li><p>文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。</p></li></ol><p>文档键命名规范：</p><ul><li>键不能含有\0 (空字符)。这个字符用来表示键的结尾。</li><li>.和$有特别的意义，只有在特定环境下才能使用。</li><li>以下划线”_”开头的键是保留的(不是严格要求的)。</li></ul><h4 id="（2）批量插入"><a href="#（2）批量插入" class="headerlink" title="（2）批量插入"></a>（2）批量插入</h4><p>语法：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pf">db.collection.insertM<span class="hljs-literal">any</span>(<br>    [ <span class="hljs-variable">&lt;document 1&gt;</span> , <span class="hljs-variable">&lt;document 2&gt;</span>, ... ],<br>        &#123;<br>            writeConcern: <span class="hljs-variable">&lt;document&gt;</span>,<br>            ordered: <span class="hljs-variable">&lt;boolean&gt;</span><br>        &#125;<br>)<br></code></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th><strong>Parameter</strong></th><th><strong>Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>document</td><td>document or array</td><td>要插入到集合中的文档或文档数组。（(json格式）</td></tr><tr><td>writeConcern</td><td>document</td><td>Optional. A document expressing the write concern. Omit to use the default write concern. See Write Concern.Do not explicitly set the write concern for the operation if run in a transaction. To use write concern with transactions, see Transactions and Write Concern.</td></tr><tr><td>ordered</td><td>boolean</td><td>可选。如果为真，则按顺序插入数组中的文档，如果其中一个文档出现错误，MongoDB将返回而</td></tr></tbody></table><p>【示例】</p><p>批量插入多条文章评论：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">db.<span class="hljs-property">comment</span>.<span class="hljs-title function_">insertMany</span>([<br>   &#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;articleid&quot;</span>:<span class="hljs-string">&quot;100001&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;我们不应该把清晨浪费在手机上，健康很重要，一杯温水幸福你我</span><br><span class="hljs-string">他。&quot;</span>,<span class="hljs-string">&quot;userid&quot;</span>:<span class="hljs-string">&quot;1002&quot;</span>,<span class="hljs-string">&quot;nickname&quot;</span>:<span class="hljs-string">&quot;相忘于江湖&quot;</span>,<span class="hljs-string">&quot;createdatetime&quot;</span>:<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;2019-08-</span><br><span class="hljs-string">05T22:08:15.522Z&quot;</span>),<span class="hljs-string">&quot;likenum&quot;</span>:<span class="hljs-title class_">NumberInt</span>(<span class="hljs-number">1000</span>),<span class="hljs-string">&quot;state&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>&#125;,<br>   &#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;articleid&quot;</span>:<span class="hljs-string">&quot;100001&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;我夏天空腹喝凉开水，冬天喝温开水&quot;</span>,<span class="hljs-string">&quot;userid&quot;</span>:<span class="hljs-string">&quot;1005&quot;</span>,<span class="hljs-string">&quot;nickname&quot;</span>:<span class="hljs-string">&quot;伊人憔</span><br><span class="hljs-string">悴&quot;</span>,<span class="hljs-string">&quot;createdatetime&quot;</span>:<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;2019-08-05T23:58:51.485Z&quot;</span>),<span class="hljs-string">&quot;likenum&quot;</span>:<span class="hljs-title class_">NumberInt</span>(<span class="hljs-number">888</span>),<span class="hljs-string">&quot;state&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>&#125;,<br>   &#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;articleid&quot;</span>:<span class="hljs-string">&quot;100001&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;我一直喝凉开水，冬天夏天都喝。&quot;</span>,<span class="hljs-string">&quot;userid&quot;</span>:<span class="hljs-string">&quot;1004&quot;</span>,<span class="hljs-string">&quot;nickname&quot;</span>:<span class="hljs-string">&quot;杰克船</span><br><span class="hljs-string">长&quot;</span>,<span class="hljs-string">&quot;createdatetime&quot;</span>:<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;2019-08-06T01:05:06.321Z&quot;</span>),<span class="hljs-string">&quot;likenum&quot;</span>:<span class="hljs-title class_">NumberInt</span>(<span class="hljs-number">666</span>),<span class="hljs-string">&quot;state&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>&#125;,<br>   &#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;articleid&quot;</span>:<span class="hljs-string">&quot;100001&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;专家说不能空腹吃饭，影响健康。&quot;</span>,<span class="hljs-string">&quot;userid&quot;</span>:<span class="hljs-string">&quot;1003&quot;</span>,<span class="hljs-string">&quot;nickname&quot;</span>:<span class="hljs-string">&quot;凯</span><br><span class="hljs-string">撒&quot;</span>,<span class="hljs-string">&quot;createdatetime&quot;</span>:<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;2019-08-06T08:18:35.288Z&quot;</span>),<span class="hljs-string">&quot;likenum&quot;</span>:<span class="hljs-title class_">NumberInt</span>(<span class="hljs-number">2000</span>),<span class="hljs-string">&quot;state&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>&#125;,<br>   &#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;articleid&quot;</span>:<span class="hljs-string">&quot;100001&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;研究表明，刚烧开的水千万不能喝，因为烫</span><br><span class="hljs-string">嘴。&quot;</span>,<span class="hljs-string">&quot;userid&quot;</span>:<span class="hljs-string">&quot;1003&quot;</span>,<span class="hljs-string">&quot;nickname&quot;</span>:<span class="hljs-string">&quot;凯撒&quot;</span>,<span class="hljs-string">&quot;createdatetime&quot;</span>:<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;2019-08-</span><br><span class="hljs-string">06T11:01:02.521Z&quot;</span>),<span class="hljs-string">&quot;likenum&quot;</span>:<span class="hljs-title class_">NumberInt</span>(<span class="hljs-number">3000</span>),<span class="hljs-string">&quot;state&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>&#125;<br>]);<br></code></pre></td></tr></table></figure><p>提示：</p><p>插入时指定了 _id ，则主键就是该值。</p><p>如果某条数据插入失败，将会终止插入，但已经插入成功的数据不会回滚掉。</p><p>因为批量插入由于数据较多容易出现失败，因此，可以使用try catch进行异常捕捉处理，测试的时候可以不处理。如（了解）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">try</span> &#123;<br>    db.<span class="hljs-property">comment</span>.<span class="hljs-title function_">insertMany</span>([<br>        &#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;articleid&quot;</span>:<span class="hljs-string">&quot;100001&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;我们不应该把清晨浪费在手机上，健康很重要，一杯温水幸福你我</span><br><span class="hljs-string">    他。&quot;</span>,<span class="hljs-string">&quot;userid&quot;</span>:<span class="hljs-string">&quot;1002&quot;</span>,<span class="hljs-string">&quot;nickname&quot;</span>:<span class="hljs-string">&quot;相忘于江湖&quot;</span>,<span class="hljs-string">&quot;createdatetime&quot;</span>:<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;2019-08-</span><br><span class="hljs-string">    05T22:08:15.522Z&quot;</span>),<span class="hljs-string">&quot;likenum&quot;</span>:<span class="hljs-title class_">NumberInt</span>(<span class="hljs-number">1000</span>),<span class="hljs-string">&quot;state&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;articleid&quot;</span>:<span class="hljs-string">&quot;100001&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;我夏天空腹喝凉开水，冬天喝温开水&quot;</span>,<span class="hljs-string">&quot;userid&quot;</span>:<span class="hljs-string">&quot;1005&quot;</span>,<span class="hljs-string">&quot;nickname&quot;</span>:<span class="hljs-string">&quot;伊人憔</span><br><span class="hljs-string">    悴&quot;</span>,<span class="hljs-string">&quot;createdatetime&quot;</span>:<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;2019-08-05T23:58:51.485Z&quot;</span>),<span class="hljs-string">&quot;likenum&quot;</span>:<span class="hljs-title class_">NumberInt</span>(<span class="hljs-number">888</span>),<span class="hljs-string">&quot;state&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;articleid&quot;</span>:<span class="hljs-string">&quot;100001&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;我一直喝凉开水，冬天夏天都喝。&quot;</span>,<span class="hljs-string">&quot;userid&quot;</span>:<span class="hljs-string">&quot;1004&quot;</span>,<span class="hljs-string">&quot;nickname&quot;</span>:<span class="hljs-string">&quot;杰克船</span><br><span class="hljs-string">    长&quot;</span>,<span class="hljs-string">&quot;createdatetime&quot;</span>:<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;2019-08-06T01:05:06.321Z&quot;</span>),<span class="hljs-string">&quot;likenum&quot;</span>:<span class="hljs-title class_">NumberInt</span>(<span class="hljs-number">666</span>),<span class="hljs-string">&quot;state&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;articleid&quot;</span>:<span class="hljs-string">&quot;100001&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;专家说不能空腹吃饭，影响健康。&quot;</span>,<span class="hljs-string">&quot;userid&quot;</span>:<span class="hljs-string">&quot;1003&quot;</span>,<span class="hljs-string">&quot;nickname&quot;</span>:<span class="hljs-string">&quot;凯</span><br><span class="hljs-string">    撒&quot;</span>,<span class="hljs-string">&quot;createdatetime&quot;</span>:<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;2019-08-06T08:18:35.288Z&quot;</span>),<span class="hljs-string">&quot;likenum&quot;</span>:<span class="hljs-title class_">NumberInt</span>(<span class="hljs-number">2000</span>),<span class="hljs-string">&quot;state&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;articleid&quot;</span>:<span class="hljs-string">&quot;100001&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;研究表明，刚烧开的水千万不能喝，因为烫</span><br><span class="hljs-string">    嘴。&quot;</span>,<span class="hljs-string">&quot;userid&quot;</span>:<span class="hljs-string">&quot;1003&quot;</span>,<span class="hljs-string">&quot;nickname&quot;</span>:<span class="hljs-string">&quot;凯撒&quot;</span>,<span class="hljs-string">&quot;createdatetime&quot;</span>:<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;2019-08-</span><br><span class="hljs-string">    06T11:01:02.521Z&quot;</span>),<span class="hljs-string">&quot;likenum&quot;</span>:<span class="hljs-title class_">NumberInt</span>(<span class="hljs-number">3000</span>),<span class="hljs-string">&quot;state&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>&#125;<br>    ]);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (e) &#123;<br>        print (e);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-2-文档的基本查询"><a href="#3-4-2-文档的基本查询" class="headerlink" title="3.4.2 文档的基本查询"></a>3.4.2 文档的基本查询</h3><p> 查询数据的语法格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">db.<span class="hljs-property">collection</span>.<span class="hljs-title function_">find</span>(&lt;query&gt;, [projection])<br></code></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th><strong>Parameter</strong></th><th><strong>Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>query</td><td>document</td><td>可选。使用查询运算符指定选择筛选器。若要返回集合中的所有文档，请省略此参数或传递空文档( {} )。</td></tr><tr><td>projection</td><td>document</td><td>可选。指定要在与查询筛选器匹配的文档中返回的字段（投影）。若要返回匹配文档中的所有字段，</td></tr></tbody></table><p>【示例】</p><p>（1）查询所有</p><p>如果我们要查询comment集合的所有文档，我们输入以下命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">db.<span class="hljs-property">comment</span>.<span class="hljs-title function_">find</span>()<br>或<br>db.<span class="hljs-property">comment</span>.<span class="hljs-title function_">find</span>(&#123;&#125;)<br></code></pre></td></tr></table></figure><p>这里你会发现每条文档会有一个叫_id的字段，这个相当于我们原来关系数据库中表的主键，当你在插入文档记录时没有指定该字段，</p><p>MongoDB会自动创建，其类型是ObjectID类型。 </p><p>如果我们在插入文档记录时指定该字段也可以，其类型可以是ObjectID类型，也可以是MongoDB支持的任意类型。</p><p>如果我想按一定条件来查询，比如我想查询userid为1003的记录，怎么办？很简单！只 要在fifind()中添加参数即可，参数也是json格式，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">db.<span class="hljs-property">comment</span>.<span class="hljs-title function_">find</span>(&#123;<span class="hljs-attr">userid</span>:<span class="hljs-string">&#x27;1003&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><p>如果你只需要返回符合条件的第一条数据，我们可以使用fifindOne命令来实现，语法和fifind一样。</p><p>如：查询用户编号是1003的记录，但只最多返回符合条件的第一条记录：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">db.<span class="hljs-property">comment</span>.<span class="hljs-title function_">findOne</span>(&#123;<span class="hljs-attr">userid</span>:<span class="hljs-string">&#x27;1003&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><p>（2）投影查询（Projection Query）：</p><p>如果要查询结果返回部分字段，则需要使用投影查询（不显示所有字段，只显示指定的字段）。</p><p>如：查询结果只显示 _id、userid、nickname : </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&gt;db.<span class="hljs-property">comment</span>.<span class="hljs-title function_">find</span>(<span class="hljs-params">&#123;userid:<span class="hljs-string">&quot;1003&quot;</span>&#125;,&#123;userid:<span class="hljs-number">1</span>,nickname:<span class="hljs-number">1</span>&#125;</span>)<br>&#123; <span class="hljs-string">&quot;_id&quot;</span> : <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;userid&quot;</span> : <span class="hljs-string">&quot;1003&quot;</span>, <span class="hljs-string">&quot;nickname&quot;</span> : <span class="hljs-string">&quot;凯撒&quot;</span> &#125;<br>&#123; <span class="hljs-string">&quot;_id&quot;</span> : <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;userid&quot;</span> : <span class="hljs-string">&quot;1003&quot;</span>, <span class="hljs-string">&quot;nickname&quot;</span> : <span class="hljs-string">&quot;凯撒&quot;</span> &#125;<br></code></pre></td></tr></table></figure><p>默认 _id 会显示。</p><p>如：查询结果只显示 、userid、nickname ，不显示 _id ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&gt;db.<span class="hljs-property">comment</span>.<span class="hljs-title function_">find</span>(<span class="hljs-params">&#123;userid:<span class="hljs-string">&quot;1003&quot;</span>&#125;,&#123;userid:<span class="hljs-number">1</span>,nickname:<span class="hljs-number">1</span>,_id:<span class="hljs-number">0</span>&#125;</span>)<br>&#123; <span class="hljs-string">&quot;userid&quot;</span> : <span class="hljs-string">&quot;1003&quot;</span>, <span class="hljs-string">&quot;nickname&quot;</span> : <span class="hljs-string">&quot;凯撒&quot;</span> &#125;<br>&#123; <span class="hljs-string">&quot;userid&quot;</span> : <span class="hljs-string">&quot;1003&quot;</span>, <span class="hljs-string">&quot;nickname&quot;</span> : <span class="hljs-string">&quot;凯撒&quot;</span> &#125;<br></code></pre></td></tr></table></figure><p>再例如：查询所有数据，但只显示 _id、userid、nickname :</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">&gt;db.comment.find(</span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml">,</span><span class="hljs-template-variable">&#123;userid:1,nickname:1&#125;</span><span class="language-xml">)</span><br></code></pre></td></tr></table></figure><h3 id="3-4-3-文档的更新"><a href="#3-4-3-文档的更新" class="headerlink" title="3.4.3 文档的更新"></a>3.4.3 文档的更新</h3><p>更新文档的语法：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vim">db.collection.<span class="hljs-keyword">update</span>(query, <span class="hljs-keyword">update</span>, <span class="hljs-keyword">options</span>)<br>//或<br>db.collection.<span class="hljs-keyword">update</span>(<br>    <span class="hljs-symbol">&lt;query&gt;</span>,<br>    <span class="hljs-symbol">&lt;update&gt;</span>,<br>    &#123;<br>        upsert: <span class="hljs-symbol">&lt;boolean&gt;</span>,<br>        multi: <span class="hljs-symbol">&lt;boolean&gt;</span>,<br>        writeConcern: <span class="hljs-symbol">&lt;document&gt;</span>,<br>        collation: <span class="hljs-symbol">&lt;document&gt;</span>,<br>        arrayFilters: [ <span class="hljs-symbol">&lt;filterdocument1&gt;</span>, ... ],<br>        hint: &lt;document|<span class="hljs-built_in">string</span>&gt; // Available starting in MongoDB <span class="hljs-number">4.2</span><br>&#125;<br>)<br></code></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th><strong>Parameter</strong></th><th><strong>Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>query</td><td>document</td><td>更新的选择条件。可以使用与find（）方法中相同的查询选择器，类似sql update查询内where后面的。</td></tr><tr><td>update</td><td>document<br>or<br>pipeline</td><td>要应用的修改。该值可以是：包含更新运算符表达式的文档，或仅包含：对的替换文档，或在MongoDB 4.2中启动聚合管道</td></tr><tr><td>upsert</td><td>boolean</td><td>可选。如果设置为true，则在没有与查询条件匹配的文档时创建新文档。默认值为false，如果找不到匹配项，则不会插入新文档。</td></tr><tr><td>multi</td><td>boolean</td><td>可选。如果设置为true，则更新符合查询条件的多个文档。如果设置为false，则更新一个文档。默认值为false。</td></tr><tr><td>writeConcern</td><td>document</td><td>可选。表示写问题的文档。抛出异常的级别。</td></tr><tr><td>collation</td><td>document</td><td>可选。<br>指定要用于操作的校对规则。<br>校对规则允许用户为字符串比较指定特定于语言的规则，例如字母大小写和重音标记的规则。<br>校对规则选项具有以下语法：<br>校对规则：{<br>区域设置：，<br>caseLevel:，<br>caseFirst:，<br>强度：，<br>numericordering:，<br>替代：，<br>最大变量：，<br>向后：<br>}<br>指定校对规则时，区域设置字段是必需的；所有其他校对规则字段都是可选的。有关字段的说明，请参阅校对规则文档。<br>如果未指定校对规则，但集合具有默认校对规则（请参见db.createCollection（）），则该操作将使用为集合指定的校对规则。<br>如果没有为集合或操作指定校对规则，MongoDB将使用以前版本中使用的简单二进制比较进行字符串比较。不能为一个操作指定多个校对规则。例如，不能为每个字段指定不同的校对规则，或者如果使用排序执行查找，则不能将一个校对规则用于查找，另一个校对规则用于排序。<br>3.4版新增。</td></tr><tr><td>arrayFilters</td><td>array</td><td>可选。一个筛选文档数组，用于确定要为数组字段上的更新操作修改哪些数组元素。</td></tr><tr><td>hint</td><td>Document<br>or string</td><td>可选。指定用于支持查询谓词的索引的文档或字符串。该选项可以采用索引规范文档或索引名称字符串。如果指定的索引不存在，则说明操作错误。例如，请参阅版本4中的“为更新操作指定提示。</td></tr></tbody></table><blockquote><p>tip:主要关注前四个参数即可。</p></blockquote><p>例如</p><p>（1）覆盖的修改</p><p>如果想修改_id为1的记录，点赞量为1001，输入以下语句：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">db<span class="hljs-selector-class">.comment</span><span class="hljs-selector-class">.update</span>(&#123;_id:<span class="hljs-string">&quot;1&quot;</span>&#125;,&#123;likenum:<span class="hljs-built_in">NumberInt</span>(<span class="hljs-number">1001</span>)&#125;)<br></code></pre></td></tr></table></figure><p>执行后，这条文档除了likenum字段其它字段都不见了</p><p>（2） 局部修改</p><p>修改_id为2的记录，浏览量为889。使用修改器$set来实现：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">db<span class="hljs-selector-class">.comment</span><span class="hljs-selector-class">.update</span>(&#123;_id:<span class="hljs-string">&quot;2&quot;</span>&#125;,&#123;<span class="hljs-variable">$set</span>:&#123;likenum:<span class="hljs-built_in">NumberInt</span>(<span class="hljs-number">889</span>)&#125;&#125;)<br></code></pre></td></tr></table></figure><p>（3）批量修改</p><p>更新所有用户为1003 的用户的昵称为凯撒大帝。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//默认只修改第一条数据</span><br>db.comment.<span class="hljs-title function_ invoke__">update</span>(&#123;<span class="hljs-attr">userid</span>:<span class="hljs-string">&quot;1003&quot;</span>&#125;,&#123;<span class="hljs-variable">$set</span>:&#123;<span class="hljs-attr">nickname</span>:<span class="hljs-string">&quot;凯撒2&quot;</span>&#125;&#125;)<br><span class="hljs-comment">//修改所有符合条件的数据</span><br>db.comment.<span class="hljs-title function_ invoke__">update</span>(&#123;<span class="hljs-attr">userid</span>:<span class="hljs-string">&quot;1003&quot;</span>&#125;,&#123;<span class="hljs-variable">$set</span>:&#123;<span class="hljs-attr">nickname</span>:<span class="hljs-string">&quot;凯撒大帝&quot;</span>&#125;&#125;,&#123;<span class="hljs-attr">multi</span>:<span class="hljs-literal">true</span>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>tip: 如果不加后面的参数，则只更新符合条件的第一条记录</p></blockquote><p>（4）列值增长的修改</p><p>对某列值在原有值的基础上进行增加或减少，可以使用$inc 运算符来实现。</p><p>对3号数据的点赞数，每次递增1</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">db<span class="hljs-selector-class">.comment</span><span class="hljs-selector-class">.update</span>(&#123;_id:<span class="hljs-string">&quot;3&quot;</span>&#125;,&#123;<span class="hljs-variable">$inc</span>:&#123;likenum:<span class="hljs-built_in">NumberInt</span>(<span class="hljs-number">1</span>)&#125;&#125;)<br></code></pre></td></tr></table></figure><h3 id="3-4-4-文档的删除"><a href="#3-4-4-文档的删除" class="headerlink" title="3.4.4 文档的删除"></a>3.4.4 文档的删除</h3><p>删除文档的语法结构：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">db.集合名称.<span class="hljs-built_in">remove</span>(条件)<br></code></pre></td></tr></table></figure><p>全部删除，<strong>慎用</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">db.comment.<span class="hljs-built_in">remove</span>(&#123;&#125;)<br></code></pre></td></tr></table></figure><p>删除_id&#x3D;1的记录</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">db.comment.<span class="hljs-built_in">remove</span>(&#123;_id:<span class="hljs-string">&quot;1&quot;</span>&#125;)<br></code></pre></td></tr></table></figure><h2 id="3-5-文档的分页查询"><a href="#3-5-文档的分页查询" class="headerlink" title="3.5 文档的分页查询"></a>3.5 文档的分页查询</h2><h3 id="3-5-1-统计查询"><a href="#3-5-1-统计查询" class="headerlink" title="3.5.1 统计查询"></a>3.5.1 统计查询</h3><p>统计查询使用count()方法，语法如下：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">db</span>.collection.<span class="hljs-keyword">count</span>(<span class="hljs-keyword">query</span>, options)<br></code></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th><strong>Parameter</strong></th><th><strong>Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>query</td><td>document</td><td>查询选择条件。</td></tr><tr><td>projection</td><td>document</td><td>可选。用于修改计数的额外选项。</td></tr></tbody></table><p>例如</p><p>（1）统计所有记录数</p><p>统计comment集合的所有的记录数：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">db.<span class="hljs-keyword">comment</span>.count()<br></code></pre></td></tr></table></figure><p>（2）按条件统计记录数</p><p>例如：统计userid为1003的记录条数</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">db.<span class="hljs-keyword">comment</span>.count(&#123;userid:&quot;1003&quot;&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>tip: 默认情况下count() 方法返回符合条件的全部记录条数。</p></blockquote><h3 id="3-5-2-分页列表查询"><a href="#3-5-2-分页列表查询" class="headerlink" title="3.5.2 分页列表查询"></a>3.5.2 分页列表查询</h3><p>可以使用limit()方法来读取指定数量的数据，使用skip()方法来跳过指定数量的数据。</p><p>基本语法如下所示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&gt;db<span class="hljs-selector-class">.COLLECTION_NAME</span><span class="hljs-selector-class">.find</span>()<span class="hljs-selector-class">.limit</span>(NUMBER)<span class="hljs-selector-class">.skip</span>(NUMBER)<br></code></pre></td></tr></table></figure><p>如果想返回指定条数的记录，可以在find方法后调用limit来返回结果(TopN)，默认值20，例如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">db<span class="hljs-selector-class">.comment</span><span class="hljs-selector-class">.find</span>()<span class="hljs-selector-class">.limit</span>(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>skip方法同样接受一个数字参数作为跳过的记录条数。（前N个不要）,默认值是0</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">db<span class="hljs-selector-class">.comment</span><span class="hljs-selector-class">.find</span>()<span class="hljs-selector-class">.skip</span>(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>分页查询：需求：每页2个，第二页开始：跳过前两条数据，接着值显示3和4条数据</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//第一页</span><br>db<span class="hljs-selector-class">.comment</span><span class="hljs-selector-class">.find</span>()<span class="hljs-selector-class">.skip</span>(<span class="hljs-number">0</span>)<span class="hljs-selector-class">.limit</span>(<span class="hljs-number">2</span>)<br><span class="hljs-comment">//第二页</span><br>db<span class="hljs-selector-class">.comment</span><span class="hljs-selector-class">.find</span>()<span class="hljs-selector-class">.skip</span>(<span class="hljs-number">2</span>)<span class="hljs-selector-class">.limit</span>(<span class="hljs-number">2</span>)<br><span class="hljs-comment">//第三页</span><br>db<span class="hljs-selector-class">.comment</span><span class="hljs-selector-class">.find</span>()<span class="hljs-selector-class">.skip</span>(<span class="hljs-number">4</span>)<span class="hljs-selector-class">.limit</span>(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h3 id="3-5-3-排序查询"><a href="#3-5-3-排序查询" class="headerlink" title="3.5.3 排序查询"></a>3.5.3 排序查询</h3><p>sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用<br>于降序排列。<br>语法如下所示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">db<span class="hljs-selector-class">.COLLECTION_NAME</span><span class="hljs-selector-class">.find</span>()<span class="hljs-selector-class">.sort</span>(&#123;KEY:<span class="hljs-number">1</span>&#125;)<br>或<br>db.集合名称<span class="hljs-selector-class">.find</span>()<span class="hljs-selector-class">.sort</span>(排序方式)<br></code></pre></td></tr></table></figure><p>对userid降序排列，并对访问量进行升序排列</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">db.<span class="hljs-built_in">comment</span>.<span class="hljs-built_in">find</span>().<span class="hljs-built_in">sort</span>(&#123;userid:-<span class="hljs-number">1</span>,likenum:<span class="hljs-number">1</span>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>tip：skip(), limilt(), sort()三个放在一起执行的时候，执行的顺序是先 sort(), 然后是 skip()，最后是显示的 limit()，和命令编写顺序无关。</p></blockquote><h2 id="3-6-文档的更多查询"><a href="#3-6-文档的更多查询" class="headerlink" title="3.6 文档的更多查询"></a>3.6 文档的更多查询</h2><h3 id="3-6-1-正则的复杂条件查询"><a href="#3-6-1-正则的复杂条件查询" class="headerlink" title="3.6.1 正则的复杂条件查询"></a>3.6.1 正则的复杂条件查询</h3><p>MongoDB的模糊查询是通过正则表达式的方式实现的。格式为：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">db.collection.<span class="hljs-built_in">find</span>(&#123;<span class="hljs-attr">field</span>:<span class="hljs-regexp">/正则表达式/</span>&#125;)<br>或<br>db.集合.<span class="hljs-built_in">find</span>(&#123;字段:<span class="hljs-regexp">/正则表达式/</span>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>tip: 正则表达式是js的语法，直接量的写法。</p></blockquote><p>要查询评论内容包含“开水”的所有文档：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">db.comment.<span class="hljs-built_in">find</span>(&#123;<span class="hljs-attr">content</span>:<span class="hljs-regexp">/开水/</span>&#125;)<br></code></pre></td></tr></table></figure><p>要查询评论的内容中以“专家”开头的：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">db.comment.<span class="hljs-built_in">find</span>(&#123;<span class="hljs-attr">content</span>:<span class="hljs-regexp">/^专家/</span>&#125;)<br></code></pre></td></tr></table></figure><h3 id="3-6-2-比较查询"><a href="#3-6-2-比较查询" class="headerlink" title="3.6.2 比较查询"></a>3.6.2 比较查询</h3><p>&lt;, &lt;&#x3D;, &gt;, &gt;&#x3D; 这个操作符也是很常用的，格式如下:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">db.集合名称.find(&#123; <span class="hljs-string">&quot;field&quot;</span> : &#123; <span class="hljs-variable">$gt</span>: value &#125;&#125;) <span class="hljs-regexp">//</span> 大于: field &gt; value<br>db.集合名称.find(&#123; <span class="hljs-string">&quot;field&quot;</span> : &#123; <span class="hljs-variable">$lt</span>: value &#125;&#125;) <span class="hljs-regexp">//</span> 小于: field &lt; value<br>db.集合名称.find(&#123; <span class="hljs-string">&quot;field&quot;</span> : &#123; <span class="hljs-variable">$gte</span>: value &#125;&#125;) <span class="hljs-regexp">//</span> 大于等于: field &gt;= value<br>db.集合名称.find(&#123; <span class="hljs-string">&quot;field&quot;</span> : &#123; <span class="hljs-variable">$lte</span>: value &#125;&#125;) <span class="hljs-regexp">//</span> 小于等于: field &lt;= value<br>db.集合名称.find(&#123; <span class="hljs-string">&quot;field&quot;</span> : &#123; <span class="hljs-variable">$ne</span>: value &#125;&#125;) <span class="hljs-regexp">//</span> 不等于: field != value<br></code></pre></td></tr></table></figure><p>示例：查询评论点赞数量大于700的记录</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">db<span class="hljs-selector-class">.comment</span><span class="hljs-selector-class">.find</span>(&#123;likenum:&#123;<span class="hljs-variable">$gt</span>:<span class="hljs-built_in">NumberInt</span>(<span class="hljs-number">700</span>)&#125;&#125;)<br></code></pre></td></tr></table></figure><h3 id="3-6-3-包含查询"><a href="#3-6-3-包含查询" class="headerlink" title="3.6.3 包含查询"></a>3.6.3 包含查询</h3><p>包含使用$in操作符。 示例：查询评论的集合中userid字段包含1003或1004的文档</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">db<span class="hljs-selector-class">.comment</span><span class="hljs-selector-class">.find</span>(&#123;userid:&#123;<span class="hljs-variable">$in</span>:<span class="hljs-selector-attr">[<span class="hljs-string">&quot;1003&quot;</span>,<span class="hljs-string">&quot;1004&quot;</span>]</span>&#125;&#125;)<br></code></pre></td></tr></table></figure><p>不包含使用$nin操作符。 示例：查询评论集合中userid字段不包含1003和1004的文档</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">db<span class="hljs-selector-class">.comment</span><span class="hljs-selector-class">.find</span>(&#123;userid:&#123;<span class="hljs-variable">$nin</span>:<span class="hljs-selector-attr">[<span class="hljs-string">&quot;1003&quot;</span>,<span class="hljs-string">&quot;1004&quot;</span>]</span>&#125;&#125;)<br></code></pre></td></tr></table></figure><h3 id="3-6-4-条件连接查询"><a href="#3-6-4-条件连接查询" class="headerlink" title="3.6.4 条件连接查询"></a>3.6.4 条件连接查询</h3><p>如果需要查询同时满足两个以上条件，需要使用$and操作符将条件进行关联。（相 当于SQL的and） 格式为：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">$and:[ </span><span class="hljs-template-variable">&#123; &#125;</span><span class="language-xml">,</span><span class="hljs-template-variable">&#123; &#125;</span><span class="language-xml">,</span><span class="hljs-template-variable">&#123; &#125;</span><span class="language-xml"> ]</span><br></code></pre></td></tr></table></figure><p>查询评论集合中likenum大于等于700 并且小于2000的文档：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">db.comment.find(&#123;<span class="hljs-variable">$and</span><span class="hljs-symbol">:</span>[&#123;<span class="hljs-symbol">likenum:</span>&#123;<span class="hljs-variable">$gte</span><span class="hljs-symbol">:NumberInt</span>(<span class="hljs-number">700</span>)&#125;&#125;,&#123;<span class="hljs-symbol">likenum:</span>&#123;<span class="hljs-variable">$lt</span><span class="hljs-symbol">:NumberInt</span>(<span class="hljs-number">2000</span>)&#125;&#125;]&#125;)<br></code></pre></td></tr></table></figure><p>如果两个以上条件之间是或者的关系，我们使用 操作符进行关联，与前面 and的使用方式相同 格式为：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">$or:[ </span><span class="hljs-template-variable">&#123; &#125;</span><span class="language-xml">,</span><span class="hljs-template-variable">&#123; &#125;</span><span class="language-xml">,</span><span class="hljs-template-variable">&#123; &#125;</span><span class="language-xml"> ]</span><br></code></pre></td></tr></table></figure><p>查询评论集合中userid为1003，或者点赞数小于1000的文档记录</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">db.comment.<span class="hljs-title function_ invoke__">find</span>(&#123;<span class="hljs-variable">$or</span>:[ &#123;<span class="hljs-attr">userid</span>:<span class="hljs-string">&quot;1003&quot;</span>&#125; ,&#123;<span class="hljs-attr">likenum</span>:&#123;<span class="hljs-variable">$lt</span>:<span class="hljs-number">1000</span>&#125; &#125;]&#125;)<br></code></pre></td></tr></table></figure><h2 id="3-7-常用命令小结"><a href="#3-7-常用命令小结" class="headerlink" title="3.7 常用命令小结"></a>3.7 常用命令小结</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros">选择切换数据库：use articledb<br>插入数据：db.comment.insert(&#123;bson数据&#125;)<br>查询所有数据：db.comment.<span class="hljs-built_in">find</span>();<br>条件查询数据：db.comment.<span class="hljs-built_in">find</span>(&#123;条件&#125;)<br>查询符合条件的第一条记录：db.comment.findOne(&#123;条件&#125;)<br>查询符合条件的前几条记录：db.comment.<span class="hljs-built_in">find</span>(&#123;条件&#125;).limit(条数)<br>查询符合条件的跳过的记录：db.comment.<span class="hljs-built_in">find</span>(&#123;条件&#125;).skip(条数)<br>修改数据：db.comment.update(&#123;条件&#125;,&#123;修改后的数据&#125;) 或db.comment.update(&#123;条件&#125;,&#123;<span class="hljs-variable">$set</span>:&#123;要修改部分的字段:数据&#125;)<br>修改数据并自增某字段值：db.comment.update(&#123;条件&#125;,&#123;<span class="hljs-variable">$inc</span>:&#123;自增的字段:步进值&#125;&#125;)<br>删除数据：db.comment.<span class="hljs-built_in">remove</span>(&#123;条件&#125;)<br>统计查询：db.comment.count(&#123;条件&#125;)<br>模糊查询：db.comment.<span class="hljs-built_in">find</span>(&#123;字段名:/正则表达式/&#125;)<br>条件比较运算：db.comment.<span class="hljs-built_in">find</span>(&#123;字段名:&#123;<span class="hljs-variable">$gt</span>:值&#125;&#125;)<br>包含查询：db.comment.<span class="hljs-built_in">find</span>(&#123;字段名:&#123;<span class="hljs-variable">$in</span>:[值1，值2]&#125;&#125;)或db.comment.<span class="hljs-built_in">find</span>(&#123;字段名:&#123;<span class="hljs-variable">$nin</span>:[值1，值2]&#125;&#125;)<br>条件连接查询：db.comment.<span class="hljs-built_in">find</span>(&#123;<span class="hljs-variable">$and</span>:[&#123;条件1&#125;,&#123;条件2&#125;]&#125;)或db.comment.<span class="hljs-built_in">find</span>(&#123;<span class="hljs-variable">$or</span>:[&#123;条件1&#125;,&#123;条件2&#125;]&#125;)<br></code></pre></td></tr></table></figure><h1 id="4-索引-Index"><a href="#4-索引-Index" class="headerlink" title="4 索引-Index"></a>4 索引-Index</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>MongoDB索引使用B树数据结构（确切的说是B-Tree，MySQL是B+Tree）</p><h2 id="4-2-索引类型"><a href="#4-2-索引类型" class="headerlink" title="4.2 索引类型"></a>4.2 索引类型</h2><ul><li>单字段索引</li><li>复合索引</li><li>其他索引</li></ul><h2 id="4-3-索引的管理操作"><a href="#4-3-索引的管理操作" class="headerlink" title="4.3 索引的管理操作"></a>4.3 索引的管理操作</h2><h3 id="4-3-1-索引的查看"><a href="#4-3-1-索引的查看" class="headerlink" title="4.3.1 索引的查看"></a>4.3.1 索引的查看</h3><p>返回一个集合中的所有索引的数组。</p><p>语法</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">db<span class="hljs-selector-class">.collection</span><span class="hljs-selector-class">.getIndexes</span>()<br></code></pre></td></tr></table></figure><p>查看comment集合中所有的索引情况</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">db<span class="hljs-selector-class">.comment</span><span class="hljs-selector-class">.getIndexes</span>()<br></code></pre></td></tr></table></figure><blockquote><p>结果中显示的是默认_id 索引。</p></blockquote><h3 id="4-3-2-索引创建"><a href="#4-3-2-索引创建" class="headerlink" title="4.3.2 索引创建"></a>4.3.2 索引创建</h3><p>在集合上创建索引。</p><p>语法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">db.collection.create<span class="hljs-constructor">Index(<span class="hljs-params">keys</span>, <span class="hljs-params">options</span>)</span><br></code></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th><strong>Parameter</strong></th><th><strong>Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>keys</td><td>document</td><td>包含字段和值对的文档，其中字段是索引键，值描述该字段的索引类型。对于字段上的升序索引，请<br>指定值1；对于降序索引，请指定值-1。比如： {字段:1或-1} ，其中1 为指定按升序创建索引，如果你<br>想按降序来创建索引指定为 -1 即可。另外，MongoDB支持几种不同的索引类型，包括文本、地理空<br>间和哈希索引。</td></tr><tr><td>options</td><td>document</td><td>可选。包含一组控制索引创建的选项的文档。有关详细信息，请参见选项详情列表。</td></tr></tbody></table><p>例子</p><p>（1）单字段索引示例：对userid 字段建立索引：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">db.comment.create<span class="hljs-constructor">Index(&#123;<span class="hljs-params">userid</span>:1&#125;)</span><br></code></pre></td></tr></table></figure><p>（2）复合索引：对userid 和nickname 同时建立复合（Compound）索引：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">db.comment.create<span class="hljs-constructor">Index(&#123;<span class="hljs-params">userid</span>:1,<span class="hljs-params">nickname</span>:-1&#125;)</span><br></code></pre></td></tr></table></figure><h3 id="4-3-3-索引的移除"><a href="#4-3-3-索引的移除" class="headerlink" title="4.3.3 索引的移除"></a>4.3.3 索引的移除</h3><p>一、指定索引的移除</p><p>语法：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">db.collection.<span class="hljs-keyword">drop</span><span class="hljs-meta">Index</span>(<span class="hljs-keyword">index</span>)<br></code></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th><strong>Parameter</strong></th><th><strong>Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>index</td><td>string or<br>document</td><td>指定要删除的索引。可以通过索引名称或索引规范文档指定索引。若要删除文本索引，请指定<br>索引名称。</td></tr></tbody></table><p>例子：</p><p>删除comment 集合中userid 字段上的升序索引：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&gt; db.<span class="hljs-property">comment</span>.<span class="hljs-title function_">dropIndex</span>(<span class="hljs-params">&#123;userid:<span class="hljs-number">1</span>&#125;</span>)<br>&#123; <span class="hljs-string">&quot;nIndexesWas&quot;</span> : <span class="hljs-number">3</span>, <span class="hljs-string">&quot;ok&quot;</span> : <span class="hljs-number">1</span> &#125;<br></code></pre></td></tr></table></figure><p>二、所有索引的移除</p><p>语法：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">db<span class="hljs-selector-class">.collection</span><span class="hljs-selector-class">.dropIndexes</span>()<br></code></pre></td></tr></table></figure><p>删除spit 集合中所有索引:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">db<span class="hljs-selector-class">.comment</span><span class="hljs-selector-class">.dropIndexes</span>()<br></code></pre></td></tr></table></figure><h2 id="4-4-索引的使用"><a href="#4-4-索引的使用" class="headerlink" title="4.4 索引的使用"></a>4.4 索引的使用</h2><h3 id="4-4-1-执行计划"><a href="#4-4-1-执行计划" class="headerlink" title="4.4.1 执行计划"></a>4.4.1 执行计划</h3><p>建立的索引是否有效，效果如何，都需要通过执行计划查看</p><p>语法</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">db.collection.<span class="hljs-keyword">find</span>(query,<span class="hljs-keyword">options</span>).explain(<span class="hljs-keyword">options</span>)<br></code></pre></td></tr></table></figure><p>例子：查看根据userid查询数据的情况</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs php">&gt;db.comment.<span class="hljs-title function_ invoke__">find</span>(&#123;<span class="hljs-attr">userid</span>:<span class="hljs-string">&quot;1003&quot;</span>&#125;).<span class="hljs-title function_ invoke__">explain</span>()<br><br>&#123;<br>    <span class="hljs-string">&quot;queryPlanner&quot;</span> : &#123;<br>        <span class="hljs-string">&quot;plannerVersion&quot;</span> : <span class="hljs-number">1</span>,<br>        <span class="hljs-string">&quot;namespace&quot;</span> : <span class="hljs-string">&quot;articledb.comment&quot;</span>,<br>        <span class="hljs-string">&quot;indexFilterSet&quot;</span> : <span class="hljs-literal">false</span>,<br>        <span class="hljs-string">&quot;parsedQuery&quot;</span> : &#123;<br>            <span class="hljs-string">&quot;userid&quot;</span> : &#123;<br>             <span class="hljs-string">&quot;<span class="hljs-subst">$eq</span>&quot;</span> : <span class="hljs-string">&quot;1003&quot;</span><br>            &#125;<br>        &#125;,<br>        <span class="hljs-string">&quot;winningPlan&quot;</span> : &#123;<br>            <span class="hljs-string">&quot;stage&quot;</span> : <span class="hljs-string">&quot;COLLSCAN&quot;</span>, <span class="hljs-comment">//全局扫描就是没有走索引</span><br>            <span class="hljs-string">&quot;filter&quot;</span> : &#123;<br>                <span class="hljs-string">&quot;userid&quot;</span> : &#123;<br>                <span class="hljs-string">&quot;<span class="hljs-subst">$eq</span>&quot;</span> : <span class="hljs-string">&quot;1003&quot;</span><br>            &#125;<br>            &#125;,<br>            <span class="hljs-string">&quot;direction&quot;</span> : <span class="hljs-string">&quot;forward&quot;</span><br>        &#125;,<br>        <span class="hljs-string">&quot;rejectedPlans&quot;</span> : [ ]<br>    &#125;,<br>    <span class="hljs-string">&quot;serverInfo&quot;</span> : &#123;<br>        <span class="hljs-string">&quot;host&quot;</span> : <span class="hljs-string">&quot;9ef3740277ad&quot;</span>,<br>        <span class="hljs-string">&quot;port&quot;</span> : <span class="hljs-number">27017</span>,<br>        <span class="hljs-string">&quot;version&quot;</span> : <span class="hljs-string">&quot;4.0.10&quot;</span>,<br>        <span class="hljs-string">&quot;gitVersion&quot;</span> : <span class="hljs-string">&quot;c389e7f69f637f7a1ac3cc9fae843b635f20b766&quot;</span><br>    &#125;,<br>    <span class="hljs-string">&quot;ok&quot;</span> : <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>tip: 关键点看： “stage” : “COLLSCAN”, 表示全集合扫描</p></blockquote><h3 id="4-4-2-涵盖的查询"><a href="#4-4-2-涵盖的查询" class="headerlink" title="4.4.2 涵盖的查询"></a>4.4.2 涵盖的查询</h3><p>Covered Queries，当查询条件和查询的投影仅包含索引字段时，MongoDB直接从索引返回结果，而不扫描任何文档或将文档带入内存。 这些覆盖的查询可以<br>非常有效。</p><p>例子</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">db.comment.<span class="hljs-title function_ invoke__">find</span>(&#123;<span class="hljs-attr">userid</span>:<span class="hljs-string">&quot;1003&quot;</span>&#125;,&#123;<span class="hljs-attr">userid</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">_id</span>:<span class="hljs-number">0</span>&#125;)<span class="hljs-comment">//查userid，不用_id,有userid的索引就不用回表</span><br></code></pre></td></tr></table></figure><h1 id="5-开发案例"><a href="#5-开发案例" class="headerlink" title="5.开发案例"></a>5.开发案例</h1><h2 id="5-1-需求分析"><a href="#5-1-需求分析" class="headerlink" title="5.1 需求分析"></a>5.1 需求分析</h2><p>文章示例参考：早晨空腹喝水，是对还是错？<a href="https://www.toutiao.com/a6721476546088927748/">https://www.toutiao.com/a6721476546088927748/</a><br>需要实现以下功能：<br>1）基本增删改查API<br>2）根据文章id查询评论<br>3）评论点赞</p><h2 id="5-2-表结构分析"><a href="#5-2-表结构分析" class="headerlink" title="5.2 表结构分析"></a>5.2 表结构分析</h2><p>数据库：articledb</p><table><thead><tr><th>专栏文章评论</th><th>comment</th><th></th><th></th></tr></thead><tbody><tr><td>字段名称</td><td>字段含义</td><td>字段类型</td><td>备注</td></tr><tr><td>_id</td><td>ID</td><td>ObjectId或String</td><td>Mongo的主键的字段</td></tr><tr><td>articleid</td><td>文章ID</td><td>String</td><td></td></tr><tr><td>content</td><td>评论内容</td><td>String</td><td></td></tr><tr><td>userid</td><td>评论人ID</td><td>String</td><td></td></tr><tr><td>nickname</td><td>评论人昵称</td><td>String</td><td></td></tr><tr><td>createdatetime</td><td>评论的日期时间</td><td>Date</td><td></td></tr><tr><td>likenum</td><td>回复数</td><td>Int32</td><td></td></tr><tr><td>replynum</td><td>状态</td><td>Int32</td><td></td></tr><tr><td>state</td><td>状态</td><td>String</td><td>0：不可见；1：可见；</td></tr><tr><td>parentid</td><td>上级ID</td><td>String</td><td>如果为0表示文章的顶级评论</td></tr></tbody></table><h2 id="5-3-技术选型"><a href="#5-3-技术选型" class="headerlink" title="5.3 技术选型"></a>5.3 技术选型</h2><h3 id="5-3-1-mongodb-driver"><a href="#5-3-1-mongodb-driver" class="headerlink" title="5.3.1 mongodb-driver"></a>5.3.1 mongodb-driver</h3><p>mongodb-driver是mongo官方推出的java连接mongoDB的驱动包，相当于JDBC驱动。我们通过一个入门的案例来了解mongodb-driver<br>的基本使用。<br>官方驱动说明和下载：<a href="http://mongodb.github.io/mongo-java-driver/">http://mongodb.github.io/mongo-java-driver/</a><br>官方驱动示例文档：<a href="http://mongodb.github.io/mongo-java-driver/3.8/driver/getting-started/quick-start/">http://mongodb.github.io/mongo-java-driver/3.8/driver/getting-started/quick-start/</a></p><h3 id="5-3-2-SpringDataMongoDB"><a href="#5-3-2-SpringDataMongoDB" class="headerlink" title="5.3.2 SpringDataMongoDB"></a>5.3.2 SpringDataMongoDB</h3><p>SpringData家族成员之一，用于操作MongoDB的持久层框架，封装了底层的mongodb-driver。<br>官网主页： <a href="https://projects.spring.io/spring-data-mongodb/">https://projects.spring.io/spring-data-mongodb/</a></p><h2 id="5-4-文章微服务模块搭建"><a href="#5-4-文章微服务模块搭建" class="headerlink" title="5.4 文章微服务模块搭建"></a>5.4 文章微服务模块搭建</h2><p>（1）搭建项目工程article，pom.xml引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）创建application.yml</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">spring:<br>    #数据源配置<br>    data:<br>        mongodb:<br>            # 主机地址<br>            host: <span class="hljs-number">192.168</span><span class="hljs-number">.40</span><span class="hljs-number">.141</span><br>            # 数据库<br>            database: articledb<br>            # 默认端口是<span class="hljs-number">27017</span><br>            port: <span class="hljs-number">27017</span><br>            #也可以使用uri连接<br>            #uri: mongodb:<span class="hljs-comment">//192.168.40.134:27017/articledb</span><br></code></pre></td></tr></table></figure><p>（3）创建启动类</p><h2 id="5-5-文章评论实体类的编写"><a href="#5-5-文章评论实体类的编写" class="headerlink" title="5.5 文章评论实体类的编写"></a>5.5 文章评论实体类的编写</h2><p>创建实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//复合索引</span><br><span class="hljs-comment">// @CompoundIndex( def = &quot;&#123;&#x27;userid&#x27;: 1, &#x27;nickname&#x27;: -1&#125;&quot;)</span><br><span class="hljs-meta">@Document(collection=&quot;comment&quot;)</span><span class="hljs-comment">//可以省略，如果省略，则默认使用类名小写映射集合</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Comment</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-comment">//主键标识，该属性的值会自动对应mongodb的主键字段&quot;_id&quot;，如果该属性名就叫“id”,则该注解可以省略，否则必须写</span><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-keyword">private</span> String id;<span class="hljs-comment">//主键</span><br><span class="hljs-meta">@Field(&quot;content&quot;)</span><span class="hljs-comment">//该属性对应mongodb的字段的名字，如果一致，则无需该注解</span><br>    <span class="hljs-keyword">private</span> String content;<span class="hljs-comment">//吐槽内容</span><br><span class="hljs-keyword">private</span> Date publishtime;<span class="hljs-comment">//发布日期</span><br>    <span class="hljs-meta">@Indexed</span>  <span class="hljs-comment">//添加了一个单字段的索引</span><br><span class="hljs-keyword">private</span> String userid;<span class="hljs-comment">//发布人ID</span><br>    <span class="hljs-keyword">private</span> String userid;<span class="hljs-comment">//发布人ID</span><br>    <span class="hljs-keyword">private</span> String nickname;<span class="hljs-comment">//昵称</span><br>    <span class="hljs-keyword">private</span> LocalDateTime createdatetime;<span class="hljs-comment">//评论的日期时间</span><br>    <span class="hljs-keyword">private</span> Integer likenum;<span class="hljs-comment">//点赞数</span><br>    <span class="hljs-keyword">private</span> Integer replynum;<span class="hljs-comment">//回复数</span><br>    <span class="hljs-keyword">private</span> String state;<span class="hljs-comment">//状态</span><br>    <span class="hljs-keyword">private</span> String parentid;<span class="hljs-comment">//上级ID</span><br>    <span class="hljs-keyword">private</span> String articleid;<br>    <span class="hljs-comment">//getter and setter.....</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>tip: 索引可以提升查询效率，一般在查询字段上添加索引，索引的添加可以通过Mongo的命令来添加，也可以在Java的实体类中通过注解添加。</p></blockquote><blockquote><p>db.comment.createIndex({“userid”:1}) &#x2F;&#x2F;单字段索引注解@Indexed</p><p>db.comment.createIndex({“userid”:1,”nickname”:-1}) &#x2F;&#x2F;复合索引注解@CompoundIndex</p></blockquote><h2 id="5-6-文章评论的基本增删改查"><a href="#5-6-文章评论的基本增删改查" class="headerlink" title="5.6 文章评论的基本增删改查"></a>5.6 文章评论的基本增删改查</h2><p>（1）创建数据访问接口dao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//评论的持久层接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CommentRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MongoRepository</span>&lt;Comment,String&gt; &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>（2）创建业务逻辑类sevice包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//评论的业务层</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommentService</span> &#123;<br>    <span class="hljs-comment">//注入dao</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> CommentRepository commentRepository;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * 保存一个评论</span><br><span class="hljs-comment">        * <span class="hljs-doctag">@param</span> comment</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveComment</span><span class="hljs-params">(Comment comment)</span>&#123;<br>        commentRepository.save(comment);<br>        &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * 更新评论</span><br><span class="hljs-comment">        * <span class="hljs-doctag">@param</span> comment</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateComment</span><span class="hljs-params">(Comment comment)</span>&#123;<br>        commentRepository.save(comment);<br>        &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * 根据id删除评论</span><br><span class="hljs-comment">        * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteCommentById</span><span class="hljs-params">(String id)</span>&#123;<br>        commentRepository.deleteById(id);<br>        &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * 查询所有评论</span><br><span class="hljs-comment">        * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">public</span> List&lt;Comment&gt; <span class="hljs-title function_">findCommentList</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> commentRepository.findAll();<br>        &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * 根据id查询评论</span><br><span class="hljs-comment">        * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">        * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">public</span> Comment <span class="hljs-title function_">findCommentById</span><span class="hljs-params">(String id)</span>&#123;<br>            <span class="hljs-keyword">return</span> commentRepository.findById(id).get();<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-7-MongoTemplate实现评论点赞"><a href="#5-7-MongoTemplate实现评论点赞" class="headerlink" title="5.7 MongoTemplate实现评论点赞"></a>5.7 MongoTemplate实现评论点赞</h2><p>传统做法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 点赞-效率低</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateCommentThumbupToIncrementingOld</span><span class="hljs-params">(String id)</span>&#123;<br>    <span class="hljs-type">Comment</span> <span class="hljs-variable">comment</span> <span class="hljs-operator">=</span> CommentRepository.findById(id).get();<br>    comment.setLikenum(comment.getLikenum()+<span class="hljs-number">1</span>);<br>    CommentRepository.save(comment);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>以上方法虽然实现简单，但是执行效率并不高，因为只需要将点赞数加1就可以了，没必要查询出所有字段修改后再更新所有字段。(蝴蝶效应)</p></blockquote><p>可以使用MongoTemplate类来实现对某列的操作</p><p>修改CommentService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注入MongoTemplate</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> MongoTemplate mongoTemplate;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 点赞数+1</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateCommentLikenum</span><span class="hljs-params">(String id)</span>&#123;<br>    <span class="hljs-comment">//1.查询对象</span><br>    Query query=Query.query(Criteria.where(<span class="hljs-string">&quot;_id&quot;</span>).is(id));<br>    <span class="hljs-comment">//2.更新对象</span><br>    Update update=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Update</span>();<br>    <span class="hljs-comment">//局部更新，相当于$set</span><br>    <span class="hljs-comment">// update.set(key,value)</span><br>    <span class="hljs-comment">//递增$inc</span><br>    <span class="hljs-comment">// update.inc(&quot;likenum&quot;,1);</span><br>    update.inc(<span class="hljs-string">&quot;likenum&quot;</span>);<br>    <span class="hljs-comment">//参数1：查询对象</span><br>    <span class="hljs-comment">//参数2：更新对象</span><br>    <span class="hljs-comment">//参数3：集合的名字或实体类的类型Comment.class</span><br>    mongoTemplate.updateFirst(query,update,<span class="hljs-string">&quot;comment&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端技术栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js</title>
    <link href="/2023/04/01/Node.js/"/>
    <url>/2023/04/01/Node.js/</url>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>官网：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></p><p>理解node是一个运行环境：</p><ul><li>浏览器是 JavaScript 的前端运行环境</li><li>Node.js 是 JavaScript 的后端运行环境</li><li>Node.js 中无法调用 DOM 和 BOM 等浏览器内置 API</li></ul><h2 id="2-fs文件系统模块"><a href="#2-fs文件系统模块" class="headerlink" title="2.fs文件系统模块"></a>2.fs文件系统模块</h2><p> 导入fs</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>)<br></code></pre></td></tr></table></figure><p>方法（必选参数）[可选参数]</p><p>读取指定文件中的内容：<code>fs.readFile(path[, option], callback)</code></p><ul><li>path：必选参数，字符串，表示文件的路径</li><li>options：可选参数，表示以什么编码格式来读取文件，比如utf8 </li><li>callback：必选参数，文件读取完成后，通过回调函数拿到读取结果，function(err,dataStr){ }，如果读取成功，err为null</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 导入 fs 模块，来操作文件</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br><span class="hljs-comment">// 2. 调用 fs.readFile() 方法读取文件</span><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/11.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, dataStr</span>) &#123;<br>  <span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;读取文件失败！&#x27;</span> + err.<span class="hljs-property">message</span>)<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;读取文件成功！&#x27;</span> + dataStr)<br>&#125;)<br></code></pre></td></tr></table></figure><p>向指定的文件中写入内容：<code>fs.writeFile(path, data[, option], callback)</code></p><ul><li>path：必选参数，字符串，文件路径</li><li>data：必选参数，写入的内容</li><li>options：可选参数，设置字符集，默认值是 utf8</li><li>callback：必选参数，件写入完成后的回调函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br><span class="hljs-comment">// 调用 fs.writeFile() 方法，写入文件的内容</span><br>fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">&#x27;./files/3.txt&#x27;</span>, <span class="hljs-string">&#x27;ok123&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123;<br>  <span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件写入失败！&#x27;</span> + err.<span class="hljs-property">message</span>)<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件写入成功！&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>tip：<strong>写入会覆盖原内容</strong>，fs.writeFile()只能用来创建文件，不能创建路径</p></blockquote><h3 id="考试成绩整理案例"><a href="#考试成绩整理案例" class="headerlink" title="考试成绩整理案例"></a>考试成绩整理案例</h3><p>要求：使用fs文件系统模块，将素材目录下成绩.txt文件中的数据，整理到成绩-ok.txt文件中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 导入 fs 模块</span><br><span class="hljs-type">const</span> <span class="hljs-variable">fs</span> <span class="hljs-operator">=</span> require(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-comment">// 2. 调用fs.readFile()读取文件的内容</span><br>fs.readFile(<span class="hljs-string">&#x27;../素材/成绩.txt&#x27;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>,function(err,dataStr)&#123;<br>    <span class="hljs-comment">//3. 判断是否读取成功</span><br>    <span class="hljs-keyword">if</span>(err)&#123;<br>        <span class="hljs-keyword">return</span> console.log(<span class="hljs-string">&#x27;读取文件失败！&#x27;</span>+ err.message)<br>    &#125;<br>   <span class="hljs-comment">//4.处理读出来的数据</span><br>    <span class="hljs-type">const</span> <span class="hljs-variable">arrOld</span> <span class="hljs-operator">=</span> dataStr.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-type">const</span> <span class="hljs-variable">arrNew</span> <span class="hljs-operator">=</span> [] <br>    arrOld.forEach(item =&gt; &#123;<br>        arrNew,push(item.replace(<span class="hljs-string">&#x27;=&#x27;</span>,<span class="hljs-string">&#x27;:&#x27;</span>))<br>    &#125;)<br>    <span class="hljs-type">const</span> <span class="hljs-variable">newStr</span> <span class="hljs-operator">=</span> arrNew.join(<span class="hljs-string">&#x27;\r\n&#x27;</span>)<br>    console.log(newStr)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="路径动态拼接的问题"><a href="#路径动态拼接的问题" class="headerlink" title="路径动态拼接的问题"></a>路径动态拼接的问题</h3><p>如果提供的操作路径是以.&#x2F;或…&#x2F;开头的<strong>相对路径</strong>时，很容易出现路径动态拼接错误的问题。</p><p>原因：代码在运行的时候，<strong>会以执行node命令时所处的目录</strong>，动态拼接出被操作文件的完整路径。</p><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230427221555559.png" alt="image-20230427221555559"></p><p>解决方法：不用相对路径。1.可以从盘符开始（可移植性差），2.<strong>__dirname</strong> 表示当前文件所处的目录</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fs.<span class="hljs-title function_">readFile</span>(__dirname + <span class="hljs-string">&#x27;/files/1.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, dataStr</span>) &#123;<br>  <span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;读取文件失败！&#x27;</span> + err.<span class="hljs-property">message</span>)<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;读取文件成功！&#x27;</span> + dataStr)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="3-path路径模块"><a href="#3-path路径模块" class="headerlink" title="3.path路径模块"></a>3.path路径模块</h2><p>导入path</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>)<br></code></pre></td></tr></table></figure><p>方法</p><p>路径拼接：<code>path.join(...paths)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 注意：  ../ 会抵消前面的路径</span><br><span class="hljs-keyword">const</span> pathStr = path.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;/a&#x27;</span>, <span class="hljs-string">&#x27;/b/c&#x27;</span>, <span class="hljs-string">&#x27;../&#x27;</span>, <span class="hljs-string">&#x27;./d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pathStr)  <span class="hljs-comment">// \a\b\d\e</span><br></code></pre></td></tr></table></figure><p>获取路径中的最后一部分：<code>path.basename(path[, ext])</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-comment">// 定义文件的存放路径</span><br><span class="hljs-keyword">const</span> fpath = <span class="hljs-string">&#x27;/a/b/c/index.html&#x27;</span><br><span class="hljs-keyword">const</span> fullName = path.<span class="hljs-title function_">basename</span>(fpath)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fullName) <span class="hljs-comment">// index.html</span><br><span class="hljs-comment">// 去除文件扩展名</span><br><span class="hljs-keyword">const</span> nameWithoutExt = path.<span class="hljs-title function_">basename</span>(fpath, <span class="hljs-string">&#x27;.html&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nameWithoutExt) <span class="hljs-comment">// index</span><br></code></pre></td></tr></table></figure><p>获取路径中的文件扩展名：<code>path.extname(path)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-comment">// 这是文件的存放路径</span><br><span class="hljs-keyword">const</span> fpath = <span class="hljs-string">&#x27;/a/b/c/index.html&#x27;</span><br><span class="hljs-keyword">const</span> fext = path.<span class="hljs-title function_">extname</span>(fpath)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fext)<span class="hljs-comment">//输出.html</span><br></code></pre></td></tr></table></figure><h2 id="4-http模块"><a href="#4-http模块" class="headerlink" title="4.http模块"></a>4.http模块</h2><p> http 模块是 Node.js 官方提供的用来创建 web 服务器的模块</p><p>导入http</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>)<br></code></pre></td></tr></table></figure><p>创建web服务器： <code>http.createServer()</code> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 导入 http 模块</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><br><span class="hljs-comment">// 2. 创建 web 服务器实例</span><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>()<br><br><span class="hljs-comment">// 3. 为服务器实例绑定 request 事件，监听客户端的请求</span><br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Someone visit our web server.&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 4. 启动服务器</span><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server running at http://127.0.0.1:8080&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>req包含了与客户端相关的数据和属性，比如req.url req.method; </p><p>res包含了与服务器相关的数据和属性，比如res.end()响应内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// req.url 是客户端请求的 URL 地址</span><br>  <span class="hljs-keyword">const</span> url = req.<span class="hljs-property">url</span><br>  <span class="hljs-comment">// req.method 是客户端请求的 method 类型</span><br>  <span class="hljs-keyword">const</span> method = req.<span class="hljs-property">method</span><br>  <span class="hljs-keyword">const</span> str = <span class="hljs-string">`Your request url is <span class="hljs-subst">$&#123;url&#125;</span>, and request method is <span class="hljs-subst">$&#123;method&#125;</span>`</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str)<br>  <br>  <span class="hljs-comment">// 调用 res.end() 方法，向客户端响应一些内容</span><br>  res.<span class="hljs-title function_">end</span>(str)<br>&#125;)<br></code></pre></td></tr></table></figure><p>当调用 res.end() 方法，向客户端发送中文内容的时候，会出现乱码问题，此时，需要手动设置内容的编码格式，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 调用 res.setHeader() 方法，设置 Content-Type 响应头，解决中文乱码的问题</span><br> res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/html; charset=utf-8&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="5-模块化概念"><a href="#5-模块化概念" class="headerlink" title="5.模块化概念"></a>5.模块化概念</h2><figure class="highlight plaintext"><figcaption><span>规定</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Node.js```遵循了``CommonJS``模块化规范，CommonJS"><br>- 每个模块内部，module 变量代表当前模块<br>- module 变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口<br>- 加载某个模块，其实是加载该模块的 module.exports 属性。require() 方法用于加载模块<br><br>分类：<br><br>- **内置模块**（内置模块是由 Node.j s 官方提供的，例如 fs、path、http 等）<br><br>- **自定义模块**（用户创建的每个 .js 文件，都是自定义模块）<br><br>- **第三方模块**（由第三方开发出来的模块，使用前需要先下载）<br><br>  ```js<br>  const fs = require(&#x27;fs&#x27;)// 内置模块<br>  const custom = require(&#x27;./custom.js&#x27;)// 自定义模块，需指明路径，可以省略 .js 的后缀名<br>  const moment = require(&#x27;moment&#x27;)// 第三方模块<br></code></pre></td></tr></table></figure><blockquote><p>tip：使用 require() 方法加载其它模块时，会<strong>执行</strong>被加载模块中的代码</p></blockquote><p>模块作用域：</p><p>在自定义模块中定义的<strong>变量、方法</strong>等成员，只能在当前模块内被访问。好处是防止了全局变量污染的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 模块作用域</span><br><span class="hljs-keyword">const</span> username = <span class="hljs-string">&#x27;张三&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;大家好，我是&#x27;</span> + username)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> custom = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./模块作用域&#x27;</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(custom) <span class="hljs-comment">//输出为&#123;&#125;</span><br></code></pre></td></tr></table></figure><p>向外共享模块作用域中的成员方式：</p><ol><li><p><code>module</code>对象</p><p>在每个.js自定义模块中都有一个moudle对象，它存储了和当前模块有关的信息</p><ul><li>可以使用<code>module.exports</code>对象，将模块内的成员共享出去</li><li>外界用<code>require()</code>方法导入，得到的就是 <code>module.exports</code> 所指向的对象，默认该属性是<code>&#123;&#125;</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在一个自定义模块中，默认情况下， module.exports = &#123;&#125;</span><br><span class="hljs-keyword">const</span> age = <span class="hljs-number">20</span><br><br><span class="hljs-comment">// 向 module.exports 对象上挂载 username 属性</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">username</span> = <span class="hljs-string">&#x27;zs&#x27;</span><br><span class="hljs-comment">// 向 module.exports 对象上挂载 sayHello 方法</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">// 让 module.exports 指向一个全新的对象</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">nickname</span>: <span class="hljs-string">&#x27;小黑&#x27;</span>,<br>  <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hi!&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>require（）得到的是这个全新的对象</p></blockquote><ol start="2"><li><p><code>export</code>对象</p><p>默认情况下，exports 和 module.exports 指向同一个对象。最终共享的结果，还是以 module.exports 指向的对象为准。 </p></li><li><p>联系</p><p>只是在刚开始<code>export</code>和<code>module.export</code>共享数据，本来都为{}，其中一个有了指向对象另外的也有了，之后的改变便<strong>不同步</strong>了。</p><blockquote><p>不建议同时使用</p></blockquote></li></ol><h2 id="6-npm与包"><a href="#6-npm与包" class="headerlink" title="6.npm与包"></a>6.npm与包</h2><p>Node.js 中的第三方模块又叫做<strong>包</strong></p><p>npm是包管理工具</p><h3 id="安装包后多了哪些文件"><a href="#安装包后多了哪些文件" class="headerlink" title="安装包后多了哪些文件"></a>安装包后多了哪些文件</h3><p>**node_modules **</p><p>用来存放所有已安装到项目中的包。require() 导入第三方包时，从这个目录中查找并加载</p><p><strong>package-lock.json</strong></p><p>记录 node_modules 目录下的每一个包的下载信息，例如包的名字、版本号、下载地址等</p><h3 id="安装指定版本的包"><a href="#安装指定版本的包" class="headerlink" title="安装指定版本的包"></a>安装指定版本的包</h3><p>npm install 命令默认安装最新版本的包。如需安装指定版本的包，在包名之后，@</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Git">npm i 包的完整名称@版本号<br></code></pre></td></tr></table></figure><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>包的版本号以“点分十进制”形式进行定义，总共有三位数字，如 2.24.0。其中每一位数字所代表的的含义如下</p><ul><li>第1位数字：<strong>大版本</strong></li><li>第2位数字：<strong>功能版本</strong></li><li>第3位数字：<strong>Bug修复版本</strong></li></ul><p>版本号提升的规则：只要前面的版本号增长了，则后面的版本号归零</p><h3 id="多人协作的问题"><a href="#多人协作的问题" class="headerlink" title="多人协作的问题"></a>多人协作的问题</h3><p><strong>package.json</strong></p><p>第三方包的体积过大，不方便团队成员之间共享项目源代码。</p><p>故要把 node_modules文件夹，添加到 .gitignore 忽略文件中。</p><p><code>package.json</code> <strong>记录项目中安装了哪些包</strong>，<code>npm init -y</code>快速创建<code>package.json</code>这个包管理配置文件。</p><p>执行npm install 命令时，npm 包管理工具会先读取package. json中的dependencies 节点，读取到记录的所有依赖包名称和版本号之后，npm包管理工具会把这些包-次性下载到项目中。</p><h3 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h3><p>运行 <code>npm uninstall</code> 命令，来卸载指定的包，没有简写形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">npm uninstall 包名<br></code></pre></td></tr></table></figure><h3 id="devDependencies节点"><a href="#devDependencies节点" class="headerlink" title="devDependencies节点"></a><strong>devDependencies节点</strong></h3><p>只在项目开发阶段会用到，项目上线之后不会用：记录到 <strong>devDependencies</strong>节点</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmd">//完整写法 包名和--save-dev顺序不重要<br>npm install 包名 --save-dev     <br>或<br>//常用简写<br>npm i 包名 -D<br></code></pre></td></tr></table></figure><p>开发和项目上线之后都需要用到：记录到 **dependencies **节点</p><h3 id="i5ting-toc"><a href="#i5ting-toc" class="headerlink" title="i5ting_toc"></a>i5ting_toc</h3><p>i5ting_toc 是一个可以把 md 文档转为 html 页面的小工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">npm i i5ting_toc -g# 安装<br>i5ting_toc -f sample.md -o# 在sample.md目录下转换<br></code></pre></td></tr></table></figure><h2 id="7-开发属于自己的包"><a href="#7-开发属于自己的包" class="headerlink" title="7.开发属于自己的包"></a>7.开发属于自己的包</h2><h3 id="规范的包结构"><a href="#规范的包结构" class="headerlink" title="规范的包结构"></a>规范的包结构</h3><p>组成结构，必须符合以下 3 点要求</p><ul><li>包必须以单独的目录而存在</li><li>包的顶级目录（点进去的目录）下要必须包含 package.json 这个包管理配置文件</li><li>package.json 中必须包含 name，version，main这三个属性，分别代表包的名字、版本号、包的入口(.js文件)（require()加载的文件）</li></ul><blockquote><p>name不能和已有的重复，和文件夹名字无关。main表示入口文件。</p></blockquote><p>包的入口文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src 文件夹下开发代码，导入到 index.js 中</span><br><span class="hljs-keyword">const</span> date = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./src/dateFormat&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">escape</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./src/htmlEscape&#x27;</span>)<br><br><span class="hljs-comment">// 向外暴露需要的成员</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  ...date,<span class="hljs-comment">// ... 展开运算符，将data所有属性交给新对象</span><br>  ...<span class="hljs-built_in">escape</span><span class="hljs-comment">// ... 展开运算符，将escape所有属性交给新对象</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h3><ul><li><a href="https://www.npmjs.com/">https://www.npmjs.com/</a> 注册 npm 账号，终端中执行 npm login 命令，依次输入用户名、密码、邮箱后，即可登录成功</li></ul><p> 注意：执行命令前，必须先把下包的服务器地址切换为 npm 的官方服务器。否则会导致发布包失败！先用nrm命令检查一下，nrm use 命令切换。终端切换到包的根目录之后，运行 npm publish 命令，即可将包发布到 npm 上（注意：包名不能雷同）</p><p>运行 npm unpublish 包名 –force命令，即可从 npm 删除已发布的包</p><ul><li>npm unpublish 命令只能删除 72 小时以内发布的包</li><li>npm unpublish 删除的包，在 24 小时内不允许重复发布</li><li>发布包的时候要慎重，尽量不要往 npm 上发布没有意义的包</li></ul><h2 id="8-模块的加载机制"><a href="#8-模块的加载机制" class="headerlink" title="8.模块的加载机制"></a>8.模块的加载机制</h2><p>模块在第一次加载后（第一次<strong>require()后</strong>）会被缓存。也就是说多次调用 <strong>require()</strong> 模块的代码只会被执行一次。</p><p>不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率。</p><p>内置模块的加载机制</p><ul><li>内置模块的加载优先级最高（当第三方模块和内置模块同名时）</li></ul><p>自定义模块的加载机制</p><ul><li><p>使用 require() 加载自定义模块时，必须指定以 .&#x2F; 或 …&#x2F; 开头的路径标识符。在加载自定义模块时，如果没有指定 .&#x2F; 或 …&#x2F; 这样的路径标识符，则 node 会把它当作内置模块或第三方模块进行加载。</p></li><li><p>在使用 require() 导入自定义模块时，如果省略了文件的扩展名，Node.js 会按顺序分别尝试加载以下的文件</p><ul><li>按照确切的文件名进行加载</li><li>补全 .js 扩展名进行加载</li><li>补全 .json 扩展名进行加载</li><li>补全 .node 扩展名进行加载</li><li>加载失败，终端报错</li></ul></li></ul><p>第三方模块的加载机制</p><ul><li>如果传递给 require() 的模块标识符不是一个内置模块，也没有以 .&#x2F; 或 …&#x2F; 开头，则 Node.js 会从当前模块的父目录开始，尝试从 &#x2F;node_modules 文件夹中加载第三方模块</li><li>如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录</li><li>假设在 ‘C:\Users\itheima\project\node_modules\a.js’ 里调用 require(‘tools’)，Node.js 会按以下顺序查找</li></ul><p>如果加载的是目录</p><ul><li>当把目录作为模块标识符，传递给 require() 进行加载的时候，有三种加载方式</li><li>在被加载的目录下查找一个叫做 package.json 的文件，并寻找 main 属性值作为 require() 加载的入口</li><li>如果目录里没有 package.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 index.js 文件<br>如果以上两步都失败了，则 Node.js 会在终端打印错误消息，报告模块的缺失：Error: Cannot find module ‘xxx’</li></ul><h2 id="9-Express"><a href="#9-Express" class="headerlink" title="9.Express"></a>9.Express</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架<br>通俗的理解：Express 的作用和 Node.js 内置的 http 模块类似，是专门用来创建 Web 服务器的。<br>本质就是一个 npm 上的第三方包，提供了快速创建 Web 服务器的便捷方法<br>中文官网 <a href="http://www.expressjs.com.cn/">http://www.expressjs.com.cn/</a></p><blockquote><p>不使用 Express 能否创建 Web 服务器？<br>能，使用 Node.js 提供的原生 http 模块即可<br>有了 http 内置模块，为什么还有用 Express？<br>http 内置模块用起来很复杂，开发效率低；<br>Express 是基于内置的 http 模块进一步封装出来的，能够极大的提高开发效率<br>http 内置模块与 Express 是什么关系？<br>类似于浏览器中 Web API 和 jQuery 的关系。后者是基于前者进一步封装出来的</p></blockquote><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li>在项目所处的目录中安装</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">npm i express<br></code></pre></td></tr></table></figure><ul><li>创建基本的 Web 服务器</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express);// 导入express</span><br><span class="hljs-string">                        </span><br><span class="hljs-string">const app = express();// 创建web服务器</span><br><span class="hljs-string"></span><br><span class="hljs-string">app.listen(80, () =&gt; &#123;// 调用回调函数，listen() 启动服务器</span><br><span class="hljs-string">console.log(&#x27;</span>express server running at <span class="hljs-attr">http</span>:<span class="hljs-comment">//127.0.0.1&#x27;)</span><br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>处理请求</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 导入 express</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">// 2. 创建 web 服务器</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br><span class="hljs-comment">// 4. 监听客户端的 GET 和 POST 请求，并向客户端响应具体的内容</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 调用 express 提供的 res.send() 方法，向客户端响应一个  JSON 对象</span><br>  res.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;男&#x27;</span> &#125;)<br>&#125;)<br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 调用 express 提供的 res.send() 方法，向客户端响应一个  文本字符串</span><br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;请求成功&#x27;</span>)<br>&#125;)<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123; <br>  <span class="hljs-comment">// 通过 req.query 可以获取到客户端发送过来的 查询参数 ‘/’表示ip根目录</span><br>  <span class="hljs-comment">// 注意：默认情况下，req.query 是一个空对象</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">query</span>)<br>  res.<span class="hljs-title function_">send</span>(req.<span class="hljs-property">query</span>)<br>&#125;)<br><br><br><span class="hljs-comment">// 注意：这里的 :id 是一个动态的参数</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/:id/:username&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// req.params 是动态匹配到的 URL 参数，默认也是一个空对象</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">params</span>)<br>  res.<span class="hljs-title function_">send</span>(req.<span class="hljs-property">params</span>)<br>&#125;)<br><br><span class="hljs-comment">// 3. 启动 web 服务器</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;express server running at http://127.0.0.1&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>:id 是一个动态的参数，‘：’是固定的写法，可以有多个参数，其中id 是该参数名字，而req.params可以动态匹配该参数的值。</p></blockquote><h3 id="托管静态资源"><a href="#托管静态资源" class="headerlink" title="托管静态资源"></a>托管静态资源</h3><ul><li>express.static()，可以非常方便地创建一个静态资源服务器，</li></ul><p>  例如，通过如下代码就可以将 public 目录下的图片、CSS 文件、JavaScript 文件对外开放访问了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>))<br></code></pre></td></tr></table></figure><blockquote><p>注意：Express 在指定的静态目录中查找文件，对外提供资源访问路径，目录名不会出现在 URL 中</p></blockquote><h3 id="挂载路径前缀"><a href="#挂载路径前缀" class="headerlink" title="挂载路径前缀"></a>挂载路径前缀</h3><p>如果希望在托管的静态资源访问路径之前，挂载路径前缀，则可以使用如下的方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/public&#x27;</span>, express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>))<br></code></pre></td></tr></table></figure><h3 id="Express-路由"><a href="#Express-路由" class="headerlink" title="Express 路由"></a>Express 路由</h3><p>在 Express 中，路由指的是客户端的请求与服务器处理函数之间的映射关系</p><ul><li>Express 中的路由分 3 部分组成，分别是请求的类型、请求的 URL 地址、处理函数，格式如下</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">method</span>(path, <span class="hljs-title function_">handler</span>())<span class="hljs-comment">// method 具体为 get post 等</span><br></code></pre></td></tr></table></figure><p>在 Express 中使用路由最简单的方式，就是把路由挂载到 app 上，示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br><span class="hljs-comment">// 挂载路由</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;hello world.&#x27;</span>)&#125;)<br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Post Request.&#x27;</span>)&#125;)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;express server running at http://127.0.0.1&#x27;</span>)&#125;)<br></code></pre></td></tr></table></figure><p><strong>模块化路由</strong></p><p>为了方便对路由进行模块化的管理，Express 不建议将路由直接挂载到 app 上，而是推荐将路由抽离为单独的模块。将路由抽离为单独模块的步骤如下</p><ul><li>创建路由模块对应的 .js 文件</li><li>调用 express.Router() 函数创建路由对象</li><li>向路由对象上挂载具体的路由</li><li>使用 module.exports 向外共享路由对象</li><li>使用 app.use() 函数注册路由模块</li></ul><p>新建router.js路由</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 路由模块 router.js</span><br><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<span class="hljs-comment">// 1. 导入 express</span><br><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>()<span class="hljs-comment">// 2. 创建路由对象</span><br><br><span class="hljs-comment">// 3. 挂载具体的路由</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/list&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Get user list.&#x27;</span>)&#125;)<br>router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user/add&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Add new user.&#x27;</span>)&#125;)<br><br><span class="hljs-comment">// 4. 向外导出路由对象 </span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> router = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./router&#x27;</span>)<span class="hljs-comment">// 1. 导入路由模块</span><br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/api&#x27;</span>, router)<span class="hljs-comment">// 2. 注册路由模块，若想使用静态资源一样可以加统一的访问前缀</span><br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;http://127.0.0.1&#x27;</span>)&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>app.use() 函数的作用，就是来注册全局中间件</p></blockquote><h3 id="Express-中间件"><a href="#Express-中间件" class="headerlink" title="Express 中间件"></a>Express 中间件</h3><p>格式</p><ul><li>Express 的中间件，本质上就是一个 <strong>function 处理函数</strong>，Express 中间件的格式如下</li><li>注意：中间件函数的形参列表中，必须包含 <strong>next 参数</strong>，而路由处理函数中只包含 req 和 res</li></ul><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230427221631354.png" alt="image-20230427221631354" style="zoom:80%;"><ul><li><p>next 函数是实现多个中间件连续调用的关键，它表示把流转关系<strong>转交</strong>给下一个中间件或路由</p><p>全局生效的中间件：是客户端发起的任何请求，达到服务器之后，都会触发的中间件。</p></li></ul><blockquote><p>请求先到服务器——&gt;中间件——&gt;下一个中间件，没有就开始匹配路由。</p></blockquote><p>通过**app.use(中间件函数)**，定义全局中间件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br><span class="hljs-comment">//mw指向的就是一个中间件函数</span><br><span class="hljs-keyword">const</span> mw = <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;这是最简单的中间件函数&#x27;</span>)<br>  <span class="hljs-comment">// 把流转关系，转交给下一个中间件或路由</span><br>  <span class="hljs-title function_">next</span>()<br>&#125;<br><br><span class="hljs-comment">// 将 mw 注册为全局生效的中间件</span><br>app.<span class="hljs-title function_">use</span>(mw)<br><br><span class="hljs-comment">// 这是定义全局中间件的简化形式</span><br><span class="hljs-comment">// app.use((req, res, next) =&gt; &#123;</span><br><span class="hljs-comment">//   console.log(&#x27;这是最简单的中间件函数&#x27;)</span><br><span class="hljs-comment">//   next()</span><br><span class="hljs-comment">// &#125;)</span><br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用了 / 这个路由&#x27;</span>)<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Home page.&#x27;</span>)<br>&#125;)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;http://127.0.0.1&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p><a href="http://127.0.0.1/%E8%AF%B7%E6%B1%82%E5%85%88%E5%88%B0mv%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%A4%84%E7%90%86%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E5%88%B0%E4%B8%8B%E4%B8%80%E4%B8%AA%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%8C%E7%94%B1%E4%BA%8E%E6%B2%A1%E6%9C%89%E4%B8%8B%E4%B8%80%E4%B8%AA%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%8C%E5%B0%B1%E5%BC%80%E5%A7%8B%E5%8C%B9%E9%85%8D%E8%B7%AF%E7%94%B1%E3%80%82">http://127.0.0.1/请求先到mv中间件处理，然后再到下一个中间件，由于没有下一个中间件，就开始匹配路由。</a></p><p>中间件的作用</p><ul><li>多个中间件之间，共享同一份 req和 res。</li><li>基于这样的特性，我们可以在上游的中间件中，统一为 req 或 res 对象添加自定义的属性或方法，供下游的中间件或路由进行使用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br><span class="hljs-comment">//定义全局中间件的简化形式</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> time = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<span class="hljs-comment">// 获取到请求到达服务器的时间</span><br>  req.<span class="hljs-property">startTime</span> = time<br>    <span class="hljs-comment">// 为 req 对象，挂载自定义属性，从而把时间共享给后面的所有路由！！！！！！！！！！</span><br>  <span class="hljs-title function_">next</span>()<br>&#125;)<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Home page.&#x27;</span> + req.<span class="hljs-property">startTime</span>)&#125;)<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;User page.&#x27;</span> + req.<span class="hljs-property">startTime</span>)&#125;)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;http://127.0.0.1&#x27;</span>)&#125;)<br></code></pre></td></tr></table></figure><p><strong>定义多个全局中间件</strong>，按照顺序先后调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br><span class="hljs-comment">// 定义第一个全局中间件</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用了第1个全局中间件&#x27;</span>)<br>  <span class="hljs-title function_">next</span>()<br>&#125;)<br><span class="hljs-comment">// 定义第二个全局中间件</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用了第2个全局中间件&#x27;</span>)<br>  <span class="hljs-title function_">next</span>()<br>&#125;)<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;User page.&#x27;</span>)&#125;)<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;http://127.0.0.1&#x27;</span>)&#125;)<br></code></pre></td></tr></table></figure><p>局部生效的中间件<strong>：</strong>不使用 app.use() 定义的中间件叫做局部生效的中间件</p><p><strong>定义多个局部中间件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br><span class="hljs-comment">// 1. 定义中间件函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">mw1</span> = (<span class="hljs-params">req, res, next</span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用了局部生效的中间件&#x27;</span>)<br>  <span class="hljs-title function_">next</span>()<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">mw2</span> = (<span class="hljs-params">req, res, next</span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用了第二个局部生效的中间件&#x27;</span>)<br>  <span class="hljs-title function_">next</span>()<br>&#125;<br><br><span class="hljs-comment">// 2. 创建路由，可见mw1，mw2只会在对应有调用的中间件中生效，调用：在get中的url和method中加一个/多个参数</span><br><span class="hljs-comment">//以下两种方式等价</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, mw1, nw2, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Home page.&#x27;</span>)&#125;)<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, [mw1, mw2],<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;User page.&#x27;</span>)&#125;)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Express server running at http://127.0.0.1&#x27;</span>)&#125;)<br></code></pre></td></tr></table></figure><p>中间件的使用注意事项</p><ul><li>一定要在路由之前注册中间件，如果直接匹配到路由就会直接响应了</li><li>执行完中间件的业务代码之后，不要忘记调用**next() **函数</li><li>为了防止代码逻辑混乱，调用 next() 函数后不要再写额外的代码</li><li>连续调用多个中间件时，多个中间件之间，<strong>共享</strong>req 和 res 对象</li></ul><p><strong>中间件的分类</strong></p><ul><li><p>应用级别的中间件（绑定到app实例上）</p></li><li><p>路由级别的中间件（绑定到路由实例上）</p></li><li><p>错误级别的中间件</p><blockquote><p>格式：错误级别中间件的 <strong>function 处理函数中</strong>，必须有 4 个形参，形参<strong>顺序从前到后</strong>，分别是 **(err, req, res, next)**。</p><p>错误级别的中间件，必须注册在所有路由之后！</p></blockquote></li><li><p>Express 内置的中间件</p><ul><li><strong>express.static()</strong> 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（<strong>无兼容性，任何版本都能用</strong>）</li><li>**express.json() **解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</li><li>**express.urlencoded(option) **解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br></code></pre></td></tr></table></figure></li></ul><h2 id="10-使用Express写接口"><a href="#10-使用Express写接口" class="headerlink" title="10.使用Express写接口"></a>10.使用Express写接口</h2><p>1.先创建一个Express服务器，使用express写接口.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express);// 导入express</span><br><span class="hljs-string">                        </span><br><span class="hljs-string">const app = express();// 创建服务器实例</span><br><span class="hljs-string"></span><br><span class="hljs-string">//写别的代码,导入路由模块之类的</span><br><span class="hljs-string"></span><br><span class="hljs-string">app.listen(80, () =&gt; &#123;// 调用回调函数，listen() 启动服务器</span><br><span class="hljs-string">console.log(&#x27;</span>express server running at <span class="hljs-attr">http</span>:<span class="hljs-comment">//127.0.0.1&#x27;)</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>2.创建路由模块,apiRouter.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<span class="hljs-comment">// 1. 导入 express</span><br><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>()<span class="hljs-comment">// 2. 创建路由对象</span><br><br><span class="hljs-comment">// 4. 挂载具体的路由</span><br><br><span class="hljs-comment">// 3. 向外导出路由对象 </span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router<br></code></pre></td></tr></table></figure><p>3.导入路由模块,在express写接口.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express);// 导入express</span><br><span class="hljs-string">                        </span><br><span class="hljs-string">const app = express();// 创建服务器实例</span><br><span class="hljs-string"></span><br><span class="hljs-string">//导入路由模块</span><br><span class="hljs-string">const router = require(&#x27;</span>./apiRouter<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">//把路由模块。注册到app上</span><br><span class="hljs-string">app.use(&#x27;</span>/api<span class="hljs-string">&#x27;, router)</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">app.listen(80, () =&gt; &#123;// 调用回调函数，listen() 启动服务器</span><br><span class="hljs-string">console.log(&#x27;</span>express server running at <span class="hljs-attr">http</span>:<span class="hljs-comment">//127.0.0.1&#x27;)</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>4.1 编写GET接口，在apiRouter.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<span class="hljs-comment">// 1. 导入 express</span><br><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>()<span class="hljs-comment">// 2. 创建路由对象</span><br><br><span class="hljs-comment">// 4. 挂载具体的路由</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/get&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 通过req.query获取客户端通过查询字符串，发送到服务器的数据</span><br>    <span class="hljs-keyword">const</span> query = req.<span class="hljs-property">query</span><br>    <span class="hljs-comment">// 调用res.send()方法，向客户端响应处理的结果</span><br>    res.<span class="hljs-title function_">send</span>(&#123;<br>        <span class="hljs-attr">status</span>: <span class="hljs-number">0</span>,         <span class="hljs-comment">//0表示处理成功，1表示处理失败</span><br>        <span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;GET请求成功！&#x27;</span>, <span class="hljs-comment">//状态描述</span><br>        <span class="hljs-attr">data</span>: query        <span class="hljs-comment">//需要响应给客户端的数据</span><br>    &#125;)<br>&#125;)<br><br><span class="hljs-comment">// 3. 向外导出路由对象 </span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router<br></code></pre></td></tr></table></figure><p>4.2 编写POST接口，在apiRouter.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<span class="hljs-comment">// 1. 导入 express</span><br><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>()<span class="hljs-comment">// 2. 创建路由对象</span><br><br><span class="hljs-comment">// 4. 挂载具体的路由</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/get&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 通过req.query获取客户端通过查询字符串，发送到服务器的数据</span><br>    <span class="hljs-keyword">const</span> query = req.<span class="hljs-property">query</span><br>    <span class="hljs-comment">// 调用res.send()方法，向客户端响应处理的结果</span><br>    res.<span class="hljs-title function_">send</span>(&#123;<br>        <span class="hljs-attr">status</span>: <span class="hljs-number">0</span>,         <span class="hljs-comment">//0表示处理成功，1表示处理失败</span><br>        <span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;GET请求成功！&#x27;</span>, <span class="hljs-comment">//状态描述</span><br>        <span class="hljs-attr">data</span>: query        <span class="hljs-comment">//需要响应给客户端的数据</span><br>    &#125;)<br>&#125;)<br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/post&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 通过req.body获取发送到服务器的URL-encoded数据</span><br>    <span class="hljs-keyword">const</span> body = req.<span class="hljs-property">body</span><br>    <span class="hljs-comment">// 调用res.send()方法，向客户端响应处理的结果</span><br>    res.<span class="hljs-title function_">send</span>(&#123;<br>        <span class="hljs-attr">status</span>: <span class="hljs-number">0</span>,         <span class="hljs-comment">//0表示处理成功，1表示处理失败</span><br>        <span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;GET请求成功！&#x27;</span>, <span class="hljs-comment">//状态描述</span><br>        <span class="hljs-attr">data</span>: body        <span class="hljs-comment">//需要响应给客户端的数据</span><br>    &#125;)<br>&#125;)<br><span class="hljs-comment">// 3. 向外导出路由对象 </span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router<br></code></pre></td></tr></table></figure><blockquote><p>注意: 如果要获取URL-encoded格式的请求体数据，必须配置中间件app.use(express.urlencoded({ extended: false ))，在express写接口.js中</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express);// 导入express</span><br><span class="hljs-string">                        </span><br><span class="hljs-string">const app = express();// 创建服务器实例</span><br><span class="hljs-string"></span><br><span class="hljs-string">//配置解析表单数据的中间件</span><br><span class="hljs-string">app.use(express.urlencoded(&#123; extended: false )) </span><br><span class="hljs-string">//导入路由模块</span><br><span class="hljs-string">const router = require(&#x27;</span>./apiRouter<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">//把路由模块。注册到app上</span><br><span class="hljs-string">app.use(&#x27;</span>/api<span class="hljs-string">&#x27;, router)</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">app.listen(80, () =&gt; &#123;// 调用回调函数，listen() 启动服务器</span><br><span class="hljs-string">console.log(&#x27;</span>express server running at <span class="hljs-attr">http</span>:<span class="hljs-comment">//127.0.0.1&#x27;)</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="CORS-跨域资源共享"><a href="#CORS-跨域资源共享" class="headerlink" title="CORS 跨域资源共享"></a>CORS 跨域资源共享</h3><p>刚才编写的 GET 和 POST接口，存在一个很严重的问题：不支持跨域请求，解决接口跨域问题的方案主要有两种</p><ul><li>CORS（主流解决方案，推荐）</li><li>JSONP（有缺陷：只支持 GET 请求）</li></ul><p>使用 CORS 中间件解决跨域问题，步骤分为如下 3 步</p><ul><li>运行 <code>npm install cors </code>安装中间件</li><li>使用 <code>const cors = require(‘cors’) </code>导入中间件</li><li>在路由之前调用 <code>app.use(cors()) </code>配置中间件</li></ul><blockquote><p>要在所有路由之前，配置cors中间件</p></blockquote><h2 id="11-Express项目操作数据库"><a href="#11-Express项目操作数据库" class="headerlink" title="11.Express项目操作数据库"></a>11.Express项目操作数据库</h2><p>步骤：</p><ol><li><p>安装操作MySQL数据库的第三方模块（mysql）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">npm install mysql<br></code></pre></td></tr></table></figure></li><li><p>通过mysql模块连接到MySQL数据库</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1. 导入myql模块</span><br><span class="hljs-keyword">const</span> mysql = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mysql&#x27;</span>)<br><span class="hljs-comment">//2. 建立于MySQL数据库的连接</span><br><span class="hljs-keyword">const</span> db = mysql.<span class="hljs-title function_">createPool</span>(&#123;<br>    <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>    <span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;root&#x27;</span>,<br>    <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;123456&#x27;</span>,<br>    <span class="hljs-attr">database</span>: <span class="hljs-string">&#x27;my_db_01&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>通过mysql模块执行SQL语句</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1. 导入myql模块</span><br><span class="hljs-keyword">const</span> mysql = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mysql&#x27;</span>)<br><span class="hljs-comment">//2. 建立于MySQL数据库的连接</span><br><span class="hljs-keyword">const</span> db = mysql.<span class="hljs-title function_">createPool</span>(&#123;<br>    <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>    <span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;root&#x27;</span>,<br>    <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;123456&#x27;</span>,<br>    <span class="hljs-attr">database</span>: <span class="hljs-string">&#x27;my_db_01&#x27;</span><br>&#125;)<br><span class="hljs-comment">//3. 测试mysql模块能否正常工作</span><br>db.<span class="hljs-title function_">query</span>(<span class="hljs-string">&#x27;select 1&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,results</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>    <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results)<br>&#125;)<br></code></pre></td></tr></table></figure><p> 查询</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sqlStr = <span class="hljs-string">&#x27;select * FROM users&#x27;</span><br>db.<span class="hljs-title function_">query</span>(sqlStr,<span class="hljs-function">(<span class="hljs-params">err,results</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>    <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results)<br>&#125;)<br></code></pre></td></tr></table></figure></li></ol><h2 id="12-身份认证"><a href="#12-身份认证" class="headerlink" title="12.身份认证"></a>12.身份认证</h2><p>不同开发模式下的身份认证</p><ul><li>服务端渲染推荐使用Session认证机制</li><li>前后端分离推荐使用 JWT认证机制</li></ul><h3 id="Session认证机制"><a href="#Session认证机制" class="headerlink" title="Session认证机制"></a>Session认证机制</h3><p>由于HTTP协议的无状态性，服务器不会主动保留每次HTTP请求的状态。会话（Session）跟踪是Web程序中常用的技术，用来<strong>跟踪用户的整个会话</strong>，最主要的目的是<strong>帮助服务器记住客户端状态</strong>（标识用户，跟踪状态）。</p><p>常用的会话跟踪技术是<code>Cookie</code>与<code>Session</code>。<strong>Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。</strong></p><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p><strong>Cookie</strong>类比于会员卡。比如生活中的超市，付钱买东西操作。服务员不会记得你是不是会员，除非你有会员卡。</p><p>Cookie是存储在用户浏览器中的一段不超过4 KB的字符串。它由一个名称(Name)、一个值(Value) 和其它几个用于控制Cookie有效期、安全性、使用范围的可选属性组成。特性：</p><ul><li>自动发送</li><li>域名独立</li><li>过期时限</li><li>4KB限制</li></ul><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230427221713313.png" alt="image-20230427221713313"></p><p>由于Cookie是存储在浏览器中的，而且浏览器也提供了读写Cookie的API,因此<strong>Cookie很容易被伪造</strong>,不具有安全性。因此不建议服务器将重要的隐私数据，</p><p>通过Cookie的形式发送给浏览器。</p><p>为了解决安全性问题，服务器根据请求中携带的Cookie要从内存中查找对应的用户信息。这样除了客户端用到Cookie，服务端也用到session确认用户身份。</p><p><strong>Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份</strong>。</p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>Express使用Session认证：</p><ol><li>安装express-session中间件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">npm install express-session<br></code></pre></td></tr></table></figure><ol start="2"><li>配置express-session中间件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1.导入session 中间件</span><br><span class="hljs-keyword">var</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-session&#x27;</span> )<br><br><span class="hljs-comment">// 2.配置Seesion中间件</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">session</span>(&#123;<br>    <span class="hljs-attr">secret</span>:<span class="hljs-string">&#x27;keyboard cat&#x27;</span>, <span class="hljs-comment">// secret属性的值可以为任意字符串</span><br>    <span class="hljs-attr">resave</span>:<span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">saveUninitialized</span>:<span class="hljs-literal">true</span><br>&#125;))<br></code></pre></td></tr></table></figure><ol start="3"><li>向session中存数据</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/login&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 判断用户提交的登录信息是否正确</span><br>    <span class="hljs-keyword">if</span>(req.<span class="hljs-property">body</span>.<span class="hljs-property">username</span> !==<span class="hljs-string">&#x27;admin&#x27;</span>|| req.<span class="hljs-property">body</span>.<span class="hljs-property">password</span>!=<span class="hljs-string">&#x27;000000&#x27;</span>)&#123;<br>        <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">send</span>(&#123;<span class="hljs-attr">status</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;登录失败&#x27;</span>&#125;)<br>    &#125;<br>    req.<span class="hljs-property">session</span>.<span class="hljs-property">userinfo</span> = req.<span class="hljs-property">body</span> <span class="hljs-comment">//将用户信息保存到Session中</span><br>    req.<span class="hljs-property">session</span>.<span class="hljs-property">islogin</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">//将用户登录状态，存储到Session中</span><br>    <br>    res.<span class="hljs-title function_">send</span>(&#123;<span class="hljs-attr">status</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;登录成功&#x27;</span>&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="4"><li>从session中取数据</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/username&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 判断用户是否登录</span><br>    <span class="hljs-keyword">if</span>(！req.<span class="hljs-property">session</span>.<span class="hljs-property">islogin</span>)&#123;<br>        <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">send</span>(&#123;<span class="hljs-attr">status</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;fail&#x27;</span>&#125;)<br>    &#125;<br>       <br>    res.<span class="hljs-title function_">send</span>(&#123;<span class="hljs-attr">status</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;success&#x27;</span>,<span class="hljs-attr">username</span>:req.<span class="hljs-property">session</span>.<span class="hljs-property">user</span>.<span class="hljs-property">username</span>&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>5.清空当前用户的session</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">req.<span class="hljs-property">session</span>.<span class="hljs-title function_">destory</span>()<br></code></pre></td></tr></table></figure><p>Session认证机制需要配合Cookie才能实现。由于Cookie默认不支持跨域访问,所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域Session认证。</p><h3 id="JWT认证机制"><a href="#JWT认证机制" class="headerlink" title="JWT认证机制"></a>JWT认证机制</h3><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230427221734114.png" alt="image-20230427221734114"></p><p>组成</p><p>JWT通常由三部分组成，分别是Header (头部)、Payload (有效荷载)、Signature (签名)。</p><p>三者之间使用英文的”.” 分隔，其中</p><ul><li>Payload 部分才是真正的用户信息，它是用户信息经过加密之后生成的字符串。</li><li>Header 和Signature是安全性相关的部分，只是为了保证Token的安全性。</li></ul><p>流程：</p><ul><li><p>客户端收到服务器返回的JWT之后，通常会将它储存在localStorage或sessionStorage中。</p></li><li><p>此后，客户端每次与服务器通信，都要带上这个JWT的字符串,从而进行身份认证。推荐的做法是把JWT放在HTTP请求头的Authorization字段中，格式如下:</p></li></ul><blockquote><p>Authorization: Bearer <token></token></p></blockquote><h4 id="Express使用-JWT认证"><a href="#Express使用-JWT认证" class="headerlink" title="Express使用 JWT认证"></a>Express使用 JWT认证</h4><ol><li>安装JWT相关的包</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">npm install jsonwebtoken express-jwt<br></code></pre></td></tr></table></figure><p>其中:</p><ul><li>jsonwebtoken 用于生成JWT字符串</li><li>express-jwt 用于将JWT字符串解析还原成JSON对象</li></ul><ol start="2"><li>导入JWT相关的包</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1.导入用于生产 JWT 字符串的包</span><br><span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jsonwebtoken&#x27;</span> )<br><span class="hljs-comment">// 2.导入用于将客户端发送过来的JWT字符串，解析还原成JSON 对象的包</span><br><span class="hljs-keyword">const</span> expressJWT = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-jwt&#x27;</span>)<br></code></pre></td></tr></table></figure><ol start="3"><li>定义secret密钥<br>①当生成JWT字符串的时候,需要使用secret密钥对用户的信息进行加密，最终得到加密好的JWT字符串<br>②当把JWT字符串解析还原成JSON对象的时候，需要使用secret密钥进行解密</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> secretKey = <span class="hljs-string">&#x27;suibian&#x27;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>在登录成功后生成JWT字符串</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/login&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 判断用户提交的登录信息是否正确</span><br>    <span class="hljs-keyword">if</span>(req.<span class="hljs-property">body</span>.<span class="hljs-property">username</span> !==<span class="hljs-string">&#x27;admin&#x27;</span>|| req.<span class="hljs-property">body</span>.<span class="hljs-property">password</span>!=<span class="hljs-string">&#x27;000000&#x27;</span>)&#123;<br>        <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">send</span>(&#123;<span class="hljs-attr">status</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;登录失败&#x27;</span>&#125;)<br>    &#125;<br>    res.<span class="hljs-title function_">send</span>(&#123;<br>        <span class="hljs-attr">status</span>:<span class="hljs-number">0</span>,<br>        <span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;登录成功&#x27;</span>,<br>        <span class="hljs-comment">//调用jwt,sign() 生成JWT字符串，三个参数分别是:用户信息对象、加密密钥、配置对象</span><br>        <span class="hljs-attr">token</span>: jwt.<span class="hljs-title function_">sign</span>(&#123; <span class="hljs-attr">username</span>: user info.<span class="hljs-property">username</span> &#125;，secretKey, &#123; <span class="hljs-attr">expiresIn</span>:<span class="hljs-string">&#x27; 30s&#x27;</span><br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="5"><li>将JWT字符串还原为JSON对象</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> secretKey = <span class="hljs-string">&#x27;suibian&#x27;</span><br><span class="hljs-comment">// .unless(&#123; path: [/^\/api\//] &#125;)//指定哪些接口不需要访问权限</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">expressJWT</span>(&#123; <span class="hljs-attr">secret</span>: secretKey &#125;).<span class="hljs-title function_">unless</span>(&#123; <span class="hljs-attr">path</span>: [<span class="hljs-regexp">/^\/api\//</span>] &#125;))<br></code></pre></td></tr></table></figure><ol start="6"><li>使用req.user获取用户信息</li></ol><blockquote><p>req.user中的信息时加密时封的用户信息</p></blockquote><ol start="7"><li>捕获解析JWT失败后产生的错误</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">err,req,res,next</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">//token解析失败导致的错误</span><br>    <span class="hljs-keyword">if</span>(err.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;UnauthorizedError&#x27;</span>)&#123;<br>        <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">send</span>(&#123;<br>            <span class="hljs-attr">status</span>:<span class="hljs-number">401</span>,<br>            <span class="hljs-attr">messaage</span>:<span class="hljs-string">&#x27;无效的token&#x27;</span><br>        &#125;)<br>        <span class="hljs-comment">// 其他原因导致的错误</span><br>        res.<span class="hljs-title function_">send</span>(&#123;<br>            <span class="hljs-attr">status</span>:<span class="hljs-number">500</span>,<br>            <span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;未知错误&#x27;</span><br>        &#125;)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>实战项目：<a href="http://www.escook.cn:8088/#/">http://www.escook.cn:8088/#/</a></p>]]></content>
    
    
    <categories>
      
      <category>后端技术栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sass语法规则</title>
    <link href="/2023/03/25/Sass%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99/"/>
    <url>/2023/03/25/Sass%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">npm  install sass-loader --save-dev<br>npm install node-sass --sava-dev<br></code></pre></td></tr></table></figure><h1 id="规则与属性"><a href="#规则与属性" class="headerlink" title="规则与属性"></a>规则与属性</h1><ol><li>嵌套规则</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#main</span> <span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#00ff00</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">97%</span>;<br><br>  <span class="hljs-selector-class">.redbox</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0000</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#000000</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译为</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#main</span> <span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#00ff00</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">97%</span>; &#125;<br>  <span class="hljs-selector-id">#main</span> <span class="hljs-selector-tag">p</span> <span class="hljs-selector-class">.redbox</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0000</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#000000</span>; &#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>父选择器 <code>&amp;</code></li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>  <span class="hljs-attribute">text-decoration</span>: none;<br>  &amp;<span class="hljs-selector-pseudo">:hover</span> &#123; <span class="hljs-attribute">text-decoration</span>: underline; &#125;<br>  <span class="hljs-selector-tag">body</span><span class="hljs-selector-class">.firefox</span> &amp; &#123; <span class="hljs-attribute">font-weight</span>: normal; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译后的 CSS 文件中 <code>&amp;</code> 将被替换成嵌套外层的父选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>  <span class="hljs-attribute">text-decoration</span>: none; &#125;<br>  <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">text-decoration</span>: underline; &#125;<br>  <span class="hljs-selector-tag">body</span><span class="hljs-selector-class">.firefox</span> <span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">font-weight</span>: normal; &#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>属性嵌套</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.funky</span> &#123;<br>  <span class="hljs-attribute">font</span>: &#123;<br>    family: fantasy;<br>    size: <span class="hljs-number">30em</span>;<br>    weight: bold;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译为</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.funky</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: fantasy;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">30em</span>;<br>  <span class="hljs-attribute">font-weight</span>: bold; &#125;<br></code></pre></td></tr></table></figure><ol start="4"><li><p>占位符选择器 <code>%foo</code> (Placeholder Selectors: <code>%foo</code>)</p></li><li><p>变量 <code>$</code> (Variables: <code>$</code>)</p></li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$width</span>: <span class="hljs-number">5em</span>;<br></code></pre></td></tr></table></figure><p>直接使用即调用变量：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#main</span> &#123;<br>  <span class="hljs-attribute">width</span>: $width;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PS快捷键</title>
    <link href="/2023/03/25/ps%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2023/03/25/ps%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="PS快捷键"><a href="#PS快捷键" class="headerlink" title="PS快捷键"></a>PS快捷键</h1><ol><li>调出标尺，Ctrl+R。或者视图—&gt;标尺。右击标尺将单位改成像素</li><li>放大缩小视图：Ctrl+加号（+）可以放大视图，Ctrl-减号（+）可以缩小视图；或者alt+鼠标滚轮</li><li>空格键，鼠标可以变成小手拖动PS视图</li></ol><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/markdown/image-20230626220642128.png" alt="image-20230626220642128"></p><ul><li>图层切图<ul><li>最简单的切图方式:右击图层&gt;快速导出为PNG。</li><li>但是很多情况下，我们需要合并图层再导出:<ul><li>选中需要的图层:图层菜单&gt;合并图层(ctrl+e)</li><li>右击→快速导出为PNG</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ps</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>引入ElementUI的方式</title>
    <link href="/2023/03/25/%E5%BC%95%E5%85%A5ElementUI/"/>
    <url>/2023/03/25/%E5%BC%95%E5%85%A5ElementUI/</url>
    
    <content type="html"><![CDATA[<h1 id="引入ElementUI"><a href="#引入ElementUI" class="headerlink" title="引入ElementUI"></a>引入ElementUI</h1><h2 id="完整引入"><a href="#完整引入" class="headerlink" title="完整引入"></a>完整引入</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ElementUI</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span>;<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">ElementUI</span>);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>)<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="按需引入"><a href="#按需引入" class="headerlink" title="按需引入"></a>按需引入</h2><ol><li><p>安装babel-plugin-component</p><blockquote><p>npm install babel-plugin-component -D  </p></blockquote></li><li><p>在babel.config.js文件中新增plugins</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">plugins</span>: [<br>   [<br>     <span class="hljs-string">&#x27;component&#x27;</span>,<br>     &#123;<br>       <span class="hljs-attr">libraryName</span>: <span class="hljs-string">&#x27;element-ui&#x27;</span>,<br>       <span class="hljs-attr">styleLibraryName</span>: <span class="hljs-string">&#x27;theme-chalk&#x27;</span><br>     &#125;<br>   ]<br> ]<br></code></pre></td></tr></table></figure></li><li><p>在 src 文件夹中新建我们的 element-ui 文件夹，并在里面新建一个 index.js 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Scrollbar</span>, <span class="hljs-title class_">Button</span>, <span class="hljs-title class_">Input</span>, <span class="hljs-title class_">Tree</span>, <span class="hljs-title class_">Message</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$message</span> = <span class="hljs-title class_">Message</span>;<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Scrollbar</span>)<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Button</span>)<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Input</span>)<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Tree</span>)<br> <br><span class="hljs-keyword">import</span> <span class="hljs-title class_">CollapseTransition</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui/lib/transitions/collapse-transition&#x27;</span>;<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-title class_">CollapseTransition</span>.<span class="hljs-property">name</span>, <span class="hljs-title class_">CollapseTransition</span>)<br></code></pre></td></tr></table></figure></li></ol><ul><li>弹窗类组件用 Vue.prototype，如 Message</li><li>大部分组件用 Vue.use，如 Input</li><li>少数组件需用Vue.component注册，如CollapseTransition</li></ul><ol start="4"><li>在main.js中引入  import ‘.&#x2F;element-ui ‘</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://element.eleme.io/#/zh-CN/component/quickstart">Element官网</a></p>]]></content>
    
    
    <categories>
      
      <category>前端技术栈</category>
      
      <category>第三方引入</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ElementUI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora设置腾讯云COS图床</title>
    <link href="/2023/03/22/Typora%E8%AE%BE%E7%BD%AE%E8%85%BE%E8%AE%AF%E4%BA%91COS%E5%9B%BE%E5%BA%8A/"/>
    <url>/2023/03/22/Typora%E8%AE%BE%E7%BD%AE%E8%85%BE%E8%AE%AF%E4%BA%91COS%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="Typora图片永久保存"><a href="#Typora图片永久保存" class="headerlink" title="Typora图片永久保存"></a>Typora图片永久保存</h1><p>腾讯云图床 + PicGo</p><p>腾讯云官网：<a href="https://cloud.tencent.com/">https://cloud.tencent.com/</a></p><p>点击产品–&gt;存储–&gt;对象存储</p><p><img src="https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220629171858610.png" alt="image-20220629171858610"></p><p>点击立即购买（新用户会让免费试用）</p><p><img src="https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220629172156605.png" alt="image-20220629172156605"></p><p>购买之后，进入对象存储–&gt;存储桶列表–&gt;创建存储桶</p><p><img src="https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220629172451620.png" alt="image-20220629172451620"></p><p>存储桶创间完成之后下载PicGo</p><p>下载地址：<a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p><p><img src="https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220804145411246.png" alt="image-20220804145411246"></p><p>点击tags，选择稳定版本2.3.0</p><p>（如果你不知道找不到，点击这个地址直达：<a href="https://github.com/Molunerfinn/PicGo/tags%EF%BC%89">https://github.com/Molunerfinn/PicGo/tags）</a></p><p>如果github访问不了点击（）</p><p><img src="https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220804145506895.png" alt="image-20220804145506895"></p><p>下载完成之后进行配置</p><p><img src="https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220804143830159.png" alt="image-20220804143830159"></p><p>需要填写秘钥。腾讯云进入对象存储–&gt;左侧导航栏最下面，选择，秘钥管理，然后访问秘钥管理</p><p><img src="https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220804143938468.png" alt="image-20220804143938468"></p><p><img src="https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220804143958587.png" alt="image-20220804143958587"></p><p><img src="https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220804144145742.png" alt="image-20220804144145742"></p><p><img src="https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220804144309564.png" alt="image-20220804144309564"></p><p>填写完成之后欧，点击上传区，选择腾讯云COS进行图片上传，这样图片就可以上传到云服务器上了</p><p><img src="https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220804143744212.png" alt="image-20220804143744212"></p><p>最后再typora中配置</p><p>文件–&gt;偏好设置–&gt;图像</p><p><img src="https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220804144600650.png" alt="image-20220804144600650"></p><p>最后可以点击验证上传选项，就可以成功上传了。</p><p>以后在typora中插入图片，就会自动上传到云服务器上了</p><p>如果插入之后没有自动上传，可以尝试重启typora，然后还是不行的话大概率是typora版本的原因，建议更换最新版本。也可以点击图片，然后右键上传图片进行上传，不过还是插入的时候自动上传比较方便。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图床</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git命令</title>
    <link href="/2023/03/22/git%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/03/22/git%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="GIT命令"><a href="#GIT命令" class="headerlink" title="GIT命令"></a>GIT命令</h1><ul><li><strong>git branch</strong>                                         检查自己所处分支</li><li><strong>git checkout -b user</strong>                    新建一个user分支并切换到user分支</li><li><strong>git status</strong>                                      检查所处分支文件状态，绿色代表在暂存区</li><li><strong>git add .</strong>                                             将修改和新增的文件统一放在暂存区</li><li>git reset  +文件名                               将暂存区的文件取消暂存或切换到指定版本</li><li><strong>git commit -m “完成用户列表功能的开发”</strong>        -m添加一个提交消息， 将当前分支提交到仓库中，运行完这句话以后查看状态git status ，当前工作目录应该是干净的</li><li>git push -u origin user                       把本地的分支推送到云端仓库origin中，取名也为user</li><li>git checkout master                           切换到master目录    </li><li><strong>git merge user</strong>                                   将user分支合并到主分支</li><li><strong>git push</strong>                                              将本地的master推送到云端</li><li><strong>git pull</strong>                                                 拉取远程代码</li><li><strong>git clone</strong>                                              克隆项目</li><li>git log                                                    查看日志，会显示commit记录，和版本标识可以用git reset –hard  版本标识  回到相应的版本</li></ul><h1 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h1><p>Git工作区中的文件存在两种状态: </p><ul><li>untracked 未跟踪(未被纳入版本控制)</li><li>tracked已跟踪( 被纳入版本控制)<ul><li>Unmodified未修改状态</li><li>Modified 已修改状态</li><li>Staged已暂存状态</li></ul></li></ul><h1 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h1><ul><li><strong>git tag</strong>                                                           列出已有的标签</li><li><strong>git tag  标签名</strong>                                              创建标签</li><li><strong>git push origin 标签名</strong>                                将标签推送至远程仓库</li><li><strong>git checkout -b  新建分支名  标签名</strong>         检出标签（新建一个创库保存该标签状态）</li></ul><h1 id="IDEA使用Git"><a href="#IDEA使用Git" class="headerlink" title="IDEA使用Git"></a>IDEA使用Git</h1><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230427220919044.png" alt="image-20230427220919044"></p><h1 id="提交规范问题"><a href="#提交规范问题" class="headerlink" title="提交规范问题"></a>提交规范问题</h1><ul><li>feat：新增 + 内容</li><li>refactor： 重构</li><li>fix：修复</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">feat：新增用户管理页面<br><br><span class="hljs-built_in">ref</span>actor：用户管理-用户详情页面修改<br><br>fix：用户管理-找回密码邮箱地址错误修改<br></code></pre></td></tr></table></figure><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230427220943320.png" alt="image-20230427220943320"></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo框架fluid主题配置</title>
    <link href="/2023/03/21/Hexo%20Fluid%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/03/21/Hexo%20Fluid%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><ul><li>进入博客目录执行命令</li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><ul><li><p>在博客目录下创建<code>_config.fluid.yml</code>,复制_config.yml内容</p></li><li><p>修改_config.yml配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>  <span class="hljs-comment"># 指定主题</span><br><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>  <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure></li><li><p>创建关于页</p><p>首次使用主题的「关于页」需要手动创建：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> about<br></code></pre></td></tr></table></figure><p>创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。</p><p>修改后的文件示例如下：</p><p><img src="https://markdown-1307246189.cos.ap-chongqing.myqcloud.com/%20markdown/image-20230427220732482.png" alt="image-20230427220732482"></p></li></ul><h2 id="博客常用命令"><a href="#博客常用命令" class="headerlink" title="博客常用命令"></a>博客常用命令</h2><p>清理缓存</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br></code></pre></td></tr></table></figure><p>发送到服务器</p><p>发表文章</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>发送到服务器</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo <span class="hljs-keyword">generate</span><br></code></pre></td></tr></table></figure><p>运行服务器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">hexo server<br></code></pre></td></tr></table></figure><blockquote><p>可以本地<a href="http://localhost:4000/%E6%9F%A5%E7%9C%8B">http://localhost:4000/查看</a></p></blockquote><p>部署到远程站点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">hexo deploy<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://hexo.fluid-dev.com/docs/guide/">用户手册</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/03/20/hello-world/"/>
    <url>/2023/03/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
